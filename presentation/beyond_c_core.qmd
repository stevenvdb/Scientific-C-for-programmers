# External libraries

## External libraries

- External libraries extend C's capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting).
- Common scientific libraries:
  - **GSL** (GNU Scientific Library)
  - **BLAS/LAPACK** (Linear Algebra)
  - **FFTW** (Fast Fourier Transforms)
  - **HDF5** (Hierarchical data format)
- Benefits:
  - Avoid reinventing the wheel
  - Leverage optimized, tested code
  - Improve performance and portability

## Static vs Dynamic Libraries {.smaller}

| Feature              | Static Library (.a/.lib)         | Dynamic Library (.so/.dll)         |
|----------------------|----------------------------------|------------------------------------|
| Linking time         | Compile time                     | Runtime                            |
| Binary size          | Larger (library included)        | Smaller (library separate)         |
| Portability          | Easier to distribute             | Requires library on target system  |
| Updates              | Recompile to update              | Can update without recompiling     |
| Performance          | Slightly faster (no indirection) | May have overhead at runtime       |

> Use `gcc -static` for static linking, or `-l<libname>` with `-L<path>` for dynamic linking.
> Details differ from library to library: check the documentation

## GNU Scientific Library {.smaller}

- The [GNU Scientific Library](https://www.gnu.org/software/gsl/) (GSL) provides a wide range of mathematical routines
- How to get it:
  - On the cluster: load it as a module, `module load GSL/2.8-GCC-13.3.0` for example
  - On your machine: install it as a system package, `apt-get install libgsl-dev` for example
- How to use it:
  - Include the relevant headers in your code
  - Find relevant link flags with `pkg-config --libs gsl` for example

## Minimizing a function with GSL

```{.c}
double f(double x, void *params) {
    Params *p = (Params *) params;
    return exp(-p->sigma*x*x)*sin(p->a + p->b*x);
}
typedef struct {
    double a, b, sigma;
} Params;

Params params = {0.3, 1.0, 0.05};
```

---

```{.c}
double minimum = -1.0, lower = -3.0, upper = 0.0;
int iter = 0, maxIter = 100, status;
const gsl_min_fminimizer_type *T = gsl_min_fminimizer_brent;
gsl_min_fminimizer *minimizer = gsl_min_fminimizer_alloc(T);
gsl_function F;
F.function = &f;
F.params = (void *) &params;
gsl_min_fminimizer_set(minimizer, &F, minimum, lower, upper);
do {
    gsl_min_fminimizer_iterate(minimizer);
    lower = gsl_min_fminimizer_x_lower(minimizer);
    upper = gsl_min_fminimizer_x_upper(minimizer);
    status = gsl_min_test_interval(lower, upper, 1.0e-6, 0.0);
} while (status == GSL_CONTINUE && ++iter < maxIter);
if (status == GSL_SUCCESS) {
    minimum = gsl_min_fminimizer_x_minimum(minimizer);
    …
}
gsl_min_fminimizer_free(minimizer);
```

## BLAS & LAPACK: High-Performance Linear Algebra {.smaller}

- **BLAS** (Basic Linear Algebra Subprograms)
  - Low-level routines for vector and matrix operations
  - Levels:
    - Level 1: Vector-vector (e.g., dot product)
    - Level 2: Matrix-vector (e.g., solving triangular systems)
    - Level 3: Matrix-matrix (e.g., multiplication)

- **LAPACK** (Linear Algebra PACKage)
  - Built on top of BLAS
  - High-level routines for:
    - Solving linear systems
    - Eigenvalue problems
    - Singular value decomposition

## BLAS & LAPACK {.smaller}

- **Why use them?**
  - Highly optimized for performance
  - Portable across platforms
  - Widely used in scientific and engineering applications
- Many implementations are available
  - OpenBLAS
  - Intel MKL
  - ATLAS

> Link with `-lblas -llapack` or use optimized implementations like OpenBLAS, Intel MKL, or ATLAS.

## Dot product in BLAS

```{.c}
#include <stdio.h>
#include <cblas.h>

int main() {
    double x[3] = {1.0, 2.0, 3.0};
    double y[3] = {4.0, 5.0, 6.0};
    double result = cblas_ddot(3, x, 1, y, 1);
    printf("Dot product: %f\n", result);
    return 0;
}
```

## HDF5: Managing Scientific Data in C {.smaller}

- **HDF5** (Hierarchical Data Format v5)
  - Designed for storing and organizing large, complex datasets
  - Supports n-dimensional arrays, tables, images, and metadata
  - Common in physics, climate modeling, bioinformatics, and engineering

- **Features**
  - Portable and self-describing binary format
  - Hierarchical structure: groups and datasets (like folders and files)
  - Supports compression, parallel I/O, and chunking

### HDF5: writing a dataset

- **Simple Example: Writing a Dataset**

```{.c}
#include "hdf5.h"

int main() {
    hid_t file_id, dataset_id, dataspace_id;
    hsize_t dims[2] = {4, 6};
    double data[4][6] = { /* initialize with values */ };

    file_id = H5Fcreate("example.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    dataspace_id = H5Screate_simple(2, dims, NULL);
    dataset_id = H5Dcreate(file_id, "/mydata", H5T_NATIVE_DOUBLE, dataspace_id,
                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);
    H5Dclose(dataset_id);
    H5Sclose(dataspace_id);
    H5Fclose(file_id);
    return 0;
}
```

# Exercises

## Solve a linear system of equations with GSL {.smaller}

## Training a neural network for handwriting recognition {.smaller}

# Segmentation faults

## Segmentation faults

TODO

## Segmentation fault example

```{.c}
#include <stdio.h>

int main(void) {
    int n = 4;
    int A[n];
    for (int i = 0; i <= n; i++) {
        printf("A[%5d] = %12d\n", i, A[i]);
        printf("A[%5d] = %12d\n", i * 3000, A[i*3000]);
    }
    return 0;
}
```

What will happen when you compile and run this program?

## Segmentation fault example

Invalid array access gives undefined behavior, the result can depend on the system

```{.bash}
$ ./segmentation_fault
A[    0] =            0
A[    0] =            0
A[    1] =            0
A[ 3000] =   1815048801
A[    2] =      4198989
A[ 6000] =   2034381655
A[    3] =            0
Segmentation fault (core dumped)
```

- Some true elements (`A[2]`) have a *garbage* value
  - Makes sense, elements were not initialized
- Some elements outside of array (`A[3000]`) have a garbage value
  - Makes sense, it is not checked if this is actually a memory argument, you just get what happens to be in memory at `(A + 3000)`
- The access of `A[9000]` gives a segmentation fault
  - ???

## Virtual vs physical memory {background-color="lightgrey"} {.smaller}

:::: {.columns}
::: {.column width=65%}
- As a user/programmer, you see *virtual* memory
- Virtual memory creates the illusion of a large, contiguous, uniform address space
  - Hides fragmentation of physical memory
  - Delegates managing memory hierarchy (caches, RAM, disk) to OS
  - Provides safety mechanism to isolate process' address space
- Mapping to phyical memory in page table
  - Out-of-bound memory access can pick up garbage mapping address
  - You might be accessing another process' memory, even on read access the CPU throws a segmentation fault
:::
::: {.column width=35%}
![](images/virtual_memory.svg) 
:::
:::: 

## Handling segmentation faults {background-color="lightgrey"}

- Do not make coding mistakes :)
- Ask the compiler to instrument executable to 
  - `gcc -fsanitize=bounds-strict segmentation_fault.c`
  - Can lead to lower performance
- Run the program under a debugger such as `gdb`
  - Compile with debug symbols (`-g`)

# Versions of C

## A brief history of C

- C development starts in the early 1970s
- First standard published in 1989: ANSI C or C89
- Update in 1999: C99 standard
- Update in 2011: C11 standard
- Minor bugfixes in 2017: C17 (sometimes referred to as C18)
- Update in 2023: C23

## Different C standards

- The C89 standard is still considered the default
- Compiler has to be instructed to use specific standard: `gcc -std=c11`
  - You need a recent compiler for the most recent standard
- Compilers often to not stick *exactly* to standard
  - `gcc` provides some C99 constructions by default
  - Options like `-std=c89 -pedantic` make it more strict

## The C99 standard additions {.smaller}

- Single-line comments with `//`
- Variable length arrays
- Mark functions with `inline` to avoid call overhead
- Use `restrict` to indicate arrays do not overlap
- Boolean and complex types in `<bool.h>` and `<complex.h>`
- Type-generic macros in `<tgmath.h>`
- IEEE 754 floating point support

## Inline functions

- Function call: expensive
  - call stack must be maintained
  - stack variables allocated, initialized
- Small functions, called often: lots of overhead
- Inline functions: function code inserted in caller
  - good compilers try that anyway
  - helping compilers: better optimization!

```{.c}
inline double sqr(double x) {
    return x*x;
}
```

## Restrict keyword for arrays

- Arrays in C
  - address of first element
  - no semantics for compiler
- Multiple arrays as function arguments, do they overlap?
- Help compiler, use `restrict`
  - programmer assures to compiler that arrays don't overlap

```{.c}
void daxpy_r(double * restrict z, double a,                      double * restrict x, double * restrict y, int n);
```

## Complex numbers

- Types:
  - float complex: single precision
  - double complex: double precision
  - long double complex: extended precision
- Declarations in complex.h
  - types
  - literal: I
  - functions, e.g., `creal`, `cimag`, `csqrt`, `cexp`, ...

## Type-generic math {.smaller}

- Automatically selects the correct version of a math function:
  - `float`, `double`, or `long double`
  - `complex` or `real` types
- Cleaner code: No need to manually choose `sinf`, `sin`, or `sinl`.
- Type safety: Matches function to argument type at compile time.

```{.c}
#include <tgmath.h>

double x = 0.5;
float y = 0.5f;

double result1 = sin(x);  // uses sin()
float result2 = sin(y);   // uses sinf()
```

## IEEE 754 floating point support 

- float: 4 byte, single precision
- double: 8 byte, double precision
- long double: 12 byte, extended precision
- Rounding well-defined
- Support for Inf, -Inf, NaN 

## The C11 standard

The `_Generic` Keyword

- Enables **type-generic programming** (like `tgmath.h`)
- Example:
  ```c
  #define my_abs(x) _Generic((x), \
      int: abs, \
      float: fabsf, \
      double: fabs \
  )(x)
  ```

## Mathematics in C23

- New mathematical functions in `math.h`
  - `sinpi(x)` is the same as `sin(pi*x)` with better precision
  - `exp10` et al.
- Checked integer artithmetic in `stdckdint.h`
  - `ckd_add` et al.
- Support for `1'000` and `1'133.023` notation
- Decimal floating-point math (IEEE 754-2008/2019)

## Syntax changes in C23

- `nullptr`` (keyword) rather than `NULL` (macro)
- `true/false` keywords, `stdbool.h` not required
- Unnamed function parameters
- `stdbit.h`: bit manipulation functions
- `strdup/strndup`: simple string duplication
- `constexpr` for compile-time constants
- `static_assert` for compile-time asserts
- `typeof` to determine type at compile time

## C23 attributes {.smaller}

- Defensive programming
  - `[[fallthrough]]`: intentional fall-through in switch
  - `[[nodiscard]]`: don't ignore return value
  - `[[maybe_unused]]`: don't warn if not used (function/parameter)
  - `[[deprecated]]`
- Performance related
  - `[[unsequenced]]`: function has no side-effects, calls can be out-of-order
  - `[[reproducible]]`: function has no side-effect, calls have to be in-order (e.g., random numbers)

# Wrapping up

## Scientific programming landscape

![](images/scientific_programming_languages_landscape.png)

## More to explore

- How to do HPC => [HPC intro](https://hpcleuven.github.io/HPC-intro) and [Linux for HPC](https://hpcleuven.github.io/Linux-for-HPC/)
- Build systems => [CMake intro](https://hpcleuven.github.io/CMake-intro/) and [Makefile intro](https://hpcleuven.github.io/Makefile-intro/)
- Version control => [Version control with git](https://github.com/gjbex/Version-control-with-git)
- Optimizing code => [Code optimization](https://gjbex.github.io/Code-optimization/)
- Debugging code => [Defensive programming and debugging](https://gjbex.github.io/Defensive_programming_and_debugging/)
- Parallel programming => [Parallel programming](https://github.com/gjbex/Parallel-programming)
- Setting up an Integrated Development Environment (IDE)

## More to explore

::: {.callout-tip}
The calendar of VSC Trainings can be found at [https://www.vscentrum.be/vsctraining](https://www.vscentrum.be/vsctraining).
Learning paths that show connections between trainings can be found at [https://gjbex.github.io/](https://gjbex.github.io/).
:::


