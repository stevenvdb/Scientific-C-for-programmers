[
  {
    "objectID": "c_advanced.html",
    "href": "c_advanced.html",
    "title": "Advanced C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_advanced.html#outline",
    "href": "c_advanced.html#outline",
    "title": "Advanced C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_advanced.html#pointers-and-arrays-1",
    "href": "c_advanced.html#pointers-and-arrays-1",
    "title": "Advanced C",
    "section": "Pointers and arrays 1 2",
    "text": "Pointers and arrays 1 2\n\nC arrays store multiple values of the same type in a single variable\nC pointers contain a memory address of a variable\nPointers and arrays are closely related in C"
  },
  {
    "objectID": "c_advanced.html#memory-management",
    "href": "c_advanced.html#memory-management",
    "title": "Advanced C",
    "section": "Memory management",
    "text": "Memory management\n\n\nMemory is one of the fundamental building blocks of current computer architectures (see von Neumann model)\nIn many programming languages, memory management is transparent to programmer\n\nA variable is stored somewhere in memory, but the programmer does not know where\nVariables are referenced symbolically by programmer, program figures out memory location\n\nC does allow managing memory yourself, so it needs a concept to allow working with memory addresses"
  },
  {
    "objectID": "c_advanced.html#pointer-basics",
    "href": "c_advanced.html#pointer-basics",
    "title": "Advanced C",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the memory location (address) of another variable\nThe & operator gives the memory address of a variable\nThe * operator gives the value of the variable a pointer points to (dereferencing)\nThere are different types of pointers, depending on which type they point to\nDeclarations like int *px indicate that px is a pointer and *px is an int"
  },
  {
    "objectID": "c_advanced.html#virtual-memory-layout",
    "href": "c_advanced.html#virtual-memory-layout",
    "title": "Advanced C",
    "section": "Virtual memory layout",
    "text": "Virtual memory layout\n\n\n\nI represent virtual memory as a table with three columns\n\nAddress column in hexadecimal format\nValue column in decimal format\nVariable column makes it easier to read, not present in actual implementation\nRemember that internally it’s all binary\nSome variables take up more than one address\n\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nint x\n0x0000\n42\n\n\nint y\n0x0004\n43\n\n\ndouble a\n0x0008\n12.6e10\n\n\ndouble a\n0x000c\n\n\n\nfloat b\n0x0010\n3.14"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach",
    "href": "c_advanced.html#swapping-variables-naive-approach",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach-1",
    "href": "c_advanced.html#swapping-variables-naive-approach-1",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach-2",
    "href": "c_advanced.html#swapping-variables-naive-approach-2",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach-3",
    "href": "c_advanced.html#swapping-variables-naive-approach-3",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach-4",
    "href": "c_advanced.html#swapping-variables-naive-approach-4",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n5\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach-5",
    "href": "c_advanced.html#swapping-variables-naive-approach-5",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nOutput:\nx = 5, y = 10\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "c_advanced.html#working-with-large-arrays",
    "href": "c_advanced.html#working-with-large-arrays",
    "title": "Advanced C",
    "section": "Working with large arrays",
    "text": "Working with large arrays\n\n\nSuppose you construct vectors using a struct (see later)\nYou want a function double innerProduct(struct vector v1, struct vector v2) that computes the inner product\nSince C uses pass-by-value, those objects would be copied when function is called\nMemory access is slow, this would give bad performance for large cases\n\n=&gt; This is also addressed by pointers"
  },
  {
    "objectID": "c_advanced.html#pointer-basics-1",
    "href": "c_advanced.html#pointer-basics-1",
    "title": "Advanced C",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the address of a variable\nPointer arguments allow modifying object in the called function\nThere are different pointer types, depending on the variable they point to, for example, int *px; or double *pa;\n\n\n\n\n\n\n\nTip\n\n\n\nMnemonic: read int *px as “*px is of type int”. Sometimes people also use int* px to declare an integer pointer."
  },
  {
    "objectID": "c_advanced.html#pointer-basics-2",
    "href": "c_advanced.html#pointer-basics-2",
    "title": "Advanced C",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nThe & operator gives the address of a variable\nThe * operator dereferences a pointer, i.e., gives the value of the variable that is pointed to\n\nint x = 1, y;\nint *px;\n\npx = &x; // px now points to x, i.e. it holds the address of x\ny = *px; // y now holds the value of the object px points to, i.e. y = 1\n*px = 10; // the value of the object px points to is set, i.e. x = 10"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers",
    "href": "c_advanced.html#swapping-variables-pointers",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers-1",
    "href": "c_advanced.html#swapping-variables-pointers-1",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers-2",
    "href": "c_advanced.html#swapping-variables-pointers-2",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers-3",
    "href": "c_advanced.html#swapping-variables-pointers-3",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers-4",
    "href": "c_advanced.html#swapping-variables-pointers-4",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers-5",
    "href": "c_advanced.html#swapping-variables-pointers-5",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nOutput:\nx = 10, y = 5\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5"
  },
  {
    "objectID": "c_advanced.html#arrays",
    "href": "c_advanced.html#arrays",
    "title": "Advanced C",
    "section": "Arrays",
    "text": "Arrays\n\nAn array is a block of consecutive objects of a specified type\n\nint a[10]; declares 10 consecutive int objects\nThe i-th element can be accessed as a[i]\n\nPointers are a natural way to loop over arrays\n\nint a[10];\nint *pa;\npa = &a[0]; // pa points to first element of a\npa++; // pa now points to second element of a\n\n\n\n\n\n\nWarning\n\n\n\nWhen pointing to array elements, incrementing a pointer always means going to the next object irrespective of the object type!"
  },
  {
    "objectID": "c_advanced.html#array-indexing-sourcery",
    "href": "c_advanced.html#array-indexing-sourcery",
    "title": "Advanced C",
    "section": "Array indexing sourcery",
    "text": "Array indexing sourcery\n\n\nIn C, the name of an array is a synonym for the memory address of the initial element\n\nint *pa = &a[0] is identical to int *pa = a\n\nAccess to the i-th element a[i] is translated to *(a+i)\nBecause integer addition is commutative, a[i] is identical to i[a]!"
  },
  {
    "objectID": "c_advanced.html#arrays-as-function-arguments",
    "href": "c_advanced.html#arrays-as-function-arguments",
    "title": "Advanced C",
    "section": "Arrays as function arguments",
    "text": "Arrays as function arguments\n\nWhen passing an array to a function, the location of the initial element is passed\nWithin the called function, the corresponding local variable is a pointer\nYou can pass a part of an array to a function\n\nf(&a[2]) passes the subarray that starts at a[2]\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou cannot pass a slice of an array, the called function is responsible to respect the bounds of the array. This is one of the reasons why C programs are often considered at risk for unsafe memory management."
  },
  {
    "objectID": "c_advanced.html#array-decay",
    "href": "c_advanced.html#array-decay",
    "title": "Advanced C",
    "section": "Array decay",
    "text": "Array decay\n\nWhen passed to a function, an array decays into a pointer to its first element\nsizeof(arr) inside function gives size of pointer, not array\nArray length information is lost\n\n#include &lt;stdio.h&gt;\n\nvoid foo(int arr[]) {\n    printf(\"sizeof(arr) = %zu\\n\", sizeof(arr)); // prints size of pointer\n}\n\nint main() {\n    int arr[10];\n    printf(\"sizeof(arr) = %zu\\n\", sizeof(arr)); // prints size of array\n    foo(arr);\n}\nOutput:\nsizeof(arr) = 40\nsizeof(arr) = 8"
  },
  {
    "objectID": "c_advanced.html#character-pointers",
    "href": "c_advanced.html#character-pointers",
    "title": "Advanced C",
    "section": "Character pointers",
    "text": "Character pointers\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation",
    "href": "c_advanced.html#dynamic-memory-allocation",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nThe C89 standard does not allow variable length arrays\n\nArray size must be known at compile time\nsize_t len = 5; int a[len]; is strictly speaking invalid\nSince C99 it is supported and many compilers allow it by default\n\nEven if you can have VLAs, there are some downsides\n\nAllocated on stack, so limited in size\nScope is local, similar as other variables\nVLA might be less efficient\n\n\n\n\n\n\n\n\nTip\n\n\n\nVariable length refers to the fact that length is only known at runtime, a variable length array remains of the same size during its lifetime."
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation-1",
    "href": "c_advanced.html#dynamic-memory-allocation-1",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\n\nMemory for arrays can be dynamically allocated on the heap\n\nHeap is a large area of memory used at runtime\nSignature: void *malloc(size_t size);\nsize is in bytes: make use of sizeof\nreturns void pointer, cast it to correct pointer type\nif memory cannot be allocated, null pointer is returned\nalways free() the memory exactly once!\ncalloc: includes initializing to zero (so slower than malloc)"
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation-2",
    "href": "c_advanced.html#dynamic-memory-allocation-2",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n    size_t len = atoi(argv[1]);\n    double *pa = (double *) malloc(len * sizeof(double));\n    if (pa == NULL) { return 1;}\n    free(pa);\n    return 0;\n}"
  },
  {
    "objectID": "c_advanced.html#multidimensional-arrays",
    "href": "c_advanced.html#multidimensional-arrays",
    "title": "Advanced C",
    "section": "Multidimensional arrays",
    "text": "Multidimensional arrays\n\nC supports multidimensional arrays by using multiple []\n\nint matrix[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n\nIndexing is done with [i][j] (not [i,j])\n\nint x = matrix[1][2]\n\nC uses row-major storage: last dimension is fastest in memory"
  },
  {
    "objectID": "c_advanced.html#pointers-to-pointers",
    "href": "c_advanced.html#pointers-to-pointers",
    "title": "Advanced C",
    "section": "Pointers to pointers",
    "text": "Pointers to pointers\n\nA pointer is also a variable -&gt; another pointer can point to its address\nIn contrast to multidimensional arrays, we can now have irregular structures\nExample: storing an upper triangular matrix\n\ndouble **lower;\nlower = (double **)malloc( n * sizeof(double *))\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}\nfree(lower);"
  },
  {
    "objectID": "c_advanced.html#arrays-of-pointers",
    "href": "c_advanced.html#arrays-of-pointers",
    "title": "Advanced C",
    "section": "Arrays of pointers",
    "text": "Arrays of pointers\n\nBy now it should be clear pointers and arrays are very similar\nThe previous example as an array of pointers:\n\ndouble *lower[n];\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}"
  },
  {
    "objectID": "c_advanced.html#pointers-to-functions",
    "href": "c_advanced.html#pointers-to-functions",
    "title": "Advanced C",
    "section": "Pointers to functions",
    "text": "Pointers to functions\n\nExample\n\nWhen \\(a\\) and \\(b\\) are close, the integral \\(\\int_a^{b} f(x) dx \\approx \\frac{1}{2} \\frac{f(a) + f(b)}{b-a}\\)\nThis rule can be written for any \\(f(x)\\) as:\n\n\ndouble trapezoidRule (double (*f)(double), double a, double b) {\n    return (b-a)*(f(a) + f(b))/2;\n}\ndouble trap = trapezoidRule(cos, 0, M_PI);"
  },
  {
    "objectID": "c_advanced.html#quadrature",
    "href": "c_advanced.html#quadrature",
    "title": "Advanced C",
    "section": "Quadrature",
    "text": "Quadrature\nGoal:\n\nWrite a program that can numerically integrate arbitrary functions\n\nLearning outcome:\n\nUse pointers to let functions operate on arrays and functions\n\nInstructions:\n\nWrite a function that allocates an array, with evenly spaced real numbers in a chosen interval as entries\nWrite a function that approximates the integral of sin and cos^2 on the chosen interval\nSee exercises/08_quadrature"
  },
  {
    "objectID": "c_advanced.html#heat-equation",
    "href": "c_advanced.html#heat-equation",
    "title": "Advanced C",
    "section": "Heat equation",
    "text": "Heat equation\nGoal:\n\nWrite a program that solves the 2D heat equation\n\nLearning outcome:\n\nLearn to work with multi-dimensional arrays\n\nInstructions:\n\nSee exercises/09_heat_equation"
  },
  {
    "objectID": "c_advanced.html#heat-equation-memory-leak",
    "href": "c_advanced.html#heat-equation-memory-leak",
    "title": "Advanced C",
    "section": "Heat equation memory leak",
    "text": "Heat equation memory leak\n\nThe provided code allocated memory at each iteration without ever freeing it\nThis is a memory leak: for larger grids and/or more steps, you would run out of memory\nMake sure to always free memory you allocated with malloc/calloc\nIn this case the allocation only has to be done once (outside of the loop)"
  },
  {
    "objectID": "c_advanced.html#structures-1",
    "href": "c_advanced.html#structures-1",
    "title": "Advanced C",
    "section": "Structures 3 4",
    "text": "Structures 3 4\n\nA structure is a collection of one or more variables, possibly of different types\nMakes it convenient to organize and handle complicated data\nA very lightweight class (but do not call C object-oriented):\n\nNo inheritance\nNo class methods"
  },
  {
    "objectID": "c_advanced.html#structure-example",
    "href": "c_advanced.html#structure-example",
    "title": "Advanced C",
    "section": "Structure example",
    "text": "Structure example\n\nA structure is defined with struct, usually followed by a tag as a name\n\nstruct particle {\n    double x;\n    double y;\n    double z;\n    double mass;\n    char symbol;\n}\n\nThe variables named in the struct are members and can be accessed with the . operator"
  },
  {
    "objectID": "c_advanced.html#structure-example-1",
    "href": "c_advanced.html#structure-example-1",
    "title": "Advanced C",
    "section": "Structure example",
    "text": "Structure example\n\nA struct can be initialized directly or member-by-member\n\nstruct particle p1;\np1.x = 1.0;\np1.y = 2.0;\np1.z = 3.0;\np1.mass = 1.000784;\np1.symbol = 'H';\nstruct particle p2 = {2.0, 4.0, 5.0, 12.011, 'C'};\n\n\n\n\n\n\n\nTip\n\n\n\nInitializing member-by-member is a bit more robust when the struct definition changes"
  },
  {
    "objectID": "c_advanced.html#structures-and-functions",
    "href": "c_advanced.html#structures-and-functions",
    "title": "Advanced C",
    "section": "Structures and functions",
    "text": "Structures and functions\n\nFunctions can operate on structures much the same way as basic types\n\nstruct particle centerOfMass(struct particle p1, struct particle p2) {\n    double mass = p1.m + p2.m;\n    struct particle com;\n    com.x = (p1.x * p1.m + p2.x * p2.m) / mass;\n    com.y = (p1.y * p1.m + p2.y * p2.m) / mass;\n    com.z = (p1.z * p1.m + p2.z * p2.m) / mass;\n    com.mass = mass\n    return com;\n}"
  },
  {
    "objectID": "c_advanced.html#arrays-of-structures",
    "href": "c_advanced.html#arrays-of-structures",
    "title": "Advanced C",
    "section": "Arrays of structures",
    "text": "Arrays of structures\n\nArrays can be made up of structs\n\n// Make an array with n particles\nstruct particle particles[n];\n\n\nDefined in this way, accessing all x coordinates would give strided memory access\n\nHaving a struct with arrays can be more efficient than an array of structs\nDepends on the specific application"
  },
  {
    "objectID": "c_advanced.html#structures-and-pointers",
    "href": "c_advanced.html#structures-and-pointers",
    "title": "Advanced C",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nStructures are variables, so you can point to their address\n\nvoid translateX(struct particle *p, double distance) {\n    (*p).x += distance;\n}\n\n\nA member of a pointer can be accessed with -&gt;\n\nIf p is a pointer to a struct particle, (*p).x is the same as p-&gt;x\n\n\nvoid translateX(struct particle *p, double distance) {\n    p-&gt;x += distance;\n}"
  },
  {
    "objectID": "c_advanced.html#structures-and-pointers-1",
    "href": "c_advanced.html#structures-and-pointers-1",
    "title": "Advanced C",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nThe . and -&gt; operators have highest precedence:\n\n*p.x would be interpreted as *(p.x) (unwanted in our example)\nuse brackets to make your intention clear"
  },
  {
    "objectID": "c_advanced.html#common-data-structures",
    "href": "c_advanced.html#common-data-structures",
    "title": "Advanced C",
    "section": "Common data structures",
    "text": "Common data structures\n\n\nMultidimensional arrays\n\nRegular and fixed structure, only members of a single type\n\nLinked lists\n\nAllow dynamic lengths and make insertion easy\n\nTrees\n\nRepresent hierarchical data\n\nGraph\n\nMore general than trees, allow more complicated topologies"
  },
  {
    "objectID": "c_advanced.html#typedef",
    "href": "c_advanced.html#typedef",
    "title": "Advanced C",
    "section": "Typedef",
    "text": "Typedef\nThe typedef keyword creates an alias for an existing data type\n\n\nTo abbreviate a long type name:\ntypedef unsigned long int ULINT;\nULINT i; // Equivalent to unsigned long int i;\nTo facilitate switching between precisions or improve portability:\n#ifdef REDUCED_PRECISION\ntypedef float MYFLOAT;\n#else\ntypedef double MYFLOAT;\n#endif\nTo have a type name closer to its semantical meaning\ntypedef struct Item * Item;\ntypedef struct Item * List;\n[look up linked-list implementation to better understand this one]"
  },
  {
    "objectID": "c_advanced.html#unions",
    "href": "c_advanced.html#unions",
    "title": "Advanced C",
    "section": "Unions",
    "text": "Unions\n\nA union can hold objects of different types, but only one at a time\n\nOnly the last assigned member is guaranteed to hold a valid value\n\nSimilar to a struct, but in a union, members share the same memory\nCan be used to have some pseudo-polymorphism in C\nunion MyUnion {int myInt; double myDouble;};\nunion MyUnion u;\nu.myInt = 1;\nu.myDouble = 2.0; // From here, u.myInt has invalid value\nSometimes used to make low-level access easier, for instance interpret a 4-byte int as 4 1-byte chars\ntypedef union\n{\n  struct {\n      unsigned char byte1, byte2, byte3, byte4;\n  } bytes;\n  unsigned int dword;\n} HW_Register;"
  },
  {
    "objectID": "c_advanced.html#size-of-structure",
    "href": "c_advanced.html#size-of-structure",
    "title": "Advanced C",
    "section": "Size of structure",
    "text": "Size of structure\nGoal:\n\nWrite a program centered around a Person structure\n\nLearning outcomes:\n\nDefine a structure and functions operating on it\nThink about memory alignment\n\nInstructions:\n\nCreate a Person structure with members height, weight, year of birth, and first letter of name\nCheck the size of the structure in memory and explain the result\nWrite a function that computes the total weight of a group of persons [hint: see variadic functions]\nSee exercises/10_struct_basics"
  },
  {
    "objectID": "c_advanced.html#dna-sequencing",
    "href": "c_advanced.html#dna-sequencing",
    "title": "Advanced C",
    "section": "DNA sequencing",
    "text": "DNA sequencing\nGoal:\n\nWrite a program to detect motifs in a DNA sequence associated with an increased risk of a hypothetical disease\n\nLearning Outcomes:\n\nDefine and use structs for organizing biological data\nWork with arrays of structs\nImplement string search algorithms in C"
  },
  {
    "objectID": "c_advanced.html#dna-sequencing-1",
    "href": "c_advanced.html#dna-sequencing-1",
    "title": "Advanced C",
    "section": "DNA sequencing",
    "text": "DNA sequencing\n\nConsider the following hypothetical DNA sequences:\n\n\n\nID\nName\nSequence\n\n\n\n\nseq1\nAlice\nATCGGGTAATCG\n\n\nseq2\nBob\nGGTAATCGGGTA\n\n\nseq3\nCarol\nATCGATCGGGTA\n\n\nseq4\nDave\nGGGGATCGATCG\n\n\nseq5\nEve\nATCGGGGGGGTA\n\n\n\nImagine that the number of times one of the following motifs is present, increases the risk to carry a certain disease:\n\n\n\nMotif\nDisease\n\n\n\n\nATCG\nDisease1\n\n\nGGTA\nDisease2"
  },
  {
    "objectID": "c_advanced.html#dna-sequencing-2",
    "href": "c_advanced.html#dna-sequencing-2",
    "title": "Advanced C",
    "section": "DNA sequencing",
    "text": "DNA sequencing\n\nConstruct structs to represent DNA sequences and motifs\nCompute for each sequence and for each disease the risk factor\n\nSee exercises/11_dna_sequencing"
  },
  {
    "objectID": "c_advanced.html#input-and-output-1",
    "href": "c_advanced.html#input-and-output-1",
    "title": "Advanced C",
    "section": "Input and output 5 6",
    "text": "Input and output 5 6\n\n\nInput/output is not part of C, but of standard library =&gt; need for #include &lt;stdio.h&gt;\nConverting input/output can be tedious (use AI assistant?)\nMake use of dedicated libraries/formats such as HDF5, NetCDF, Zarr\nAnnotate data with metadata (units, meaning, etc…)\nLimited coverage in this course, see K&R Appendix B"
  },
  {
    "objectID": "c_advanced.html#writing-to-standard-out-stdout",
    "href": "c_advanced.html#writing-to-standard-out-stdout",
    "title": "Advanced C",
    "section": "Writing to standard out (stdout)",
    "text": "Writing to standard out (stdout)\nprintf allows to print internal values as characters in terminal\n// int with minimal width 5\nprintf(\"a = %5d\\n\", a); // a =    10\n// int with minimal width 5 and zero padding\nprintf(\"a = %05d\\n\", a); // a = 00010\n// double with 8 digits after comma\nprintf(\"pi = %.8f\\n\", M_PI); // pi = 3.14159265\n// double in exponential notation\nprintf(\"pi = %8.2e\\n\", M_PI); // pi = 3.14e+00\n// fixed-width string\nprintf(\"%.10s\\n\", \"Hello, world\"); // Hello, wor"
  },
  {
    "objectID": "c_advanced.html#reading-from-standard-in-stdin",
    "href": "c_advanced.html#reading-from-standard-in-stdin",
    "title": "Advanced C",
    "section": "Reading from standard in (stdin)",
    "text": "Reading from standard in (stdin)\nint day;\nchar month[20];\nprintf(\"Enter data in format '01 January'\\n\");\nscanf(\"%d %s\", &day, month); // Make sure to check values!\nscanf:\n\nreturns number of matched items\nstops when format string is exhausted or input fails to match specification\n\n\n\n\n\n\n\nTip\n\n\n\nTo run non-interactively, you can redirect file contents to stdin on Linux with ./a.out &lt;inputfile"
  },
  {
    "objectID": "c_advanced.html#command-line-arguments",
    "href": "c_advanced.html#command-line-arguments",
    "title": "Advanced C",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n\nCommand-line arguments are passed to main\nFirst argument: number of command-line arguments + 1 (typically argc)\nSecond argument: pointer to array of character strings (typically argv)\n\nFirst array element (at index 0) has name of program"
  },
  {
    "objectID": "c_advanced.html#command-line-arguments-1",
    "href": "c_advanced.html#command-line-arguments-1",
    "title": "Advanced C",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"There are %d command-line arguments\\n\", argc);\n    printf(\"The program is called %s\\n\", argv[0]);\n    for (int i = 1; i &lt; argc; i++)\n        printf(\"Command-line argument %d is %s\\n\", i, argv[i]);\n    return 0;\n}\n$ ./a.out Hello World\nThere are 3 command-line arguments\nThe program is called ./a.out\nCommand-line argument 1 is Hello\nCommand-line argument 2 is World"
  },
  {
    "objectID": "c_advanced.html#file-access",
    "href": "c_advanced.html#file-access",
    "title": "Advanced C",
    "section": "File access",
    "text": "File access\n\nFiles are accessed using a FILE structure defined in stdio.h:\n\nFILE *fp; fp = fopen(name, mode);\n\nmode can be read r, append a, or write w\nMake sure to check if fopen was succesful by comparing with NULL pointer\nMake sure to close file again with fclose(fp);"
  },
  {
    "objectID": "c_advanced.html#file-access-example",
    "href": "c_advanced.html#file-access-example",
    "title": "Advanced C",
    "section": "File access example",
    "text": "File access example\n    FILE *values = fopen(\"values.txt\", \"r\");\n    if (values == NULL) {\n        printf(\"Failed to open values.txt\\n\");\n        return 1;\n    }\n    char line[256];\n    while (fgets(line, sizeof(line), values)) {\n        double value;\n        if (sscanf(line, \"%lf\", &value) == 1) {\n            printf(\"Read value %f\\n\", value);\n        }\n    }\n    fclose(values);\n$ cat values.txt\n42\n3.14\n981.12\n$ ./a.out\nRead value 42.000000\nRead value 3.140000\nRead value 981.120000"
  },
  {
    "objectID": "c_advanced.html#exercise-regression",
    "href": "c_advanced.html#exercise-regression",
    "title": "Advanced C",
    "section": "Exercise: regression",
    "text": "Exercise: regression\nGoal:\n\nWrite a program that reads temperature anomalies and predicts future values using simple linear regression\n\nLearning outcomes:\n\nLearn how to read numbers from a structured input file and process them\n\nInstructions:\n\nSee exercises/12_regression"
  },
  {
    "objectID": "c_advanced.html#footnotes",
    "href": "c_advanced.html#footnotes",
    "title": "Advanced C",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nKernighan and Ritchie, Chapter 5, Pointers and arrays↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 6, Structures↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 7, Input and Output↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎"
  },
  {
    "objectID": "jumping_in.html",
    "href": "jumping_in.html",
    "title": "Jumping in",
    "section": "",
    "text": "Goal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program\nInstructions:\n\nOpen the Visual Studio Code app via https://ondemand.hpc.kuleuven.be if you have a VSC account\nUse a C environment on your local machine if available\nCreate an app on https://replit.com/languages/c otherwise\n\n\nCreate a text file called hello.c containing:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world\\n\");\n    return 0;\n}\nCompile and run it in a terminal as follows:\ngcc hello.c -o hello\n./hello\n\n\n\n\n\n\nTip\n\n\n\nYou can use another compiler such as clang if you prefer, some options can be different.\n\n\n\n\n\nGoal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors\n\n\nInstructions:\n\nThe training repository contains files needed for the exercises\n\nDownload the repository with\ngit clone https://github.com/stevenvdb/Scientific-C-for-programmers/\nAlternatively, visit https://github.com/stevenvdb/Scientific-C-for-programmers/ in a browser\n\nThis exercise is located in exercises/01_temperature_conversion\n\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    float fahr, celcius;\n    float lower, upper, step;\n\n    lower = 0;   // Lowest temperature in Fahrenheit\n    upper = 100; // Highest temperature in Fahrenheit\n    step = 10;   // Increment of temperature\n\n    fahr = lower;\n    while (fahr &lt; upper) {\n        celcius = (5 / 9) * (fahr - 32);\n        printf(\"%8.1f %8.1f\\n\", fahr, celcius);\n        fahr = fahr + step\n    }\n    return 0;\n}\nFix the problems (there are 3) to compile and run the code:\ngcc convert_temperatures.c -o convert_temperatures\n./convert_temperatures\n\n\n\n\nSimple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)\n\n\n\n\nGoal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercises/02_logistic_map\n\n\n\n\ndouble update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input\n\n\n\n\n\n\nComparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate =&gt; example of a chaotic system"
  },
  {
    "objectID": "jumping_in.html#the-obligatory-hello-world",
    "href": "jumping_in.html#the-obligatory-hello-world",
    "title": "Jumping in",
    "section": "",
    "text": "Goal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program\nInstructions:\n\nOpen the Visual Studio Code app via https://ondemand.hpc.kuleuven.be if you have a VSC account\nUse a C environment on your local machine if available\nCreate an app on https://replit.com/languages/c otherwise\n\n\nCreate a text file called hello.c containing:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world\\n\");\n    return 0;\n}\nCompile and run it in a terminal as follows:\ngcc hello.c -o hello\n./hello\n\n\n\n\n\n\nTip\n\n\n\nYou can use another compiler such as clang if you prefer, some options can be different."
  },
  {
    "objectID": "jumping_in.html#temperature-conversion",
    "href": "jumping_in.html#temperature-conversion",
    "title": "Jumping in",
    "section": "",
    "text": "Goal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors\n\n\nInstructions:\n\nThe training repository contains files needed for the exercises\n\nDownload the repository with\ngit clone https://github.com/stevenvdb/Scientific-C-for-programmers/\nAlternatively, visit https://github.com/stevenvdb/Scientific-C-for-programmers/ in a browser\n\nThis exercise is located in exercises/01_temperature_conversion\n\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    float fahr, celcius;\n    float lower, upper, step;\n\n    lower = 0;   // Lowest temperature in Fahrenheit\n    upper = 100; // Highest temperature in Fahrenheit\n    step = 10;   // Increment of temperature\n\n    fahr = lower;\n    while (fahr &lt; upper) {\n        celcius = (5 / 9) * (fahr - 32);\n        printf(\"%8.1f %8.1f\\n\", fahr, celcius);\n        fahr = fahr + step\n    }\n    return 0;\n}\nFix the problems (there are 3) to compile and run the code:\ngcc convert_temperatures.c -o convert_temperatures\n./convert_temperatures"
  },
  {
    "objectID": "jumping_in.html#logistic-map",
    "href": "jumping_in.html#logistic-map",
    "title": "Jumping in",
    "section": "",
    "text": "Simple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)"
  },
  {
    "objectID": "jumping_in.html#logistic-map-1",
    "href": "jumping_in.html#logistic-map-1",
    "title": "Jumping in",
    "section": "",
    "text": "Goal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercises/02_logistic_map"
  },
  {
    "objectID": "jumping_in.html#logistic-map-solution",
    "href": "jumping_in.html#logistic-map-solution",
    "title": "Jumping in",
    "section": "",
    "text": "double update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input"
  },
  {
    "objectID": "jumping_in.html#logistic-map-discussion",
    "href": "jumping_in.html#logistic-map-discussion",
    "title": "Jumping in",
    "section": "",
    "text": "Comparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate =&gt; example of a chaotic system"
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Main lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modeling\n\nSupport during hands-on sessions from Jan De Laet\n\n\n\nPlease present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C\n\n\n\n\n\nFour sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference.\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#who-am-i",
    "href": "introduction.html#who-am-i",
    "title": "Introduction",
    "section": "",
    "text": "Main lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modeling\n\nSupport during hands-on sessions from Jan De Laet"
  },
  {
    "objectID": "introduction.html#who-are-you",
    "href": "introduction.html#who-are-you",
    "title": "Introduction",
    "section": "",
    "text": "Please present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C"
  },
  {
    "objectID": "introduction.html#practical-aspects",
    "href": "introduction.html#practical-aspects",
    "title": "Introduction",
    "section": "",
    "text": "Four sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference."
  },
  {
    "objectID": "introduction.html#outline",
    "href": "introduction.html#outline",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c",
    "href": "introduction.html#why-learn-to-program-in-c",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-1",
    "href": "introduction.html#why-learn-to-program-in-c-1",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nDidn’t AI agents take over programming? In my opinion:\n\nAI agents are invaluable assistants\nStill benefit greatly from a prompter with expertise because:\n\nThey will confidently write code that is wrong\nThey will often produce sub-optimal code (speed, maintainability, …)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis opinion might be outdated very soon."
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-2",
    "href": "introduction.html#why-learn-to-program-in-c-2",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nI encourage you to use AI assistance during this course\n\nYou will use it in real-life coding\nYou need to learn how to use it\n\nwith two caveats:\n\nThe exercises are educational,AI might perform better than for your real problems\nDon’t cheat on yourself,try to understand the answers to learn something"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-3",
    "href": "introduction.html#why-learn-to-program-in-c-3",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\n\n\nRelatively low level, close to hardware\n\nPopular to write system software (OS for example)\nGives insight into computer architecture\n\nPotentially gives good performance\n\nFairly popular in scientific computing\n\nSmall and stable language, syntax can be learned quickly\nGood basis to learn other programming languages\nYou inherited a project written in C\n\nNot a good intrinsic motivation, but a reality"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape",
    "href": "introduction.html#scientific-programming-landscape",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "introduction.html#assembly",
    "href": "introduction.html#assembly",
    "title": "Introduction",
    "section": "Assembly",
    "text": "Assembly\n\nVery low level, essentially machine code in readable format\nMachine dependent, specific to each architecture\nUsed in performance-critical parts of low-level libraries\nIf you are not sure you need it, you don’t\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe godbolt project gives a taste of what assembly looks like."
  },
  {
    "objectID": "introduction.html#c",
    "href": "introduction.html#c",
    "title": "Introduction",
    "section": "C",
    "text": "C\n\nFirst appeared in 1972, successor of B\nFirst standard in 1989, four revisions since\nCompiled language with static typing\nSmall language and standard library\nGives a lot of low-level control (e.g., memory management)"
  },
  {
    "objectID": "introduction.html#c-1",
    "href": "introduction.html#c-1",
    "title": "Introduction",
    "section": "C++",
    "text": "C++\n\nExtension of C, adding object-oriented features\nCompiled language with static typing\nAllows better and more complex project constructs\nMore syntax and much larger standard library\nIn principle retains all benefits from C,in practice you program differently"
  },
  {
    "objectID": "introduction.html#rust",
    "href": "introduction.html#rust",
    "title": "Introduction",
    "section": "Rust",
    "text": "Rust\n\n“Modern” version of C/C++\nVery different approach to memory management:\n\nC/C++ are prone to bugs causing safety issues\nRust is proposed as an alternative, see DARPA: Translating all C to Rust\nNot as problematic for programs you run locally\n\nEcosystem for scientific computing not as advanced as C/C++, but efforts are under way\n\nExample of a project for high-performance data manipulation: Polars dataframes"
  },
  {
    "objectID": "introduction.html#fortran",
    "href": "introduction.html#fortran",
    "title": "Introduction",
    "section": "Fortran",
    "text": "Fortran\n\nFortran (Formula Translating System) appeared in 1957\nCompiled language with static typing\nObject-oriented features added in 2003 standard\nStill a lot of Fortran compilers produce fast code\nGood fit for mathematical applications\nSince the 2008 standard: coarrays as a built-in parallel programming model"
  },
  {
    "objectID": "introduction.html#java",
    "href": "introduction.html#java",
    "title": "Introduction",
    "section": "Java",
    "text": "Java\n\nSyntax influenced by C/C++, supports object orientation\nSource code compiled to Java bytecode which runs in virtual machine\n\nin principle slower code execution\n\nMemory safety and automatic garbage collection\nQuite often used in bio informatics"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-1",
    "href": "introduction.html#scientific-programming-landscape-1",
    "title": "Introduction",
    "section": "Scientific programming landscape 2",
    "text": "Scientific programming landscape 2"
  },
  {
    "objectID": "introduction.html#julia",
    "href": "introduction.html#julia",
    "title": "Introduction",
    "section": "Julia",
    "text": "Julia\n\nDesigned for technical and numerical computing\nDynamically typed, supports multiple paradigms\nScripted language with some support for compiling\nDesigned for parallel computing"
  },
  {
    "objectID": "introduction.html#python",
    "href": "introduction.html#python",
    "title": "Introduction",
    "section": "Python",
    "text": "Python\n\nScripting language, runs in Python interpreter\nDynamically typed, garbage collection\nPerceived as easy to learn\nNot very efficient (unless actual work is done by C/Fortran)\nPopular in scientific computing, including machine learning 3"
  },
  {
    "objectID": "introduction.html#r",
    "href": "introduction.html#r",
    "title": "Introduction",
    "section": "R",
    "text": "R\n\nAimed at statistical computing and visualization\nInterpreted language, runs in R interpreter\nSimilar in many aspects to Python\nPopular in some fields such as social sciences and economics"
  },
  {
    "objectID": "introduction.html#matlab",
    "href": "introduction.html#matlab",
    "title": "Introduction",
    "section": "Matlab",
    "text": "Matlab\n\nProprietary numeric computing environment\nExtensive built-in functions for linear algebra, signal processing, optimization, and statistics"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-2",
    "href": "introduction.html#scientific-programming-landscape-2",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "introduction.html#programming-accelerators",
    "href": "introduction.html#programming-accelerators",
    "title": "Introduction",
    "section": "Programming accelerators",
    "text": "Programming accelerators\n\nThus far: general-purpose programming languages for CPUs\nGPUs (originally for visualization) are well suited for scientific computing\n\nRequire dedicated programming languages\nCUDA for NVIDIA GPUs\nROCm for AMD GPUs\nOpenCL/OpenMP/… support multiple devices"
  },
  {
    "objectID": "introduction.html#parallelization",
    "href": "introduction.html#parallelization",
    "title": "Introduction",
    "section": "Parallelization",
    "text": "Parallelization\n\nHigh performance computing (HPC) is all about parallelization\nNearly all programming languages are inherently serial,parallelization has to be added\nSeveral paradigms:\n\npthreads (OS level)\nOpenMP: shared-memory parallel programming in C/C++ and Fortran\nMPI: message passing interface for communication between processes"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-3",
    "href": "introduction.html#scientific-programming-landscape-3",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape\nConclusions:\n\nKnowing multiple languages is useful\n\nAllows you to use the right tool for the right job\nFor example, C for computationally-intensive parts, Python for post processing\n\nSelect a few languages in which you become an expert\nLook beyond intrinsic properties, the ecosystem and support is important"
  },
  {
    "objectID": "introduction.html#what-you-will-learn-in-this-course",
    "href": "introduction.html#what-you-will-learn-in-this-course",
    "title": "Introduction",
    "section": "What you will learn in this course",
    "text": "What you will learn in this course\n\nthe place of C in the landscape of scientific programming languages\nlearn (most of) the C syntax 4\nwrite and run basic C programs with a focus on programming concepts encountered in science\nhow to use external libraries when writing C code"
  },
  {
    "objectID": "introduction.html#what-you-will-not-learn-in-this-course",
    "href": "introduction.html#what-you-will-not-learn-in-this-course",
    "title": "Introduction",
    "section": "What you will not learn in this course 5",
    "text": "What you will not learn in this course 5\n\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "introduction.html#what-you-will-not-learn-in-this-course-1",
    "href": "introduction.html#what-you-will-not-learn-in-this-course-1",
    "title": "Introduction",
    "section": "What you will not learn in this course 6",
    "text": "What you will not learn in this course 6\n\n\n\n\n\n\nTip\n\n\n\nThe calendar of VSC Training sessions can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between training sessions can be found at https://gjbex.github.io/Training-sessions."
  },
  {
    "objectID": "introduction.html#outline-1",
    "href": "introduction.html#outline-1",
    "title": "Introduction",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#footnotes",
    "href": "introduction.html#footnotes",
    "title": "Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.vscentrum.be↩︎\nThe line between compiled and interpreted is not as clear as indicated in this picture↩︎\nThe heavy computational lifting is usually not done in Python↩︎\nBased on “The C Programming Language” second edition by Kernighan and Ritchie↩︎\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course↩︎\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course↩︎"
  },
  {
    "objectID": "code_examples/swap_pointers.html",
    "href": "code_examples/swap_pointers.html",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers-1",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers-1",
    "title": "",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers-2",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers-2",
    "title": "",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers-3",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers-3",
    "title": "",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers-4",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers-4",
    "title": "",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers-5",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers-5",
    "title": "",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\nOutput:\nx = 10, y = 5\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5"
  },
  {
    "objectID": "beyond_c_core.html",
    "href": "beyond_c_core.html",
    "title": "External libraries",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "beyond_c_core.html#outline",
    "href": "beyond_c_core.html#outline",
    "title": "External libraries",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "beyond_c_core.html#external-libraries-1",
    "href": "beyond_c_core.html#external-libraries-1",
    "title": "External libraries",
    "section": "External libraries",
    "text": "External libraries\n\n\nThere are literally hundreds of potentially useful scientific libraries\nThe ones discussed here are by no means exhaustive or representative for your case\nThe intention is to get a feel for how you can proceed to use libraries in general"
  },
  {
    "objectID": "beyond_c_core.html#external-libraries-overview",
    "href": "beyond_c_core.html#external-libraries-overview",
    "title": "External libraries",
    "section": "External libraries overview",
    "text": "External libraries overview\n\n\nExternal libraries extend C’s capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting)\n\n\n\n\nCommon scientific libraries:\n\nGSL (GNU Scientific Library)\nBLAS/LAPACK (Linear Algebra)\nFFTW (Fast Fourier Transforms)\nHDF5 (Hierarchical data format)\n\n\n\n\n\nBenefits:\n\nAvoid reinventing the wheel\nLeverage optimized, tested code\nImprove performance and portability"
  },
  {
    "objectID": "beyond_c_core.html#using-external-libraries",
    "href": "beyond_c_core.html#using-external-libraries",
    "title": "External libraries",
    "section": "Using external libraries",
    "text": "Using external libraries\n\nBefore you can include calls to external libraries in your code, you typically need to include relevant header files\n\nHeader files define signatures of functions, structs, constants\n\nTo compile code relying on an external library into an executable, you need to link that library\n\nTypically -l&lt;libname&gt;, check library documentation"
  },
  {
    "objectID": "beyond_c_core.html#static-vs-dynamic-libraries",
    "href": "beyond_c_core.html#static-vs-dynamic-libraries",
    "title": "External libraries",
    "section": "Static vs Dynamic Libraries",
    "text": "Static vs Dynamic Libraries\n\n\n\n\n\n\n\n\nFeature\nStatic Library (.a/.lib)\nDynamic Library (.so/.dll)\n\n\n\n\nLinking time\nCompile time\nRuntime\n\n\nBinary size\nLarger (library included)\nSmaller (library separate)\n\n\nPortability\nEasier to distribute\nRequires library on target system\n\n\nUpdates\nRecompile to update\nCan update without recompiling\n\n\nPerformance\nSlightly faster (no indirection)\nMay have overhead at runtime\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse gcc -static for static linking, or -l&lt;libname&gt; with -L&lt;path&gt; for dynamic linking\n\n\n\n\n\n\n\n\nTip\n\n\n\nDetails differ from library to library: check the specific documentation"
  },
  {
    "objectID": "beyond_c_core.html#gnu-scientific-library",
    "href": "beyond_c_core.html#gnu-scientific-library",
    "title": "External libraries",
    "section": "GNU Scientific Library",
    "text": "GNU Scientific Library\n\nThe GNU Scientific Library (GSL) provides a wide range of mathematical routines\nHow to get it:\n\nOn the cluster: load it as a module, module load GSL/2.8-GCC-13.3.0 for example\nOn your machine: install it as a system package, apt-get install libgsl-dev for example\n\nHow to use it:\n\nInclude the relevant headers in your code\nFind relevant link flags with pkg-config --libs gsl for example\n\n\n\n\n\n\n\n\nTip\n\n\n\nBy loading a module on the cluster, some variables are set to make it easier to use libraries. For instance CPATH will include the path of the header files, LD_LIBRARY_PATH will include the path of the libraries."
  },
  {
    "objectID": "beyond_c_core.html#minimizing-a-function-with-gsl",
    "href": "beyond_c_core.html#minimizing-a-function-with-gsl",
    "title": "External libraries",
    "section": "Minimizing a function with GSL",
    "text": "Minimizing a function with GSL\nSee https://www.gnu.org/software/gsl/doc/html/min.html for documentation about one dimensional minimization\n#include &lt;stdio.h&gt;\n#include &lt;gsl/gsl_errno.h&gt;\n#include &lt;gsl/gsl_min.h&gt;\n#include &lt;gsl/gsl_math.h&gt;\n\ntypedef struct {\n    double a, b, sigma;\n} Params;\n\n// Define a function f according to the GSL rules\ndouble f(double x, void *params) {\n    Params *p = (Params *) params;\n    return exp(-p-&gt;sigma*x*x)*sin(p-&gt;a + p-&gt;b*x);\n}"
  },
  {
    "objectID": "beyond_c_core.html#minimizing-a-function-with-gsl-1",
    "href": "beyond_c_core.html#minimizing-a-function-with-gsl-1",
    "title": "External libraries",
    "section": "Minimizing a function with GSL",
    "text": "Minimizing a function with GSL\nint main() {\n    Params params = {0.3, 1.0, 0.05};\n\n    double minimum = -2.5, lower = -3.0, upper = 0.0;\n    int iter = 0, maxIter = 100, status;\n\n    const gsl_min_fminimizer_type *T = gsl_min_fminimizer_brent;\n    gsl_min_fminimizer *minimizer = gsl_min_fminimizer_alloc(T);\n    gsl_function F;\n    F.function = &f;\n    F.params = (void *) &params;\n\n    gsl_min_fminimizer_set(minimizer, &F, minimum, lower, upper);\n\n    do {\n        gsl_min_fminimizer_iterate(minimizer);\n        lower = gsl_min_fminimizer_x_lower(minimizer);\n        upper = gsl_min_fminimizer_x_upper(minimizer);\n        status = gsl_min_test_interval(lower, upper, 1.0e-6, 0.0);\n    } while (status == GSL_CONTINUE && ++iter &lt; maxIter);\n\n    if (status == GSL_SUCCESS) {\n        minimum = gsl_min_fminimizer_x_minimum(minimizer);\n        printf(\"f reached the minimum %.6f at %.6f after %d iterations\\n\", f(minimum, F.params), minimum, iter);\n    }\n\n    gsl_min_fminimizer_free(minimizer);\n    return 0;\n}"
  },
  {
    "objectID": "beyond_c_core.html#blas-basic-linear-algebra-subprograms",
    "href": "beyond_c_core.html#blas-basic-linear-algebra-subprograms",
    "title": "External libraries",
    "section": "BLAS: Basic Linear Algebra Subprograms",
    "text": "BLAS: Basic Linear Algebra Subprograms\n\nLow-level routines for vector and matrix operations\nLevels:\n\nLevel 1: Vector-vector (e.g., dot product)\nLevel 2: Matrix-vector (e.g., solving triangular systems)\nLevel 3: Matrix-matrix (e.g., matrix multiplication)"
  },
  {
    "objectID": "beyond_c_core.html#lapack-linear-algebra-package",
    "href": "beyond_c_core.html#lapack-linear-algebra-package",
    "title": "External libraries",
    "section": "LAPACK: Linear Algebra PACKage",
    "text": "LAPACK: Linear Algebra PACKage\n\nBuilt on top of BLAS\nHigh-level routines for:\n\nSolving linear systems\nEigenvalue problems\nSingular value decomposition"
  },
  {
    "objectID": "beyond_c_core.html#blas-lapack",
    "href": "beyond_c_core.html#blas-lapack",
    "title": "External libraries",
    "section": "BLAS & LAPACK",
    "text": "BLAS & LAPACK\n\n\nWhy use them?\n\nHighly optimized for performance\nPortable across platforms\nWidely used in scientific and engineering applications\n\n\n\n\n\nMany implementations are available\n\nOpenBLAS - Intel MKL - ATLAS\n\n\n\n\n\nOften implemented (partially) in Fortran and assembly\n\nC bindings nearly always available though\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nLink typically happens with -lblas -llapack, but this can be different for optimized implementations like OpenBLAS, Intel MKL, or ATLAS."
  },
  {
    "objectID": "beyond_c_core.html#dot-product-in-blas",
    "href": "beyond_c_core.html#dot-product-in-blas",
    "title": "External libraries",
    "section": "Dot product in BLAS",
    "text": "Dot product in BLAS\n#include &lt;stdio.h&gt;\n#include &lt;cblas.h&gt;\n\nint main() {\n    double x[3] = {1.0, 2.0, 3.0};\n    double y[3] = {4.0, 5.0, 6.0};\n    double result = cblas_ddot(3, x, 1, y, 1);\n    printf(\"Dot product: %f\\n\", result);\n    return 0;\n}\n$ gcc dotproduct.c -o dotproduct -lblas && ./dotproduct\nDot product: 32.000000\n\n\n\n\n\n\nTip\n\n\n\nOn the cluster, use module load OpenBLAS/0.3.27-GCC-13.3.0 and link with -lopenblas"
  },
  {
    "objectID": "beyond_c_core.html#hdf5-managing-scientific-data-in-c",
    "href": "beyond_c_core.html#hdf5-managing-scientific-data-in-c",
    "title": "External libraries",
    "section": "HDF5: Managing Scientific Data in C",
    "text": "HDF5: Managing Scientific Data in C\n\nHDF5 (Hierarchical Data Format v5)\n\nDesigned for storing and organizing large, complex datasets\nSupports n-dimensional arrays, tables, images, and metadata\nCommon in physics, climate modeling, bioinformatics, and engineering\n\nFeatures\n\nPortable and self-describing binary format\nHierarchical structure: groups and datasets (like folders and files)\nSupports compression, parallel I/O, and chunking"
  },
  {
    "objectID": "beyond_c_core.html#hdf5-schematic-view-of-an-hdf5-file",
    "href": "beyond_c_core.html#hdf5-schematic-view-of-an-hdf5-file",
    "title": "External libraries",
    "section": "HDF5: schematic view of an HDF5 file",
    "text": "HDF5: schematic view of an HDF5 file"
  },
  {
    "objectID": "beyond_c_core.html#hdf5-writing-a-dataset",
    "href": "beyond_c_core.html#hdf5-writing-a-dataset",
    "title": "External libraries",
    "section": "HDF5: writing a dataset",
    "text": "HDF5: writing a dataset\n#include \"hdf5.h\"\n\nint main() {\n    hid_t file_id, dataset_id, dataspace_id;\n    hsize_t dims[2] = {4, 6};\n    double data[4][6] = { /* initialize with values */ };\n\n    file_id = H5Fcreate(\"example.h5\", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    dataspace_id = H5Screate_simple(2, dims, NULL);\n    dataset_id = H5Dcreate(file_id, \"/mydata\", H5T_NATIVE_DOUBLE, dataspace_id,\n                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);\n    H5Dclose(dataset_id);\n    H5Sclose(dataspace_id);\n    H5Fclose(file_id);\n    return 0;\n}"
  },
  {
    "objectID": "beyond_c_core.html#solve-a-linear-system-of-equations-with-gsl",
    "href": "beyond_c_core.html#solve-a-linear-system-of-equations-with-gsl",
    "title": "External libraries",
    "section": "Solve a linear system of equations with GSL",
    "text": "Solve a linear system of equations with GSL\nGoal:\n\nWrite a program that balances a chemical equation by solving a linear system of equations using GSL.\n\nLearning outcomes:\n\nLearn how to call functions in GSL.\n\nInstructions:\n\nConsider the chemical equation \\(a C_3H_8 + b O_2 \\leftrightarrow c CO_2 + d H_2O\\). Write a program that determines values for a,b,c,d such that the equation is balanced (i.e., each element appears as often on the left hand side as on the right hand side). Make use of GSL linear algebra functions to do this.\nBonus: Find a way to make sure the coefficients are integer"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition",
    "href": "beyond_c_core.html#handwriting-recognition",
    "title": "External libraries",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nGoal:\n\nTrain a model that can recognize handwritten digits\n\nLearning outcomes:\n\nLearn how to read “production” C code without understanding all details\nWork with HDF5 and BLAS libraries\n\n\n\n\n\n\n\nTip\n\n\n\nIt is not necessary or even wanted to fully understand the mathematics of the model. The following slides contain the essential things you need to know."
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-1",
    "href": "beyond_c_core.html#handwriting-recognition-1",
    "title": "External libraries",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\n\nSupervised machine learning models:\n\n\nPropose a model \\(y = f(x; A)\\) that relates the input \\(x\\) to the output \\(y\\) with a function \\(f\\) that depends on (currently unknown) parameters \\(A\\)\nCollect a training set of known input-output pairs of \\(\\{x, y\\}\\) and determine the parameters \\(A\\) such that the model predicts the expected outputs for the training set\n\nTechnically: minimize a cost function using gradient descent\n\nUse the estimated parameters to compute output for new inputs (inference)"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-2",
    "href": "beyond_c_core.html#handwriting-recognition-2",
    "title": "External libraries",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\n\nInput \\(\\mathbf{x}\\): vector of size \\(784\\) representing grayscale values of an image of \\(28 \\times 28\\) pixels\nOutput \\(\\mathbf{y}\\): vector of size \\(10\\), representing probabilities that image is classified as integer \\(\\{ 0, 1, ..., 9\\}\\)\nModel \\(\\mathbf{y} = \\sigma \\left( W \\mathbf{x} + \\mathbf{B} \\right)\\)\n\nPerceptron: neuron whose activation depends on weights, biases and inputs\n\\(\\sigma\\) is an activation function, in this case a softmax\n\nParameters: \\(W\\) (\\(782 \\times 10\\)) matrix and \\(\\mathbf{B}\\) (vector of size 10)\n\n\n\n\n\n\n\nTip\n\n\n\nThis is not a state-of-the art model, but does demonstrate the essence of even very modern machine learning."
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-3",
    "href": "beyond_c_core.html#handwriting-recognition-3",
    "title": "External libraries",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nAn excellent tutorial is available at https://www.3blue1brown.com/lessons/neural-networks (it uses multiple layers, so more parameters than in our case)"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-4",
    "href": "beyond_c_core.html#handwriting-recognition-4",
    "title": "External libraries",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nInstructions:\n\nUse https://github.com/AndrewCarterUK/mnist-neural-network-plain-c as a starting point\nGo through the code and try to get a high-level overview, without getting lost in the implementation details\nAdd checkpointing: allow storing parameters at the end of training in HDF5 format. Also allow reading them back in as initial guess to resume training\nReplace the linear algebra operations by calls to BLAS. Compare the performance with the original implementation\nWrite a companion program that does inference by using precalculated parameters\nImplement your own feature that you think would improve the code"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-discussion",
    "href": "beyond_c_core.html#handwriting-recognition-discussion",
    "title": "External libraries",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.00%\nP(1) =   0.01%\nP(2) =   0.11%\nP(3) =  99.81%\nP(4) =   0.00%\nP(5) =   0.02%\nP(6) =   0.00%\nP(7) =   0.00%\nP(8) =   0.05%\nP(9) =   0.00%\nDigit prediction: 3"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-discussion-1",
    "href": "beyond_c_core.html#handwriting-recognition-discussion-1",
    "title": "External libraries",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.05%\nP(1) =   0.00%\nP(2) =   0.01%\nP(3) =  96.88%\nP(4) =   0.00%\nP(5) =   3.06%\nP(6) =   0.00%\nP(7) =   0.00%\nP(8) =   0.00%\nP(9) =   0.00%\nDigit prediction: 3"
  },
  {
    "objectID": "beyond_c_core.html#handwriting-recognition-discussion-2",
    "href": "beyond_c_core.html#handwriting-recognition-discussion-2",
    "title": "External libraries",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.00%\nP(1) =   0.08%\nP(2) =   0.68%\nP(3) =   0.01%\nP(4) =   0.00%\nP(5) =   0.00%\nP(6) =  99.08%\nP(7) =   0.00%\nP(8) =   0.14%\nP(9) =   0.00%\nDigit prediction: 6"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-faults-1",
    "href": "beyond_c_core.html#segmentation-faults-1",
    "title": "External libraries",
    "section": "Segmentation faults",
    "text": "Segmentation faults\n\nA segmentation fault occurs when a program accesses memory it does not own.\nCommon causes:\n\nDereferencing NULL or uninitialized pointers\nAccessing memory out of bounds (arrays, strings)\nWriting to read-only memory"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-fault-example",
    "href": "beyond_c_core.html#segmentation-fault-example",
    "title": "External libraries",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\n#include &lt;stdio.h&gt;\n \nint main(void) {\n    int n = 4;\n    int A[n];\n    for (int i = 0; i &lt;= n; i++) printf(\"A[%5d] = %12d\\n\", i, A[i]);\n    for (int i = 1; i &lt;= n; i++) printf(\"A[%5d] = %12d\\n\", i * 30000, A[i * 30000]);\n    return 0;\n}\nWhat will happen when you compile and run this program?\n\nThe program will not compile\nThe program will crash when accessing A[0] since its value is not initialized\nThe program will crash when accessing A[4] since it is outside of the array\nThe program might crash when accessing any element outside of the array\nThe program will always run to completion"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-fault-example-1",
    "href": "beyond_c_core.html#segmentation-fault-example-1",
    "title": "External libraries",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\nA[    0] =            0\nA[    1] =            0\nA[    2] =      4199005\nA[    3] =            0\nA[    4] =  -2103564768\nA[30000] =   1818850658\nA[60000] =    774974819\nSegmentation fault (core dumped)\n\nSome elements of the array (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[30000]) have a garbage value\n\nMakes sense, you just get what happens to be in memory at (A + 30000)\n\nThe access of A[90000] gives a segmentation fault\n\n???"
  },
  {
    "objectID": "beyond_c_core.html#virtual-vs-physical-memory",
    "href": "beyond_c_core.html#virtual-vs-physical-memory",
    "title": "External libraries",
    "section": "Virtual vs physical memory",
    "text": "Virtual vs physical memory\n\n\n\nAs a user/programmer, you see virtual memory\nVirtual memory creates the illusion of a large, contiguous, uniform address space\n\nHides fragmentation of physical memory\nDelegates managing memory hierarchy (caches, RAM, disk) to OS\nProvides safety mechanism to isolate process’ address space\n\n\n\n\n\n\n\n\nMapping to phyical memory in page table\n\nOut-of-bound memory access can pick up garbage mapping address\nYou might be accessing another process’ memory, even on read access the CPU throws a segmentation fault"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-fault-example-2",
    "href": "beyond_c_core.html#segmentation-fault-example-2",
    "title": "External libraries",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\nA[    0] =            0\nA[    1] =            0\nA[    2] =      4199005\nA[    3] =            0\nA[    4] =  -2103564768\nA[30000] =   1818850658\nA[60000] =    774974819\nSegmentation fault (core dumped)\n\nSome elements of the array (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[30000]) have a garbage value\n\nMakes sense, you just get what happens to be in memory at (A + 3000)\n\nThe access of A[90000] gives a segmentation fault\n\nThis virtual address corresponds to a physical address that is not part of the process\nThe operating system reports this as a segmentation fault"
  },
  {
    "objectID": "beyond_c_core.html#handling-segmentation-faults",
    "href": "beyond_c_core.html#handling-segmentation-faults",
    "title": "External libraries",
    "section": "Handling segmentation faults",
    "text": "Handling segmentation faults\n\nDo not make coding mistakes :)\nAsk the compiler to instrument executable to\n\ngcc -fsanitize=bounds-strict segmentation_fault.c\nCan lead to lower performance\n\nRun the program under a debugger such as gdb\n\nCompile with debug symbols (-g)"
  },
  {
    "objectID": "beyond_c_core.html#versions-of-c-1",
    "href": "beyond_c_core.html#versions-of-c-1",
    "title": "External libraries",
    "section": "Versions of C 1",
    "text": "Versions of C 1"
  },
  {
    "objectID": "beyond_c_core.html#a-brief-history-of-c",
    "href": "beyond_c_core.html#a-brief-history-of-c",
    "title": "External libraries",
    "section": "A brief history of C",
    "text": "A brief history of C\n\nC development starts in the early 1970s\nFirst standard published in 1989: ANSI C or C89\nUpdate in 1999: C99 standard\nUpdate in 2011: C11 standard\nMinor bugfixes in 2017: C17 (sometimes referred to as C18)\nUpdate in 2023: C23"
  },
  {
    "objectID": "beyond_c_core.html#different-c-standards",
    "href": "beyond_c_core.html#different-c-standards",
    "title": "External libraries",
    "section": "Different C standards",
    "text": "Different C standards\n\nThe C89 standard is still considered the default\nCompiler has to be instructed to use specific standard: gcc -std=c11\n\nYou need a recent compiler for the most recent standard\n\nCompilers often do not stick exactly to standard\n\ngcc provides some C99 constructions by default\nOptions like -std=c89 -pedantic make it more strict"
  },
  {
    "objectID": "beyond_c_core.html#the-c99-standard-additions",
    "href": "beyond_c_core.html#the-c99-standard-additions",
    "title": "External libraries",
    "section": "The C99 standard additions",
    "text": "The C99 standard additions\n\nSingle-line comments with //\nVariable length arrays\nMark functions with inline to avoid call overhead\nUse restrict to indicate arrays do not overlap\nBoolean and complex types in &lt;bool.h&gt; and &lt;complex.h&gt;\nType-generic macros in &lt;tgmath.h&gt;\nIEEE 754 floating point support"
  },
  {
    "objectID": "beyond_c_core.html#inline-functions",
    "href": "beyond_c_core.html#inline-functions",
    "title": "External libraries",
    "section": "Inline functions",
    "text": "Inline functions\n\nFunction call: expensive\n\ncall stack must be maintained\nstack variables allocated, initialized\n\nSmall functions, called often: lots of overhead\nInline functions: function code inserted in caller\n\ngood compilers try that anyway\nhelping compilers: better optimization!\n\n\ninline double sqr(double x) {\n    return x*x;\n}"
  },
  {
    "objectID": "beyond_c_core.html#restrict-keyword-for-arrays",
    "href": "beyond_c_core.html#restrict-keyword-for-arrays",
    "title": "External libraries",
    "section": "Restrict keyword for arrays",
    "text": "Restrict keyword for arrays\n\nArrays in C:\n\ndecay into pointers, just contain address of first element\nno semantics for compiler\n\nMultiple arrays as function arguments, do they overlap?\nHelp compiler, use restrict\n\nprogrammer assures to compiler that arrays don’t overlap\n\n\nvoid daxpy_r(double * restrict z, double a, double * restrict x,\n             double * restrict y, int n);"
  },
  {
    "objectID": "beyond_c_core.html#complex-numbers",
    "href": "beyond_c_core.html#complex-numbers",
    "title": "External libraries",
    "section": "Complex numbers",
    "text": "Complex numbers\n\nTypes:\n\nfloat complex: single precision\ndouble complex: double precision\nlong double complex: extended precision\n\nDeclarations in complex.h\n\ntypes\nliteral: I\nfunctions, e.g., creal, cimag, csqrt, cexp, …"
  },
  {
    "objectID": "beyond_c_core.html#type-generic-math",
    "href": "beyond_c_core.html#type-generic-math",
    "title": "External libraries",
    "section": "Type-generic math",
    "text": "Type-generic math\n\nAutomatically selects the correct version of a math function:\n\nfloat, double, or long double\ncomplex or real types\n\nCleaner code: No need to manually choose sinf, sin, or sinl.\nType safety: Matches function to argument type at compile time.\n\n#include &lt;tgmath.h&gt;\n\ndouble x = 0.5;\nfloat y = 0.5f;\n\ndouble result1 = sin(x);  // uses sin()\nfloat result2 = sin(y);   // uses sinf()"
  },
  {
    "objectID": "beyond_c_core.html#ieee-754-floating-point-support",
    "href": "beyond_c_core.html#ieee-754-floating-point-support",
    "title": "External libraries",
    "section": "IEEE 754 floating point support",
    "text": "IEEE 754 floating point support\n\nfloat: 4 byte, single precision\ndouble: 8 byte, double precision\nlong double: 12 byte, extended precision\nRounding well-defined\nSupport for Inf, -Inf, NaN"
  },
  {
    "objectID": "beyond_c_core.html#the-c11-standard",
    "href": "beyond_c_core.html#the-c11-standard",
    "title": "External libraries",
    "section": "The C11 standard",
    "text": "The C11 standard\nThe _Generic Keyword\n\nEnables type-generic programming (like tgmath.h)\nExample:\n#define my_abs(x) _Generic((x), \\\n    int: abs, \\\n    float: fabsf, \\\n    double: fabs \\\n)(x)"
  },
  {
    "objectID": "beyond_c_core.html#mathematics-in-c23",
    "href": "beyond_c_core.html#mathematics-in-c23",
    "title": "External libraries",
    "section": "Mathematics in C23",
    "text": "Mathematics in C23\n\nNew mathematical functions in math.h\n\nsinpi(x) is the same as sin(pi*x) with better precision\nexp10 et al.\n\nChecked integer arithmetic in stdckdint.h\n\nckd_add et al.\n\nSupport for 1'000 and 1'133.023 notation\nDecimal floating-point math (IEEE 754-2008/2019)"
  },
  {
    "objectID": "beyond_c_core.html#syntax-changes-in-c23",
    "href": "beyond_c_core.html#syntax-changes-in-c23",
    "title": "External libraries",
    "section": "Syntax changes in C23",
    "text": "Syntax changes in C23\n\nnullptr (keyword) rather than NULL (macro)\ntrue/false keywords, stdbool.h not required\nUnnamed function parameters\nstdbit.h: bit manipulation functions\nstrdup/strndup: simple string duplication\nconstexpr for compile-time constants\nstatic_assert for compile-time asserts\ntypeof to determine type at compile time"
  },
  {
    "objectID": "beyond_c_core.html#c23-attributes",
    "href": "beyond_c_core.html#c23-attributes",
    "title": "External libraries",
    "section": "C23 attributes",
    "text": "C23 attributes\n\nDefensive programming\n\n[[fallthrough]]: intentional fall-through in switch\n[[nodiscard]]: don’t ignore return value\n[[maybe_unused]]: don’t warn if not used (function/parameter)\n[[deprecated]]\n\nPerformance related\n\n[[unsequenced]]: function has no side-effects, calls can be out-of-order\n[[reproducible]]: function has no side-effect, calls have to be in-order (e.g., random numbers)"
  },
  {
    "objectID": "beyond_c_core.html#scientific-programming-landscape",
    "href": "beyond_c_core.html#scientific-programming-landscape",
    "title": "External libraries",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "beyond_c_core.html#more-to-explore",
    "href": "beyond_c_core.html#more-to-explore",
    "title": "External libraries",
    "section": "More to explore",
    "text": "More to explore\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "beyond_c_core.html#more-to-explore-1",
    "href": "beyond_c_core.html#more-to-explore-1",
    "title": "External libraries",
    "section": "More to explore",
    "text": "More to explore\n\n\n\n\n\n\nTip\n\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/."
  },
  {
    "objectID": "beyond_c_core.html#footnotes",
    "href": "beyond_c_core.html#footnotes",
    "title": "External libraries",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAdapted from https://github.com/gjbex/Scientific-C↩︎"
  },
  {
    "objectID": "index.html#who-am-i",
    "href": "index.html#who-am-i",
    "title": "Scientific C for programmers",
    "section": "Who am I?",
    "text": "Who am I?\nMain lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modeling\n\nSupport during hands-on sessions from Jan De Laet\nhttps://www.vscentrum.be"
  },
  {
    "objectID": "index.html#who-are-you",
    "href": "index.html#who-are-you",
    "title": "Scientific C for programmers",
    "section": "Who are you?",
    "text": "Who are you?\nPlease present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C"
  },
  {
    "objectID": "index.html#practical-aspects",
    "href": "index.html#practical-aspects",
    "title": "Scientific C for programmers",
    "section": "Practical aspects",
    "text": "Practical aspects\n\nFour sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference."
  },
  {
    "objectID": "index.html#outline",
    "href": "index.html#outline",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c",
    "href": "index.html#why-learn-to-program-in-c",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-1",
    "href": "index.html#why-learn-to-program-in-c-1",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nDidn’t AI agents take over programming? In my opinion:\n\nAI agents are invaluable assistants\nStill benefit greatly from a prompter with expertise because:\n\nThey will confidently write code that is wrong\nThey will often produce sub-optimal code (speed, maintainability, …)\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThis opinion might be outdated very soon."
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-2",
    "href": "index.html#why-learn-to-program-in-c-2",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nI encourage you to use AI assistance during this course\n\nYou will use it in real-life coding\nYou need to learn how to use it\n\nwith two caveats:\n\nThe exercises are educational,AI might perform better than for your real problems\nDon’t cheat on yourself,try to understand the answers to learn something"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-3",
    "href": "index.html#why-learn-to-program-in-c-3",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\n\nRelatively low level, close to hardware\n\nPopular to write system software (OS for example)\nGives insight into computer architecture\n\nPotentially gives good performance\n\nFairly popular in scientific computing\n\nSmall and stable language, syntax can be learned quickly\nGood basis to learn other programming languages\nYou inherited a project written in C\n\nNot a good intrinsic motivation, but a reality"
  },
  {
    "objectID": "index.html#scientific-programming-landscape",
    "href": "index.html#scientific-programming-landscape",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#assembly",
    "href": "index.html#assembly",
    "title": "Scientific C for programmers",
    "section": "Assembly",
    "text": "Assembly\n\nVery low level, essentially machine code in readable format\nMachine dependent, specific to each architecture\nUsed in performance-critical parts of low-level libraries\nIf you are not sure you need it, you don’t\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe godbolt project gives a taste of what assembly looks like."
  },
  {
    "objectID": "index.html#c",
    "href": "index.html#c",
    "title": "Scientific C for programmers",
    "section": "C",
    "text": "C\n\nFirst appeared in 1972, successor of B\nFirst standard in 1989, four revisions since\nCompiled language with static typing\nSmall language and standard library\nGives a lot of low-level control (e.g., memory management)"
  },
  {
    "objectID": "index.html#c-1",
    "href": "index.html#c-1",
    "title": "Scientific C for programmers",
    "section": "C++",
    "text": "C++\n\nExtension of C, adding object-oriented features\nCompiled language with static typing\nAllows better and more complex project constructs\nMore syntax and much larger standard library\nIn principle retains all benefits from C,in practice you program differently"
  },
  {
    "objectID": "index.html#rust",
    "href": "index.html#rust",
    "title": "Scientific C for programmers",
    "section": "Rust",
    "text": "Rust\n\n“Modern” version of C/C++\nVery different approach to memory management:\n\nC/C++ are prone to bugs causing safety issues\nRust is proposed as an alternative, see DARPA: Translating all C to Rust\nNot as problematic for programs you run locally\n\nEcosystem for scientific computing not as advanced as C/C++, but efforts are under way\n\nExample of a project for high-performance data manipulation: Polars dataframes"
  },
  {
    "objectID": "index.html#fortran",
    "href": "index.html#fortran",
    "title": "Scientific C for programmers",
    "section": "Fortran",
    "text": "Fortran\n\nFortran (Formula Translating System) appeared in 1957\nCompiled language with static typing\nObject-oriented features added in 2003 standard\nStill a lot of Fortran compilers produce fast code\nGood fit for mathematical applications\nSince the 2008 standard: coarrays as a built-in parallel programming model"
  },
  {
    "objectID": "index.html#java",
    "href": "index.html#java",
    "title": "Scientific C for programmers",
    "section": "Java",
    "text": "Java\n\nSyntax influenced by C/C++, supports object orientation\nSource code compiled to Java bytecode which runs in virtual machine\n\nin principle slower code execution\n\nMemory safety and automatic garbage collection\nQuite often used in bio informatics"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-1",
    "href": "index.html#scientific-programming-landscape-1",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape 1",
    "text": "Scientific programming landscape 1\n\nThe line between compiled and interpreted is not as clear as indicated in this picture"
  },
  {
    "objectID": "index.html#julia",
    "href": "index.html#julia",
    "title": "Scientific C for programmers",
    "section": "Julia",
    "text": "Julia\n\nDesigned for technical and numerical computing\nDynamically typed, supports multiple paradigms\nScripted language with some support for compiling\nDesigned for parallel computing"
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Scientific C for programmers",
    "section": "Python",
    "text": "Python\n\nScripting language, runs in Python interpreter\nDynamically typed, garbage collection\nPerceived as easy to learn\nNot very efficient (unless actual work is done by C/Fortran)\nPopular in scientific computing, including machine learning 1\n\nThe heavy computational lifting is usually not done in Python"
  },
  {
    "objectID": "index.html#r",
    "href": "index.html#r",
    "title": "Scientific C for programmers",
    "section": "R",
    "text": "R\n\nAimed at statistical computing and visualization\nInterpreted language, runs in R interpreter\nSimilar in many aspects to Python\nPopular in some fields such as social sciences and economics"
  },
  {
    "objectID": "index.html#matlab",
    "href": "index.html#matlab",
    "title": "Scientific C for programmers",
    "section": "Matlab",
    "text": "Matlab\n\nProprietary numeric computing environment\nExtensive built-in functions for linear algebra, signal processing, optimization, and statistics"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-2",
    "href": "index.html#scientific-programming-landscape-2",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#programming-accelerators",
    "href": "index.html#programming-accelerators",
    "title": "Scientific C for programmers",
    "section": "Programming accelerators",
    "text": "Programming accelerators\n\nThus far: general-purpose programming languages for CPUs\nGPUs (originally for visualization) are well suited for scientific computing\n\nRequire dedicated programming languages\nCUDA for NVIDIA GPUs\nROCm for AMD GPUs\nOpenCL/OpenMP/… support multiple devices"
  },
  {
    "objectID": "index.html#parallelization",
    "href": "index.html#parallelization",
    "title": "Scientific C for programmers",
    "section": "Parallelization",
    "text": "Parallelization\n\nHigh performance computing (HPC) is all about parallelization\nNearly all programming languages are inherently serial,parallelization has to be added\nSeveral paradigms:\n\npthreads (OS level)\nOpenMP: shared-memory parallel programming in C/C++ and Fortran\nMPI: message passing interface for communication between processes"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-3",
    "href": "index.html#scientific-programming-landscape-3",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape\nConclusions:\n\nKnowing multiple languages is useful\n\nAllows you to use the right tool for the right job\nFor example, C for computationally-intensive parts, Python for post processing\n\nSelect a few languages in which you become an expert\nLook beyond intrinsic properties, the ecosystem and support is important"
  },
  {
    "objectID": "index.html#what-you-will-learn-in-this-course",
    "href": "index.html#what-you-will-learn-in-this-course",
    "title": "Scientific C for programmers",
    "section": "What you will learn in this course",
    "text": "What you will learn in this course\n\nthe place of C in the landscape of scientific programming languages\nlearn (most of) the C syntax 1\nwrite and run basic C programs with a focus on programming concepts encountered in science\nhow to use external libraries when writing C code\n\nBased on “The C Programming Language” second edition by Kernighan and Ritchie"
  },
  {
    "objectID": "index.html#what-you-will-not-learn-in-this-course",
    "href": "index.html#what-you-will-not-learn-in-this-course",
    "title": "Scientific C for programmers",
    "section": "What you will not learn in this course 1",
    "text": "What you will not learn in this course 1\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)\n\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course"
  },
  {
    "objectID": "index.html#what-you-will-not-learn-in-this-course-1",
    "href": "index.html#what-you-will-not-learn-in-this-course-1",
    "title": "Scientific C for programmers",
    "section": "What you will not learn in this course 1",
    "text": "What you will not learn in this course 1\n\n\n\n\n\n\nTip\n\n\nThe calendar of VSC Training sessions can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between training sessions can be found at https://gjbex.github.io/Training-sessions.\n\n\n\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course"
  },
  {
    "objectID": "index.html#outline-1",
    "href": "index.html#outline-1",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#the-obligatory-hello-world",
    "href": "index.html#the-obligatory-hello-world",
    "title": "Scientific C for programmers",
    "section": "The obligatory “Hello, world”",
    "text": "The obligatory “Hello, world”\nGoal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program\nInstructions:\n\nOpen the Visual Studio Code app via https://ondemand.hpc.kuleuven.be if you have a VSC account\nUse a C environment on your local machine if available\nCreate an app on https://replit.com/languages/c otherwise"
  },
  {
    "objectID": "index.html#temperature-conversion",
    "href": "index.html#temperature-conversion",
    "title": "Scientific C for programmers",
    "section": "Temperature conversion",
    "text": "Temperature conversion\nGoal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors"
  },
  {
    "objectID": "index.html#logistic-map",
    "href": "index.html#logistic-map",
    "title": "Scientific C for programmers",
    "section": "Logistic map",
    "text": "Logistic map\n\nSimple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)"
  },
  {
    "objectID": "index.html#logistic-map-1",
    "href": "index.html#logistic-map-1",
    "title": "Scientific C for programmers",
    "section": "Logistic map",
    "text": "Logistic map\nGoal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercises/02_logistic_map"
  },
  {
    "objectID": "index.html#logistic-map-solution",
    "href": "index.html#logistic-map-solution",
    "title": "Scientific C for programmers",
    "section": "Logistic map: solution",
    "text": "Logistic map: solution\ndouble update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input"
  },
  {
    "objectID": "index.html#logistic-map-discussion",
    "href": "index.html#logistic-map-discussion",
    "title": "Scientific C for programmers",
    "section": "Logistic map: discussion",
    "text": "Logistic map: discussion\n\nComparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate =&gt; example of a chaotic system"
  },
  {
    "objectID": "index.html#outline-2",
    "href": "index.html#outline-2",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#data-types-operators-and-expressions-1",
    "href": "index.html#data-types-operators-and-expressions-1",
    "title": "Scientific C for programmers",
    "section": "Data types, operators and expressions 1 2",
    "text": "Data types, operators and expressions 1 2\n\nVariables are the basic data objects manipulated in a C program\nC is statically typed: a variable is of a specific type defined at compile time\nC allows manipulation of variables by expressions with operators\n\nKernighan and Ritchie, Chapter 2, Types, operators and expressionsAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#the-very-basics",
    "href": "index.html#the-very-basics",
    "title": "Scientific C for programmers",
    "section": "The very basics",
    "text": "The very basics\n\n\n\nC statements 1 end with a semicolon\nBraces {} are used to group statements into a code block\nWhitespace is mostly ignored, allows to improve readability\nCompiler ignores what comes after // and between /* and */\n\n\nint a = 10;\nif (a &gt; 0) {\n    b = 2; // Single-line comment\n    c = 3;\n}\n/* Multi-line\n   comment */\n\nA statement is roughly a programming instruction, something to do"
  },
  {
    "objectID": "index.html#names-of-data-objects-in-c",
    "href": "index.html#names-of-data-objects-in-c",
    "title": "Scientific C for programmers",
    "section": "Names of data objects in C",
    "text": "Names of data objects in C\n\nare case sensitive\nconsist of {A,...,Z,a,...,z,_,0,...,9}\nstart with {A,...,Z,a,...,z,_}\ncan have any length, but at most:\n\nvariables: 31 significant, 64 for C99+\nfunctions: 6 significant1, 32 for C99+\n\ncannot be reserved words such as if, while, char, int, …\n\nguaranteed by standard, nowadays most compilers allow longer lengths"
  },
  {
    "objectID": "index.html#conventions-for-names",
    "href": "index.html#conventions-for-names",
    "title": "Scientific C for programmers",
    "section": "Conventions for names",
    "text": "Conventions for names\n\nvariables, functions: start with lowercase\nconstants, type names: start with uppercase or fully capitalized\nnames reflect semantics of entity!\n\nvariables with very small scope have a short name\n\ncamelCase (e.g., nrOfRuns) or underscores nr_of_runs\n\n\n\n\n\n\n\nTip\n\n\nTry to be consistent within a project. If you might share code with others, try to stick to a generally accepted code style, e.g. the GNU coding standard"
  },
  {
    "objectID": "index.html#overview-of-data-types",
    "href": "index.html#overview-of-data-types",
    "title": "Scientific C for programmers",
    "section": "Overview of data types",
    "text": "Overview of data types\n\nchar: single character\nint: integer, allows qualifiers (signed, long, …)\nfloat/double/long double: real numbers\nenum: list of constants\nstruct: structure, group of related variables"
  },
  {
    "objectID": "index.html#characters",
    "href": "index.html#characters",
    "title": "Scientific C for programmers",
    "section": "Characters",
    "text": "Characters\n\na char holds 1 character of the local character set\nusually 1 byte, check with the sizeof operator\nlimits are defined in limits.h header as CHAR_MIN and CHAR_MAX\nchar can be signed or unsigned\n\nalmost always irrelevant, just use char\n\nExample: char myChar = 'b';\n\n\"b\" is a string (=array of chars)!"
  },
  {
    "objectID": "index.html#special-characters-are-escaped-with",
    "href": "index.html#special-characters-are-escaped-with",
    "title": "Scientific C for programmers",
    "section": "Special characters are escaped with \\",
    "text": "Special characters are escaped with \\\n\n'\\a': bell\n'\\n': new line\n'\\r': carriage return\n'\\t': horizontal tab\n'\\\\': backslash\n'\\'': single quote\n'\\\"': double quote\n'\\0': null character (terminates strings)"
  },
  {
    "objectID": "index.html#strings",
    "href": "index.html#strings",
    "title": "Scientific C for programmers",
    "section": "Strings?",
    "text": "Strings?\n\nC does not have a basic string type\nThere are two ways to declare a string constant:\n\nAn array of characters: 1\nchar amessage[] = \"My first string\";\nA character pointer: 2\nchar *pmessage = \"My second string\";\n\n\narrays are discussed later onpointers are discussed later on"
  },
  {
    "objectID": "index.html#strings-1",
    "href": "index.html#strings-1",
    "title": "Scientific C for programmers",
    "section": "Strings?",
    "text": "Strings?\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "index.html#integers",
    "href": "index.html#integers",
    "title": "Scientific C for programmers",
    "section": "Integers",
    "text": "Integers\n\nint: typically 4 bytes, offers \\(2^{32}\\) distinct values\nmodifiers:\n\nunsigned int: only non-negative integers, natural for array indices\nshort int/long int/long long int: different ranges compared to plain int, can be combined with unsigned\n\n\n\n\n\n\n\n\nTip\n\n\nThe range of int can be a limitation in practice, think about the range you need and choose the appropriate type."
  },
  {
    "objectID": "index.html#fixed-size-integers",
    "href": "index.html#fixed-size-integers",
    "title": "Scientific C for programmers",
    "section": "Fixed-size integers",
    "text": "Fixed-size integers\nThe C standard only imposes a minimal range for integers:\n\nFor example, int should at least cover \\([−32767, +32767]\\)\nSome platforms provide larger range =&gt; code is potentially platform dependent\n\nIf you need a fixed range:\n\nInclude the stdint.h header\nUse uint8_t, int16_t, …, which provide exactly the specified number of bits"
  },
  {
    "objectID": "index.html#real-numbers",
    "href": "index.html#real-numbers",
    "title": "Scientific C for programmers",
    "section": "Real numbers",
    "text": "Real numbers\n\n\n\nReal numbers are represented in a computer in a format very similar to exponential notation1\nComputer uses binary representation, e.g., the IEEE SP standard:\n\nExponent determines range\nMantissa determines precision\n\n\n\n  \n\nnot part of the C standard, but quite universal"
  },
  {
    "objectID": "index.html#double-precision",
    "href": "index.html#double-precision",
    "title": "Scientific C for programmers",
    "section": "Double precision",
    "text": "Double precision\n\n\n\n\n\na double is usually 8 bytes and gives about 15 decimal digit precision\nthe float.h header provides:\n\nDBL_MAX: largest positive double\nDBL_MIN: smallest positive double\nDBL_EPSILON: difference between 1.0 and next representable value (\\(\\approx\\) machine precision)\nBLD_DIG: number of significant decimal digits"
  },
  {
    "objectID": "index.html#basic-floating-point-representations",
    "href": "index.html#basic-floating-point-representations",
    "title": "Scientific C for programmers",
    "section": "Basic floating-point representations",
    "text": "Basic floating-point representations\n\ndouble: most often used in science\nfloat: half the number of bits compared to double, usually 7 decimal digit precision\nlong double: usually larger range than double, not used often\n\n\n\n\n\n\n\nNote\n\n\nIn deep learning, reduced-precision formats (FP16, FP8) are often used. Only dedicated devices like GPUs give hardware support."
  },
  {
    "objectID": "index.html#enumeration",
    "href": "index.html#enumeration",
    "title": "Scientific C for programmers",
    "section": "Enumeration",
    "text": "Enumeration\n\nenum makes it convenient to refer to constants symbolically\nUsing automatic integer numbering:\n\nenum Level = {LOW, MEDIUM, HIGH};\nenum Level myLevel = MEDIUM; // myLevel will be 1\n\nUsing custom values:\n\nenum Pieces = {King = 'K', Queen = 'Q', Rook = 'R', Bishop = 'B', Knight = 'N'};\nenum Pieces myPiece = Bishop; // myPiece will be 'B'"
  },
  {
    "objectID": "index.html#type-conversion",
    "href": "index.html#type-conversion",
    "title": "Scientific C for programmers",
    "section": "Type conversion",
    "text": "Type conversion\n\nIn constants, use suffix, e.g. 123456789L is a long int\nIn expressions, automatic conversion to largest type, e.g. 5/9.0 is interpreted as 5.0/9.0\nExplicit casting with brackets, e.g. (int) 5.3\n\nthis evaluates to the integer 5, so information is lost"
  },
  {
    "objectID": "index.html#accidental-type-conversion",
    "href": "index.html#accidental-type-conversion",
    "title": "Scientific C for programmers",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nWhat do you expect the following code will do?\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    double a = -1.6e12;\n    if (abs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n    else printf(\"abs(a) is smaller or equal to 0\\n\");\n}\n\n\nBehaviour is unexpected?\n\n$ gcc conversion.c -o conversion && ./conversion\nabs(a) is smaller or equal to 0"
  },
  {
    "objectID": "index.html#accidental-type-conversion-1",
    "href": "index.html#accidental-type-conversion-1",
    "title": "Scientific C for programmers",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nCompilation with -Wconversion flags provide a hint\n\n$ gcc -Wconversion conversion.c  -o conversion\nconversion.c: In function ‘main’:\nconversion.c:6:13: warning: conversion from ‘double’ to ‘int’ may change value [-Wfloat-conversion]\n    6 |     if (abs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n\n\nThe abs function is for int, double a was silently converted\nSolution: use the fabs function\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main() {\n    double a = -1.6e12;\n    if (fabs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n    else printf(\"abs(a) is smaller or equal to 0\\n\");\n}"
  },
  {
    "objectID": "index.html#variable-declaration",
    "href": "index.html#variable-declaration",
    "title": "Scientific C for programmers",
    "section": "Variable declaration",
    "text": "Variable declaration\n\nC is statically typed, each variable has to be declared with type information: int a, b;\nCan be combined with an assignment, but no automatic initalization:\n\ndouble x = 3.2, y;\ndouble z = sqrt(2.0);\n\nConstants cannot be modified during runtime, must be assigned on declaration: const int MINUTESPERHOUR = 60;\n\nConvention: names of constants are capitalized"
  },
  {
    "objectID": "index.html#booleans",
    "href": "index.html#booleans",
    "title": "Scientific C for programmers",
    "section": "Booleans",
    "text": "Booleans\n\nThe original C89 standard does not have a boolean type\n\ntrue: non-zero integer, non-NULL pointer\nfalse: zero, NULL pointer\n\nThe C99 standard adds the bool type and true/false keywords (after including &lt;stdbool.h&gt;)\nThe C23 standard provides booleans by default\nYou can get by with the C89 approach, dedicated bool type might be somewhat more efficient in some cases"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes",
    "href": "index.html#exercise-data-type-sizes",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes",
    "text": "Exercise: data type sizes\nGoal:\n\nPrint information about sizes and ranges of several types\n\nLearning outcomes:\n\nUnderstand C data types\n\nInstructions:\n\nExtend the program provided in exercises/04_data_type_sizes to print information about more types and ranges\nExplain the relation between sizes and ranges"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes-solution",
    "href": "index.html#exercise-data-type-sizes-solution",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The size of int is %zu bytes; it ranges from %d to %d\\n\",\n       sizeof(int), INT_MIN, INT_MAX);\nprintf(\"The size of unsigned long int is %zu bytes; its max is %lu\\n\",\n       sizeof(unsigned long int), ULONG_MAX);\nOutput:\nThe size of int is 4 bytes; it ranges from -2147483648 to 2147483647\nThe size of unsigned long int is 8 bytes; its max is 18446744073709551615\n\n4 bytes = 32 bits: int is in \\([-2^{31}, 2^{31}-1]\\)\n8 bytes = 64 bits: unsigned long int is in \\([0, 2^{64}-1]\\)"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes-solution-1",
    "href": "index.html#exercise-data-type-sizes-solution-1",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The largest double that can be represented is %6.1e\\n\", DBL_MAX);\nprintf(\"The smallest positive double that can be represented is %6.1e\\n\", DBL_MIN);\nprintf(\"The machine epsilon is %6.1e\\n\", DBL_EPSILON);\nprintf(\"The number of digits is %d\\n\", DBL_DIG);\nOutput:\nThe largest double that can be represented is 1.8e+308\nThe smallest positive double that can be represented is 2.2e-308\nThe machine epsilon is 2.2e-16\nThe number of digits is 15\n\nExponent has 11 bits -&gt; in range [-1023,1024] -&gt; \\(2^{1024} \\approx 10^{308}\\)\nMantissa has 52 bits -&gt; 52 significant digits in binary -&gt; \\(52 \\log_{10} 2 \\approx 15.6\\)"
  },
  {
    "objectID": "index.html#overview-of-operators",
    "href": "index.html#overview-of-operators",
    "title": "Scientific C for programmers",
    "section": "Overview of operators",
    "text": "Overview of operators\n\narithmetic operators\nrelational operators\nlogical operators\nbitwise operators\nassignment operators\nincremental operators\nconditional operator"
  },
  {
    "objectID": "index.html#arithmetic-operators",
    "href": "index.html#arithmetic-operators",
    "title": "Scientific C for programmers",
    "section": "Arithmetic operators",
    "text": "Arithmetic operators\n\naddition, subtraction: +, -\nmultiplication, division: *, /\n\ninteger division truncates fractional part, 5/9 equals 0\n\nmodulo (only for integers): %\n*, /, % take precedence over + and -\n\n\n\n\n\n\n\n\nTip\n\n\nUse brackets for clarity instead of relying on precedence rules"
  },
  {
    "objectID": "index.html#relational-operators",
    "href": "index.html#relational-operators",
    "title": "Scientific C for programmers",
    "section": "Relational operators",
    "text": "Relational operators\n\norder:\n\nsmaller, smaller or equal: &lt;, &lt;=\nlarger, larger or equal: &gt;, &gt;=\n\nequality:\n\nequal to, not equal to: ==, !=\n\n\n\n\n\n\n\n\n\nTip\n\n\nBe careful when comparing doubles, e.g. pow(sqrt(5.0), 2) == 5.0 is false!"
  },
  {
    "objectID": "index.html#logical-operators",
    "href": "index.html#logical-operators",
    "title": "Scientific C for programmers",
    "section": "Logical operators",
    "text": "Logical operators\n\nlogical and, logical or: &&, ||\n\nevaluated left to right with early stopping, (i &lt; N) && (a[i] &gt; 0) will not access a[i] unless i &lt; N\n\nunary negation !\n\nconverts non-zero operand into 0 and zero operand into 1\nzero is false, non-zero is true"
  },
  {
    "objectID": "index.html#incrementdecrement-operators",
    "href": "index.html#incrementdecrement-operators",
    "title": "Scientific C for programmers",
    "section": "Increment/decrement operators",
    "text": "Increment/decrement operators\n\nC specific shorthand notation\n\nincrement: i = i + 1; is the same as i++; or ++i;\ndecrement: i = i - 1; is the same as i--; or --i;\n\npost/pre increment matters when value is used, for example in assignment:\n\nint j = ++i;: first increment i, then assign it to j\nint j = i++;: first assign i to j, then increment i\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe name C++ can be interpreted as “incremented C”"
  },
  {
    "objectID": "index.html#bitwise-operators",
    "href": "index.html#bitwise-operators",
    "title": "Scientific C for programmers",
    "section": "Bitwise operators",
    "text": "Bitwise operators\nManipulate bits of integers (signed and unsigned char, int, long, …)\n\nBitwise and, or, xor: &, |, ^\n\n0011 & 0101 -&gt; 0001\n\nShift bits left, right: &lt;&lt;, &gt;&gt;\n\n0111 1000 &gt;&gt; 2 -&gt; xx01 1110\nx is zero if unsigned, undefined otherwise\n\nOne’s complement: ~\n\n~1101 -&gt; 0010\n\n\n\n\n\n\n\n\n\nTip\n\n\nBitwise operators are powerful, but also tedious. Use with care!"
  },
  {
    "objectID": "index.html#assignment-operators",
    "href": "index.html#assignment-operators",
    "title": "Scientific C for programmers",
    "section": "Assignment operators",
    "text": "Assignment operators\n\nSimple assignment is done with = (do not confuse with comparison ==)\nAssignment operators allow to compress statements:\n\ni = i + 2; is the same as i += 2;\nMost binary operators have a corresponding assignment operator\nMore concise, but often more intuitive as well"
  },
  {
    "objectID": "index.html#conditional-expression",
    "href": "index.html#conditional-expression",
    "title": "Scientific C for programmers",
    "section": "Conditional expression",
    "text": "Conditional expression\nConditional expression is a ternary operator condition ? expr_true : expr_false\n\nEvaluate the condition\n\nIf true, evaluate expr_true as the result\nIf false, evaluate expr_false as the result\n\n\n// z = max(a, b)\nif (a &gt; b) {\n    z = a;\n} else {\n    z = b;\n}\n// same thing but shorter\nz = (a &gt; b) ? a : b;"
  },
  {
    "objectID": "index.html#precedence-and-associativity",
    "href": "index.html#precedence-and-associativity",
    "title": "Scientific C for programmers",
    "section": "Precedence and associativity",
    "text": "Precedence and associativity\n\nK&R provide a table with precedence rules (2.12)\n\nMake your code readable and maintable by using brackets\n\nC does not specify order of evaluation for most operators:\n\norder can even depend on compiler options\nx = f() + g(); might evaluate g before f\n\nimportant if g alters variable used by f\n\na + b + c; could be (a + b) + c or a + (b + c)\n\nfloating-point arithmetic does not preserve mathematical associativity"
  },
  {
    "objectID": "index.html#exercise-operators",
    "href": "index.html#exercise-operators",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators",
    "text": "Exercise: operators\nGoal: Solve a few operator-related programming questions Learning outcome: Understand the basics of C operators Instructions: See exercises/05_operators\n\n\n\n\n\n\nTip\n\n\nThis exercise uses the assert() function to check your solution. This function can be useful for debugging, but should not be used in production code.\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can easily “cheat” the assert() statements, but that is not the intention of course."
  },
  {
    "objectID": "index.html#exercise-operators-solution",
    "href": "index.html#exercise-operators-solution",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\nImplement a function that returns if a year is a leap year: easy to achieve by combining modulo and logical operators.\nint isLeapYear(int year) {\n    /* Return 1 if year is a leap year and return 0 otherwise\n       A year is a leap year if:\n       - it is divisible by 4 but not by 100 OR\n       - it is disisible by 400\n    */\n    if ( (year % 4 == 0 && year % 100 != 0) || (year % 400) == 0) return 1;\n    else return 0;\n}"
  },
  {
    "objectID": "index.html#exercise-operators-solution-1",
    "href": "index.html#exercise-operators-solution-1",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\n// Multiply i by 8 and store it in j, but without making use of the * operator\n// Hint: use a bitwise operator\nint i = 5;\nint j = i &lt;&lt; 3;\nassert(j == 40);\n\n// Compute c as the minimal value of a and b without using an if-else statement\nint a = 126;\nint b = 45;\nint c = (a &lt; b) ? a : b;\nassert(c == b);"
  },
  {
    "objectID": "index.html#control-flow-1",
    "href": "index.html#control-flow-1",
    "title": "Scientific C for programmers",
    "section": "Control flow 1 2",
    "text": "Control flow 1 2\n\nControl flow statements specify order in which computations are performed\nOften multiple ways to achieve the same end result\n\nInvolves an element of personal preference\nOne way might provide faster code than another\n\n\nKernighan and Ritchie, Chapter 3, Control FlowAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#statements-and-blocks",
    "href": "index.html#statements-and-blocks",
    "title": "Scientific C for programmers",
    "section": "Statements and blocks",
    "text": "Statements and blocks\n\nUse ; to terminate a statement\nGroup multiple statements in blocks with braces {}\n\nblocks can be nested\nvariables can be redeclared and have block scope\n{\n   int i = 3; // from here, i is 3\n   {\n      int i = 5; //from here, i is 5\n   }\n   // from here, i is 3 again\n}\n\n\n\n\n\n\n\n\nTip\n\n\nUse blocks to make your code more readable, unless you want to participate in the The International Obfuscated C Code Contest"
  },
  {
    "objectID": "index.html#if-else-statement",
    "href": "index.html#if-else-statement",
    "title": "Scientific C for programmers",
    "section": "if-else statement",
    "text": "if-else statement\n\n\nif (expression != 0) {\n    statement_true;\n} else {\n    statement_false;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression != 0} --&gt;|true| C[statement_true]\n    B --&gt;|false| E[statement_false]\n\n\n\n\n\n\n\n\nThe else clause is optional\nFor a single-line statement, braces are optional\nIndentation is only for style, but helps for readability\nif (expression) is the same as if (expression != 0)"
  },
  {
    "objectID": "index.html#else-if-statement",
    "href": "index.html#else-if-statement",
    "title": "Scientific C for programmers",
    "section": "else-if statement",
    "text": "else-if statement\n\n\nif (expression1) {\n    statement1;\n} else if (expression2) {\n    statement2;\n} else {\n    statement3;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression1} --&gt;|true| C[statement1]\n    B --&gt;|false| E{expression2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n\n\n\n\n\n\n\n\nGeneral way to write a multi-way decision\nThe else clause is optional"
  },
  {
    "objectID": "index.html#switch",
    "href": "index.html#switch",
    "title": "Scientific C for programmers",
    "section": "Switch",
    "text": "Switch\n\n\nswitch (expression) {\n    case const-expr1: statements1\n    case const-expr2: statements2\n    default: statements3\n}\n\n\n\n\nMulti-way decision to branch based on comparison with constant integer values\nFall through: execution goes to next case\n\nYou can leave a switch with break or return\n\nCase expressions must be constant and unique\ndefault is optional"
  },
  {
    "objectID": "index.html#switch-example",
    "href": "index.html#switch-example",
    "title": "Scientific C for programmers",
    "section": "Switch example",
    "text": "Switch example\n// Count occurrence of odd and even digits in a string\nswitch (c) {\ncase '0': case '2': case '4': case '6': case '8':\n    neven++;\n    break;\ncase '1': case '3': case '5': case '7': case '9':\n    nodd++;\n    break;"
  },
  {
    "objectID": "index.html#for-loop",
    "href": "index.html#for-loop",
    "title": "Scientific C for programmers",
    "section": "For loop",
    "text": "For loop\n// General for loop\nfor (expr1; expr2; expr3) {\n    statements;\n}\n// Most common usage\nfor (int i = 0; i &lt; N; i++) {\n    statements;\n}\n\nexpr1: executed once at start, typically for initialization\nexpr2: evaluated at start of each iteration, for loop stops if false\nexpr3: evaluated at end of each iteration"
  },
  {
    "objectID": "index.html#for-loop-1",
    "href": "index.html#for-loop-1",
    "title": "Scientific C for programmers",
    "section": "For loop",
    "text": "For loop\n\nShould be used when number of repetitions is known or computed\nEach expression is optional, for (;;) {} is an infinite loop\nbreak in loop body terminates loop\ncontinue in loop body goes to next iteration"
  },
  {
    "objectID": "index.html#while-loop",
    "href": "index.html#while-loop",
    "title": "Scientific C for programmers",
    "section": "While loop",
    "text": "While loop\n// General while loop\nwhile (expression) {\n    statements;\n}\n// Check if str contains c\nwhile (i &lt; strlen(str) && !found) {\n    if (str[i] == c)\n        found = True;\n    else\n        i++;\n}\n\nstatements are executed zero or more times, as long as expression is true\nshould be used when number of repetitions is unknown"
  },
  {
    "objectID": "index.html#do-while-loop",
    "href": "index.html#do-while-loop",
    "title": "Scientific C for programmers",
    "section": "Do-While loop",
    "text": "Do-While loop\n// General while loop\ndo {\n    statements;\n} while (expression);\n\nstatements are executed at least once, until expression is false\nSimilar to while loop, but expression is evaluated at end of iteration"
  },
  {
    "objectID": "index.html#goto-and-labels",
    "href": "index.html#goto-and-labels",
    "title": "Scientific C for programmers",
    "section": "Goto and labels",
    "text": "Goto and labels\ngoto label;\n...\nlabel:\n    statements;\n\ngoto allows to branch to a specified label\nnever necessary, often makes code hard to read\neven C inventors discourage it, do do not use it"
  },
  {
    "objectID": "index.html#functions-and-program-structure-1",
    "href": "index.html#functions-and-program-structure-1",
    "title": "Scientific C for programmers",
    "section": "Functions and Program Structure 1 2",
    "text": "Functions and Program Structure 1 2\n\nFunctions break large computing tasks into smaller ones\nHelp to bring structure into code\nHide implementations details\nMake it easier to reuse existing code\n\nKernighan and Ritchie, Chapter 4, Functions and Program StructureAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#basics-of-functions",
    "href": "index.html#basics-of-functions",
    "title": "Scientific C for programmers",
    "section": "Basics of functions",
    "text": "Basics of functions\n// General function definition\nreturn-type function-name(type1 arg1, type2 arg2, ...) {\n    declarations and statements;\n    return expression;\n} \n\nA function can have no arguments: int myFunction(void);\nA function can return nothing: void myFunction(int A);\n\nNo return statement in body required\n\nThe compiler requires a function to be known before it can process a call\n\nDeclare the function: return-type function-name(type1 arg1, type2 arg2);\nDeclaration is promise to provide implementation later"
  },
  {
    "objectID": "index.html#function-examples",
    "href": "index.html#function-examples",
    "title": "Scientific C for programmers",
    "section": "Function examples",
    "text": "Function examples\n// The most minimal (useless) function\ndummy() {}\n// Compute the square of a floating-point number\ndouble square(double a) {\n    return a * a;\n}"
  },
  {
    "objectID": "index.html#return-statements",
    "href": "index.html#return-statements",
    "title": "Scientific C for programmers",
    "section": "Return statement(s)",
    "text": "Return statement(s)\n\nA return statements returns a value (or nothing), but also returns control to the caller\nA function can have multiple return statements, but at most one is executed in each call\n\nint index(char c, char s[]) {\n    unsigned i;\n    for (i = 0; i &lt; strlen(s); i++)\n        if (s[i] == c)\n            return i;\n    return -1;\n}\n\nThe returned expression is converted to function’s return type\n\n// Valid, but dubious\nint returnInt() {\n    double a = 5.0;\n    return a;\n}"
  },
  {
    "objectID": "index.html#more-on-functions",
    "href": "index.html#more-on-functions",
    "title": "Scientific C for programmers",
    "section": "More on functions",
    "text": "More on functions\n\nmain function is special: always the entry point of the program\nC passes arguments by value, inside the function a local copy is made\n\nchanges to values are invisible outside of function\npointers (see Day 3) allow to circumvent limitations\n\nA function can only return one variable\n\npack multiple values in a struct\nuse pointers (see Day 3) to pass out values\nexternal variables (usually a bad idea)"
  },
  {
    "objectID": "index.html#return-code-of-main-function",
    "href": "index.html#return-code-of-main-function",
    "title": "Scientific C for programmers",
    "section": "Return code of main function",
    "text": "Return code of main function\n\nThe return code of main is passed as exit code to calling process\nConvention is to return 0 in case of success, non-zero otherwise\nAllows chaining dependent commands, for example in bash:\n\n&& only executes next command if previous one had exit code 0\n\ncompile && execute"
  },
  {
    "objectID": "index.html#return-code-of-main-function-1",
    "href": "index.html#return-code-of-main-function-1",
    "title": "Scientific C for programmers",
    "section": "Return code of main function",
    "text": "Return code of main function\n\nstdlib.h defines some macros\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    FILE* fp = fopen(\"data.txt\", \"r\");\n    if (fp == NULL)\n    {\n       fprintf(stderr, \"fopen() failed in file %s at line #%d\", __FILE__, __LINE__);\n       exit(EXIT_FAILURE);\n    }\n\n    /* Normal processing continues here. */\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "objectID": "index.html#external-variables",
    "href": "index.html#external-variables",
    "title": "Scientific C for programmers",
    "section": "External variables",
    "text": "External variables\n\ninternal variable: defined inside function\n\nlifetime and scope limited to function call\n\nexternal variable: defined outside function\n\nbigger scope: globally accessible inside any function\nlonger lifetime: keeps value between calls\nalternative for long list of function arguments\n\n\n\n\n\n\n\n\nTip\n\n\nExternal variables typically make code less reusable, so generally they should be avoided"
  },
  {
    "objectID": "index.html#external-variables-example",
    "href": "index.html#external-variables-example",
    "title": "Scientific C for programmers",
    "section": "External variables example",
    "text": "External variables example\n#include &lt;stdio.h&gt;\nint external_variable;\n\nvoid someFunction(void) {\n    printf(\"In someFunction, external variable is %d\\n\", external_variable);\n    external_variable++;\n    }\n\nint main(void) {\n    external_variable = 1;\n    someFunction();\n    printf(\"in main, external variable is %d\\n\", external_variable);\n    return 0;\n}\n\nValue of external_variable persists:\n$ ./a.out\nIn someFunction, external variable is 1\nin main, external variable is 2"
  },
  {
    "objectID": "index.html#scope",
    "href": "index.html#scope",
    "title": "Scientific C for programmers",
    "section": "Scope",
    "text": "Scope\nThe scope of a variable or function is the part of the program where the variable of function can be used\n\nLocal variables\n\nFrom definition until end of block\nIncludes function arguments\n\nExternal variables\n\nFrom definition until end of file\nCan be used in multiple files by declaring with extern (not covered)"
  },
  {
    "objectID": "index.html#header-files-and-build-systems",
    "href": "index.html#header-files-and-build-systems",
    "title": "Scientific C for programmers",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nSo far: small programs in one .c file: easy to compile\nLarger projects: many source files\n\nOrder of compilation can matter because of dependencies\nDifficult to remember compilation commands (linking and flags)\nEditing one file does not require recompiling entirely"
  },
  {
    "objectID": "index.html#header-files-and-build-systems-1",
    "href": "index.html#header-files-and-build-systems-1",
    "title": "Scientific C for programmers",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nUse header files:\n\n.h files containing shared definitions and declarations\n#include \"example.h\" or #include &lt;stdio.h&gt;\n\nUse a build system (not covered here)\n\nMakefile (https://github.com/hpcleuven/Makefile-intro]\nCMake (https://github.com/hpcleuven/CMake-intro]\nMeson\n\n\n\n\n\n\n\n\nTip\n\n\nMost exercises can be compiled by running the make command in the exercise directory"
  },
  {
    "objectID": "index.html#static-variables",
    "href": "index.html#static-variables",
    "title": "Scientific C for programmers",
    "section": "Static variables",
    "text": "Static variables\n\nInternal variables with static declaration\n\nRemain in existing across function calls\nProvide permanent private storage within a single function\n\n\nunsigned uniqueIdentifier() {\n    // id Indicates how many times the function has been called\n    static unsigned id = 0;\n    return id++;\n}"
  },
  {
    "objectID": "index.html#static-functions",
    "href": "index.html#static-functions",
    "title": "Scientific C for programmers",
    "section": "Static functions",
    "text": "Static functions\n\nFunctions with static declaration\n\nA static function is only visible within the file where it is declared\nA normal function is visible everywhere\n\nExternal variables with static declaration\n\nCan only be used in file where they are declared"
  },
  {
    "objectID": "index.html#initialization",
    "href": "index.html#initialization",
    "title": "Scientific C for programmers",
    "section": "Initialization",
    "text": "Initialization\n\nAutomatic internal variables\n\nWithout explicit initialization (such as int x;), values are “garbage”\nInitial value can come from expression: double y = sqrt(6.0);\nRe-initialized each time the block is entered\nCompiler can warn about uninitialized variables\n\nE.g., -Wuninitialized for gcc (not perfect)"
  },
  {
    "objectID": "index.html#initialization-1",
    "href": "index.html#initialization-1",
    "title": "Scientific C for programmers",
    "section": "Initialization",
    "text": "Initialization\n\nStatic internal variables\n\nGuaranteed to initialize to zero\nInitialization first time it is encountered\nExpression or constant expression\n\nExternal variables\n\nGuaranteed to initialize to zero\nInitialized at start of execution\nConstant expression"
  },
  {
    "objectID": "index.html#recursion",
    "href": "index.html#recursion",
    "title": "Scientific C for programmers",
    "section": "Recursion",
    "text": "Recursion\nFunctions can call themselves (i.e. recursion)\nunsigned long fac(unsigned long n) {\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n*fac(n-1);\n}\n\nEach function call has overhead (pushing frame on stack)\nOften not the fastest or lowest footprint\n\nDeep recursion levels can even cause stack overflow\n\nOften closer to mathematical description\n\n\n\n\n\n\n\n\nTip\n\n\nWhen turning on compiler optimizations, recursive functions might be automatically converted to a loop, especially in case of tail recursion (where the recursive call is the last statement)."
  },
  {
    "objectID": "index.html#the-c-preprocessor",
    "href": "index.html#the-c-preprocessor",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA few statements are processed before compilation\n\n#include \"filename\" or include &lt;filename&gt;\n#define name replacement\nconditional inclusions with #if, #elif, #else, #endif\n\nIn your head, do not interpret these as C code, but imagine their impact on the code presented to compiler."
  },
  {
    "objectID": "index.html#the-c-preprocessor-1",
    "href": "index.html#the-c-preprocessor-1",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\n\n#include \"myheader.h\": includes content from myheader.h in current directory verbatim\n#include &lt;math.h&gt;: includes content from math.h in include directory verbatim\nguarantees all source files have same definitions and variable declarations"
  },
  {
    "objectID": "index.html#the-c-preprocessor-2",
    "href": "index.html#the-c-preprocessor-2",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA macro substitution replaces each occurrence of a name with a replacement, for example #define max(A, B) ((A) &gt; (B) ? (A) : (B))\n\nEvery occurence of max(x, y) will be replaced\nUse with care, can make code more readable, but also obfuscate when reading code for the first time\nMacros avoid overhead associated with function call"
  },
  {
    "objectID": "index.html#the-c-preprocessor-3",
    "href": "index.html#the-c-preprocessor-3",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nConditional inclusion gives control over preprocessor statements\n// Prevent redefinition\n#ifndef FOUR_PI\n#define FOUR_PI 4 * M_PI\n#endif\n// Use SYSTEM to decide which header is included\n#if SYSTEM == SYSV\n    #define HDR \"sysv.h\"\n#elif SYSTEM == MSDOS\n    #define HDR \"msdos.h\"\n#else\n    #define HDR \"default.h\"\n#endif"
  },
  {
    "objectID": "index.html#variadic-functions",
    "href": "index.html#variadic-functions",
    "title": "Scientific C for programmers",
    "section": "Variadic functions",
    "text": "Variadic functions\n\nC allows variable-length argument lists (variadic functions)\nThe printf function is an example we already encountered\nstdarg.h header provides utilities like va_list,va_start,va_arg,va_end\n\n\n\n\n\n\n\nTip\n\n\nUse sparingly, variadic functions are somewhat unconventional"
  },
  {
    "objectID": "index.html#variadic-functions-1",
    "href": "index.html#variadic-functions-1",
    "title": "Scientific C for programmers",
    "section": "Variadic functions",
    "text": "Variadic functions\n\nExample: add variable number of integers:\n\n#include &lt;stdarg.h&gt;\n\nint add_integers(int count, ...)\n{\n    int result = 0;\n    va_list args;\n    va_start(args, count); // count can be omitted since C23\n    for (int i = 0; i &lt; count; ++i) {\n        result += va_arg(args, int);\n    }\n    va_end(args);\n    return result;\n}"
  },
  {
    "objectID": "index.html#compute-pi-using-monte-carlo",
    "href": "index.html#compute-pi-using-monte-carlo",
    "title": "Scientific C for programmers",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo\nGoal:\n\nWrite a program that approximates \\(\\pi\\) by using a Monte Carlo algorithm\n\nLearning outcomes:\n\nWrite a loop and use control flow\n\nInstructions:\n\nThe quarter unit circle in the first quadrant has area \\(\\frac{\\pi}{4}\\). Approximate this area by generating uniformly distributed points in \\([0,1] \\times [0,1]\\) (get_random_double is provided) and selecting points inside a unit circle\nHow does the estimate converge with the number of samples?\nSee exercises/06_mc_pi."
  },
  {
    "objectID": "index.html#compute-pi-using-monte-carlo-1",
    "href": "index.html#compute-pi-using-monte-carlo-1",
    "title": "Scientific C for programmers",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo"
  },
  {
    "objectID": "index.html#compiler-optimization",
    "href": "index.html#compiler-optimization",
    "title": "Scientific C for programmers",
    "section": "Compiler optimization",
    "text": "Compiler optimization\n\nMost compilers have flags to control to which extent executable is optimized\nExamples of optimizations\n\nFunction inlining\nEliminating common subexpressions\nVectorization\nStatements of source code are reordered\nLoop reordering"
  },
  {
    "objectID": "index.html#gcc-optimization-levels",
    "href": "index.html#gcc-optimization-levels",
    "title": "Scientific C for programmers",
    "section": "GCC optimization levels",
    "text": "GCC optimization levels\n\n-O0:\n\nNo optimization, machine code stays close to source code\nFast compilation, but slow at runtime\nGood for debugging, never use for production runs!\n\n-O2 or -O3:\n\nOptimize, but comply with standards\nSlower compilation, but fast at runtime\nUsually the best option for production runs\n\n-Ofast:\n\nOptimize and possibly ignore standards compliance\nIn principle the fastest execution\nNever use without checking results!"
  },
  {
    "objectID": "index.html#monte-carlo-pi-timings",
    "href": "index.html#monte-carlo-pi-timings",
    "title": "Scientific C for programmers",
    "section": "Monte Carlo \\(\\pi\\) timings",
    "text": "Monte Carlo \\(\\pi\\) timings\n\nCompilation without optimizations:\n$ gcc -O0 -o mc_pi mc_pi.c && ./mc_pi\nWalltime =    2.490s,      4.0e+07 iterations/s\nNsamples = 100000000 Estimated pi =   3.14169792 Error =   1.0527e-04\nCompilation with optimizations:\n$ gcc -O2 -o mc_pi mc_pi.c && ./mc_pi\nWalltime =    1.768s,      5.7e+07 iterations/s\nNsamples = 100000000 Estimated pi =   3.14169792 Error =   1.0527e-04\nMain optimization in this case is probably inlining get_random_double"
  },
  {
    "objectID": "index.html#fibonacci",
    "href": "index.html#fibonacci",
    "title": "Scientific C for programmers",
    "section": "Fibonacci",
    "text": "Fibonacci\nGoal:\n\nWrite a program to compute the Fibonacci sequence\n\nLearning outcome:\n\nWrite (recursive) functions\n\nInstructions:\n\nThe Fibonacci sequence is defined by \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) and \\(F_0=0, F_1=1\\)\nCompute the nth element by using a recursive function\nTry to trigger a stack overflow for large n\nWrite a function without recursion\nSee exercises/07_recursion"
  },
  {
    "objectID": "index.html#outline-3",
    "href": "index.html#outline-3",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#pointers-and-arrays-1",
    "href": "index.html#pointers-and-arrays-1",
    "title": "Scientific C for programmers",
    "section": "Pointers and arrays 1 2",
    "text": "Pointers and arrays 1 2\n\nC arrays store multiple values of the same type in a single variable\nC pointers contain a memory address of a variable\nPointers and arrays are closely related in C\n\nKernighan and Ritchie, Chapter 5, Pointers and arraysAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#memory-management",
    "href": "index.html#memory-management",
    "title": "Scientific C for programmers",
    "section": "Memory management",
    "text": "Memory management\n\nMemory is one of the fundamental building blocks of current computer architectures (see von Neumann model)\nIn many programming languages, memory management is transparent to programmer\n\nA variable is stored somewhere in memory, but the programmer does not know where\nVariables are referenced symbolically by programmer, program figures out memory location\n\nC does allow managing memory yourself, so it needs a concept to allow working with memory addresses"
  },
  {
    "objectID": "index.html#pointer-basics",
    "href": "index.html#pointer-basics",
    "title": "Scientific C for programmers",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the memory location (address) of another variable\nThe & operator gives the memory address of a variable\nThe * operator gives the value of the variable a pointer points to (dereferencing)\nThere are different types of pointers, depending on which type they point to\nDeclarations like int *px indicate that px is a pointer and *px is an int"
  },
  {
    "objectID": "index.html#virtual-memory-layout",
    "href": "index.html#virtual-memory-layout",
    "title": "Scientific C for programmers",
    "section": "Virtual memory layout",
    "text": "Virtual memory layout\n\n\n\nI represent virtual memory as a table with three columns\n\nAddress column in hexadecimal format\nValue column in decimal format\nVariable column makes it easier to read, not present in actual implementation\nRemember that internally it’s all binary\nSome variables take up more than one address\n\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nint x\n0x0000\n42\n\n\nint y\n0x0004\n43\n\n\ndouble a\n0x0008\n12.6e10\n\n\ndouble a\n0x000c\n\n\n\nfloat b\n0x0010\n3.14"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach",
    "href": "index.html#swapping-variables-naive-approach",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach-1",
    "href": "index.html#swapping-variables-naive-approach-1",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach-2",
    "href": "index.html#swapping-variables-naive-approach-2",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach-3",
    "href": "index.html#swapping-variables-naive-approach-3",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach-4",
    "href": "index.html#swapping-variables-naive-approach-4",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n5\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach-5",
    "href": "index.html#swapping-variables-naive-approach-5",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nOutput:\nx = 5, y = 10\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "index.html#working-with-large-arrays",
    "href": "index.html#working-with-large-arrays",
    "title": "Scientific C for programmers",
    "section": "Working with large arrays",
    "text": "Working with large arrays\n\nSuppose you construct vectors using a struct (see later)\nYou want a function double innerProduct(struct vector v1, struct vector v2) that computes the inner product\nSince C uses pass-by-value, those objects would be copied when function is called\nMemory access is slow, this would give bad performance for large cases\n\n=&gt; This is also addressed by pointers"
  },
  {
    "objectID": "index.html#pointer-basics-1",
    "href": "index.html#pointer-basics-1",
    "title": "Scientific C for programmers",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the address of a variable\nPointer arguments allow modifying object in the called function\nThere are different pointer types, depending on the variable they point to, for example, int *px; or double *pa;\n\n\n\n\n\n\n\nTip\n\n\nMnemonic: read int *px as “*px is of type int”. Sometimes people also use int* px to declare an integer pointer."
  },
  {
    "objectID": "index.html#pointer-basics-2",
    "href": "index.html#pointer-basics-2",
    "title": "Scientific C for programmers",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nThe & operator gives the address of a variable\nThe * operator dereferences a pointer, i.e., gives the value of the variable that is pointed to\n\nint x = 1, y;\nint *px;\n\npx = &x; // px now points to x, i.e. it holds the address of x\ny = *px; // y now holds the value of the object px points to, i.e. y = 1\n*px = 10; // the value of the object px points to is set, i.e. x = 10"
  },
  {
    "objectID": "index.html#swapping-variables-pointers",
    "href": "index.html#swapping-variables-pointers",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "index.html#swapping-variables-pointers-1",
    "href": "index.html#swapping-variables-pointers-1",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104"
  },
  {
    "objectID": "index.html#swapping-variables-pointers-2",
    "href": "index.html#swapping-variables-pointers-2",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-pointers-3",
    "href": "index.html#swapping-variables-pointers-3",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-pointers-4",
    "href": "index.html#swapping-variables-pointers-4",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#swapping-variables-pointers-5",
    "href": "index.html#swapping-variables-pointers-5",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nOutput:\nx = 10, y = 5\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n10\n\n\ny\n0x104\n5"
  },
  {
    "objectID": "index.html#arrays",
    "href": "index.html#arrays",
    "title": "Scientific C for programmers",
    "section": "Arrays",
    "text": "Arrays\n\nAn array is a block of consecutive objects of a specified type\n\nint a[10]; declares 10 consecutive int objects\nThe i-th element can be accessed as a[i]\n\nPointers are a natural way to loop over arrays\n\nint a[10];\nint *pa;\npa = &a[0]; // pa points to first element of a\npa++; // pa now points to second element of a\n\n\n\n\n\n\nWarning\n\n\nWhen pointing to array elements, incrementing a pointer always means going to the next object irrespective of the object type!"
  },
  {
    "objectID": "index.html#array-indexing-sourcery",
    "href": "index.html#array-indexing-sourcery",
    "title": "Scientific C for programmers",
    "section": "Array indexing sourcery",
    "text": "Array indexing sourcery\n\nIn C, the name of an array is a synonym for the memory address of the initial element\n\nint *pa = &a[0] is identical to int *pa = a\n\nAccess to the i-th element a[i] is translated to *(a+i)\nBecause integer addition is commutative, a[i] is identical to i[a]!"
  },
  {
    "objectID": "index.html#arrays-as-function-arguments",
    "href": "index.html#arrays-as-function-arguments",
    "title": "Scientific C for programmers",
    "section": "Arrays as function arguments",
    "text": "Arrays as function arguments\n\nWhen passing an array to a function, the location of the initial element is passed\nWithin the called function, the corresponding local variable is a pointer\nYou can pass a part of an array to a function\n\nf(&a[2]) passes the subarray that starts at a[2]\n\n\n\n\n\n\n\n\nWarning\n\n\nYou cannot pass a slice of an array, the called function is responsible to respect the bounds of the array. This is one of the reasons why C programs are often considered at risk for unsafe memory management."
  },
  {
    "objectID": "index.html#array-decay",
    "href": "index.html#array-decay",
    "title": "Scientific C for programmers",
    "section": "Array decay",
    "text": "Array decay\n\nWhen passed to a function, an array decays into a pointer to its first element\nsizeof(arr) inside function gives size of pointer, not array\nArray length information is lost\n\n#include &lt;stdio.h&gt;\n\nvoid foo(int arr[]) {\n    printf(\"sizeof(arr) = %zu\\n\", sizeof(arr)); // prints size of pointer\n}\n\nint main() {\n    int arr[10];\n    printf(\"sizeof(arr) = %zu\\n\", sizeof(arr)); // prints size of array\n    foo(arr);\n}\nOutput:\nsizeof(arr) = 40\nsizeof(arr) = 8"
  },
  {
    "objectID": "index.html#character-pointers",
    "href": "index.html#character-pointers",
    "title": "Scientific C for programmers",
    "section": "Character pointers",
    "text": "Character pointers\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "index.html#dynamic-memory-allocation",
    "href": "index.html#dynamic-memory-allocation",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nThe C89 standard does not allow variable length arrays\n\nArray size must be known at compile time\nsize_t len = 5; int a[len]; is strictly speaking invalid\nSince C99 it is supported and many compilers allow it by default\n\nEven if you can have VLAs, there are some downsides\n\nAllocated on stack, so limited in size\nScope is local, similar as other variables\nVLA might be less efficient\n\n\n\n\n\n\n\n\nTip\n\n\nVariable length refers to the fact that length is only known at runtime, a variable length array remains of the same size during its lifetime."
  },
  {
    "objectID": "index.html#dynamic-memory-allocation-1",
    "href": "index.html#dynamic-memory-allocation-1",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nMemory for arrays can be dynamically allocated on the heap\n\nHeap is a large area of memory used at runtime\nSignature: void *malloc(size_t size);\nsize is in bytes: make use of sizeof\nreturns void pointer, cast it to correct pointer type\nif memory cannot be allocated, null pointer is returned\nalways free() the memory exactly once!\ncalloc: includes initializing to zero (so slower than malloc)"
  },
  {
    "objectID": "index.html#dynamic-memory-allocation-2",
    "href": "index.html#dynamic-memory-allocation-2",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n    size_t len = atoi(argv[1]);\n    double *pa = (double *) malloc(len * sizeof(double));\n    if (pa == NULL) { return 1;}\n    free(pa);\n    return 0;\n}"
  },
  {
    "objectID": "index.html#multidimensional-arrays",
    "href": "index.html#multidimensional-arrays",
    "title": "Scientific C for programmers",
    "section": "Multidimensional arrays",
    "text": "Multidimensional arrays\n\nC supports multidimensional arrays by using multiple []\n\nint matrix[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n\nIndexing is done with [i][j] (not [i,j])\n\nint x = matrix[1][2]\n\nC uses row-major storage: last dimension is fastest in memory"
  },
  {
    "objectID": "index.html#pointers-to-pointers",
    "href": "index.html#pointers-to-pointers",
    "title": "Scientific C for programmers",
    "section": "Pointers to pointers",
    "text": "Pointers to pointers\n\nA pointer is also a variable -&gt; another pointer can point to its address\nIn contrast to multidimensional arrays, we can now have irregular structures\nExample: storing an upper triangular matrix\n\ndouble **lower;\nlower = (double **)malloc( n * sizeof(double *))\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}\nfree(lower);"
  },
  {
    "objectID": "index.html#arrays-of-pointers",
    "href": "index.html#arrays-of-pointers",
    "title": "Scientific C for programmers",
    "section": "Arrays of pointers",
    "text": "Arrays of pointers\n\nBy now it should be clear pointers and arrays are very similar\nThe previous example as an array of pointers:\n\ndouble *lower[n];\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}"
  },
  {
    "objectID": "index.html#pointers-to-functions",
    "href": "index.html#pointers-to-functions",
    "title": "Scientific C for programmers",
    "section": "Pointers to functions",
    "text": "Pointers to functions\n\nExample\n\nWhen \\(a\\) and \\(b\\) are close, the integral \\(\\int_a^{b} f(x) dx \\approx \\frac{1}{2} \\frac{f(a) + f(b)}{b-a}\\)\nThis rule can be written for any \\(f(x)\\) as:\n\n\ndouble trapezoidRule (double (*f)(double), double a, double b) {\n    return (b-a)*(f(a) + f(b))/2;\n}\ndouble trap = trapezoidRule(cos, 0, M_PI);"
  },
  {
    "objectID": "index.html#quadrature",
    "href": "index.html#quadrature",
    "title": "Scientific C for programmers",
    "section": "Quadrature",
    "text": "Quadrature\nGoal:\n\nWrite a program that can numerically integrate arbitrary functions\n\nLearning outcome:\n\nUse pointers to let functions operate on arrays and functions\n\nInstructions:\n\nWrite a function that allocates an array, with evenly spaced real numbers in a chosen interval as entries\nWrite a function that approximates the integral of sin and cos^2 on the chosen interval\nSee exercises/08_quadrature"
  },
  {
    "objectID": "index.html#heat-equation",
    "href": "index.html#heat-equation",
    "title": "Scientific C for programmers",
    "section": "Heat equation",
    "text": "Heat equation\nGoal:\n\nWrite a program that solves the 2D heat equation\n\nLearning outcome:\n\nLearn to work with multi-dimensional arrays\n\nInstructions:\n\nSee exercises/09_heat_equation"
  },
  {
    "objectID": "index.html#heat-equation-memory-leak",
    "href": "index.html#heat-equation-memory-leak",
    "title": "Scientific C for programmers",
    "section": "Heat equation memory leak",
    "text": "Heat equation memory leak\n\nThe provided code allocated memory at each iteration without ever freeing it\nThis is a memory leak: for larger grids and/or more steps, you would run out of memory\nMake sure to always free memory you allocated with malloc/calloc\nIn this case the allocation only has to be done once (outside of the loop)"
  },
  {
    "objectID": "index.html#structures-1",
    "href": "index.html#structures-1",
    "title": "Scientific C for programmers",
    "section": "Structures 1 2",
    "text": "Structures 1 2\n\nA structure is a collection of one or more variables, possibly of different types\nMakes it convenient to organize and handle complicated data\nA very lightweight class (but do not call C object-oriented):\n\nNo inheritance\nNo class methods\n\n\nKernighan and Ritchie, Chapter 6, StructuresAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#structure-example",
    "href": "index.html#structure-example",
    "title": "Scientific C for programmers",
    "section": "Structure example",
    "text": "Structure example\n\nA structure is defined with struct, usually followed by a tag as a name\n\nstruct particle {\n    double x;\n    double y;\n    double z;\n    double mass;\n    char symbol;\n}\n\nThe variables named in the struct are members and can be accessed with the . operator"
  },
  {
    "objectID": "index.html#structure-example-1",
    "href": "index.html#structure-example-1",
    "title": "Scientific C for programmers",
    "section": "Structure example",
    "text": "Structure example\n\nA struct can be initialized directly or member-by-member\n\nstruct particle p1;\np1.x = 1.0;\np1.y = 2.0;\np1.z = 3.0;\np1.mass = 1.000784;\np1.symbol = 'H';\nstruct particle p2 = {2.0, 4.0, 5.0, 12.011, 'C'};\n\n\n\n\n\n\n\nTip\n\n\nInitializing member-by-member is a bit more robust when the struct definition changes"
  },
  {
    "objectID": "index.html#structures-and-functions",
    "href": "index.html#structures-and-functions",
    "title": "Scientific C for programmers",
    "section": "Structures and functions",
    "text": "Structures and functions\n\nFunctions can operate on structures much the same way as basic types\n\nstruct particle centerOfMass(struct particle p1, struct particle p2) {\n    double mass = p1.m + p2.m;\n    struct particle com;\n    com.x = (p1.x * p1.m + p2.x * p2.m) / mass;\n    com.y = (p1.y * p1.m + p2.y * p2.m) / mass;\n    com.z = (p1.z * p1.m + p2.z * p2.m) / mass;\n    com.mass = mass\n    return com;\n}"
  },
  {
    "objectID": "index.html#arrays-of-structures",
    "href": "index.html#arrays-of-structures",
    "title": "Scientific C for programmers",
    "section": "Arrays of structures",
    "text": "Arrays of structures\n\nArrays can be made up of structs\n\n// Make an array with n particles\nstruct particle particles[n];\n\n\nDefined in this way, accessing all x coordinates would give strided memory access\n\nHaving a struct with arrays can be more efficient than an array of structs\nDepends on the specific application"
  },
  {
    "objectID": "index.html#structures-and-pointers",
    "href": "index.html#structures-and-pointers",
    "title": "Scientific C for programmers",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nStructures are variables, so you can point to their address\n\nvoid translateX(struct particle *p, double distance) {\n    (*p).x += distance;\n}\n\n\nA member of a pointer can be accessed with -&gt;\n\nIf p is a pointer to a struct particle, (*p).x is the same as p-&gt;x\n\n\nvoid translateX(struct particle *p, double distance) {\n    p-&gt;x += distance;\n}"
  },
  {
    "objectID": "index.html#structures-and-pointers-1",
    "href": "index.html#structures-and-pointers-1",
    "title": "Scientific C for programmers",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nThe . and -&gt; operators have highest precedence:\n\n*p.x would be interpreted as *(p.x) (unwanted in our example)\nuse brackets to make your intention clear"
  },
  {
    "objectID": "index.html#common-data-structures",
    "href": "index.html#common-data-structures",
    "title": "Scientific C for programmers",
    "section": "Common data structures",
    "text": "Common data structures\n\nMultidimensional arrays\n\nRegular and fixed structure, only members of a single type\n\nLinked lists\n\nAllow dynamic lengths and make insertion easy\n\nTrees\n\nRepresent hierarchical data\n\nGraph\n\nMore general than trees, allow more complicated topologies"
  },
  {
    "objectID": "index.html#typedef",
    "href": "index.html#typedef",
    "title": "Scientific C for programmers",
    "section": "Typedef",
    "text": "Typedef\nThe typedef keyword creates an alias for an existing data type\n\nTo abbreviate a long type name:\ntypedef unsigned long int ULINT;\nULINT i; // Equivalent to unsigned long int i;\nTo facilitate switching between precisions or improve portability:\n#ifdef REDUCED_PRECISION\ntypedef float MYFLOAT;\n#else\ntypedef double MYFLOAT;\n#endif\nTo have a type name closer to its semantical meaning\ntypedef struct Item * Item;\ntypedef struct Item * List;\n[look up linked-list implementation to better understand this one]"
  },
  {
    "objectID": "index.html#unions",
    "href": "index.html#unions",
    "title": "Scientific C for programmers",
    "section": "Unions",
    "text": "Unions\n\nA union can hold objects of different types, but only one at a time\n\nOnly the last assigned member is guaranteed to hold a valid value\n\nSimilar to a struct, but in a union, members share the same memory\nCan be used to have some pseudo-polymorphism in C\nunion MyUnion {int myInt; double myDouble;};\nunion MyUnion u;\nu.myInt = 1;\nu.myDouble = 2.0; // From here, u.myInt has invalid value\nSometimes used to make low-level access easier, for instance interpret a 4-byte int as 4 1-byte chars\ntypedef union\n{\n  struct {\n      unsigned char byte1, byte2, byte3, byte4;\n  } bytes;\n  unsigned int dword;\n} HW_Register;"
  },
  {
    "objectID": "index.html#size-of-structure",
    "href": "index.html#size-of-structure",
    "title": "Scientific C for programmers",
    "section": "Size of structure",
    "text": "Size of structure\nGoal:\n\nWrite a program centered around a Person structure\n\nLearning outcomes:\n\nDefine a structure and functions operating on it\nThink about memory alignment\n\nInstructions:\n\nCreate a Person structure with members height, weight, year of birth, and first letter of name\nCheck the size of the structure in memory and explain the result\nWrite a function that computes the total weight of a group of persons [hint: see variadic functions]\nSee exercises/10_struct_basics"
  },
  {
    "objectID": "index.html#dna-sequencing",
    "href": "index.html#dna-sequencing",
    "title": "Scientific C for programmers",
    "section": "DNA sequencing",
    "text": "DNA sequencing\nGoal:\n\nWrite a program to detect motifs in a DNA sequence associated with an increased risk of a hypothetical disease\n\nLearning Outcomes:\n\nDefine and use structs for organizing biological data\nWork with arrays of structs\nImplement string search algorithms in C"
  },
  {
    "objectID": "index.html#dna-sequencing-1",
    "href": "index.html#dna-sequencing-1",
    "title": "Scientific C for programmers",
    "section": "DNA sequencing",
    "text": "DNA sequencing\n\nConsider the following hypothetical DNA sequences:\n\n\n\nID\nName\nSequence\n\n\n\n\nseq1\nAlice\nATCGGGTAATCG\n\n\nseq2\nBob\nGGTAATCGGGTA\n\n\nseq3\nCarol\nATCGATCGGGTA\n\n\nseq4\nDave\nGGGGATCGATCG\n\n\nseq5\nEve\nATCGGGGGGGTA\n\n\n\nImagine that the number of times one of the following motifs is present, increases the risk to carry a certain disease:\n\n\n\nMotif\nDisease\n\n\n\n\nATCG\nDisease1\n\n\nGGTA\nDisease2"
  },
  {
    "objectID": "index.html#dna-sequencing-2",
    "href": "index.html#dna-sequencing-2",
    "title": "Scientific C for programmers",
    "section": "DNA sequencing",
    "text": "DNA sequencing\n\nConstruct structs to represent DNA sequences and motifs\nCompute for each sequence and for each disease the risk factor\n\nSee exercises/11_dna_sequencing"
  },
  {
    "objectID": "index.html#input-and-output-1",
    "href": "index.html#input-and-output-1",
    "title": "Scientific C for programmers",
    "section": "Input and output 1 2",
    "text": "Input and output 1 2\n\nInput/output is not part of C, but of standard library =&gt; need for #include &lt;stdio.h&gt;\nConverting input/output can be tedious (use AI assistant?)\nMake use of dedicated libraries/formats such as HDF5, NetCDF, Zarr\nAnnotate data with metadata (units, meaning, etc…)\nLimited coverage in this course, see K&R Appendix B\n\nKernighan and Ritchie, Chapter 7, Input and OutputAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#writing-to-standard-out-stdout",
    "href": "index.html#writing-to-standard-out-stdout",
    "title": "Scientific C for programmers",
    "section": "Writing to standard out (stdout)",
    "text": "Writing to standard out (stdout)\nprintf allows to print internal values as characters in terminal\n// int with minimal width 5\nprintf(\"a = %5d\\n\", a); // a =    10\n// int with minimal width 5 and zero padding\nprintf(\"a = %05d\\n\", a); // a = 00010\n// double with 8 digits after comma\nprintf(\"pi = %.8f\\n\", M_PI); // pi = 3.14159265\n// double in exponential notation\nprintf(\"pi = %8.2e\\n\", M_PI); // pi = 3.14e+00\n// fixed-width string\nprintf(\"%.10s\\n\", \"Hello, world\"); // Hello, wor"
  },
  {
    "objectID": "index.html#reading-from-standard-in-stdin",
    "href": "index.html#reading-from-standard-in-stdin",
    "title": "Scientific C for programmers",
    "section": "Reading from standard in (stdin)",
    "text": "Reading from standard in (stdin)\nint day;\nchar month[20];\nprintf(\"Enter data in format '01 January'\\n\");\nscanf(\"%d %s\", &day, month); // Make sure to check values!\nscanf:\n\nreturns number of matched items\nstops when format string is exhausted or input fails to match specification\n\n\n\n\n\n\n\nTip\n\n\nTo run non-interactively, you can redirect file contents to stdin on Linux with ./a.out &lt;inputfile"
  },
  {
    "objectID": "index.html#command-line-arguments",
    "href": "index.html#command-line-arguments",
    "title": "Scientific C for programmers",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n\nCommand-line arguments are passed to main\nFirst argument: number of command-line arguments + 1 (typically argc)\nSecond argument: pointer to array of character strings (typically argv)\n\nFirst array element (at index 0) has name of program"
  },
  {
    "objectID": "index.html#command-line-arguments-1",
    "href": "index.html#command-line-arguments-1",
    "title": "Scientific C for programmers",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"There are %d command-line arguments\\n\", argc);\n    printf(\"The program is called %s\\n\", argv[0]);\n    for (int i = 1; i &lt; argc; i++)\n        printf(\"Command-line argument %d is %s\\n\", i, argv[i]);\n    return 0;\n}\n$ ./a.out Hello World\nThere are 3 command-line arguments\nThe program is called ./a.out\nCommand-line argument 1 is Hello\nCommand-line argument 2 is World"
  },
  {
    "objectID": "index.html#file-access",
    "href": "index.html#file-access",
    "title": "Scientific C for programmers",
    "section": "File access",
    "text": "File access\n\nFiles are accessed using a FILE structure defined in stdio.h:\n\nFILE *fp; fp = fopen(name, mode);\n\nmode can be read r, append a, or write w\nMake sure to check if fopen was succesful by comparing with NULL pointer\nMake sure to close file again with fclose(fp);"
  },
  {
    "objectID": "index.html#file-access-example",
    "href": "index.html#file-access-example",
    "title": "Scientific C for programmers",
    "section": "File access example",
    "text": "File access example\n    FILE *values = fopen(\"values.txt\", \"r\");\n    if (values == NULL) {\n        printf(\"Failed to open values.txt\\n\");\n        return 1;\n    }\n    char line[256];\n    while (fgets(line, sizeof(line), values)) {\n        double value;\n        if (sscanf(line, \"%lf\", &value) == 1) {\n            printf(\"Read value %f\\n\", value);\n        }\n    }\n    fclose(values);\n$ cat values.txt\n42\n3.14\n981.12\n$ ./a.out\nRead value 42.000000\nRead value 3.140000\nRead value 981.120000"
  },
  {
    "objectID": "index.html#exercise-regression",
    "href": "index.html#exercise-regression",
    "title": "Scientific C for programmers",
    "section": "Exercise: regression",
    "text": "Exercise: regression\nGoal:\n\nWrite a program that reads temperature anomalies and predicts future values using simple linear regression\n\nLearning outcomes:\n\nLearn how to read numbers from a structured input file and process them\n\nInstructions:\n\nSee exercises/12_regression"
  },
  {
    "objectID": "index.html#outline-4",
    "href": "index.html#outline-4",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#external-libraries-1",
    "href": "index.html#external-libraries-1",
    "title": "Scientific C for programmers",
    "section": "External libraries",
    "text": "External libraries\n\nThere are literally hundreds of potentially useful scientific libraries\nThe ones discussed here are by no means exhaustive or representative for your case\nThe intention is to get a feel for how you can proceed to use libraries in general"
  },
  {
    "objectID": "index.html#external-libraries-overview",
    "href": "index.html#external-libraries-overview",
    "title": "Scientific C for programmers",
    "section": "External libraries overview",
    "text": "External libraries overview\n\n\nExternal libraries extend C’s capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting)\n\n\n\n\nCommon scientific libraries:\n\nGSL (GNU Scientific Library)\nBLAS/LAPACK (Linear Algebra)\nFFTW (Fast Fourier Transforms)\nHDF5 (Hierarchical data format)\n\n\n\n\n\nBenefits:\n\nAvoid reinventing the wheel\nLeverage optimized, tested code\nImprove performance and portability"
  },
  {
    "objectID": "index.html#using-external-libraries",
    "href": "index.html#using-external-libraries",
    "title": "Scientific C for programmers",
    "section": "Using external libraries",
    "text": "Using external libraries\n\nBefore you can include calls to external libraries in your code, you typically need to include relevant header files\n\nHeader files define signatures of functions, structs, constants\n\nTo compile code relying on an external library into an executable, you need to link that library\n\nTypically -l&lt;libname&gt;, check library documentation"
  },
  {
    "objectID": "index.html#static-vs-dynamic-libraries",
    "href": "index.html#static-vs-dynamic-libraries",
    "title": "Scientific C for programmers",
    "section": "Static vs Dynamic Libraries",
    "text": "Static vs Dynamic Libraries\n\n\n\n\n\n\n\n\nFeature\nStatic Library (.a/.lib)\nDynamic Library (.so/.dll)\n\n\n\n\nLinking time\nCompile time\nRuntime\n\n\nBinary size\nLarger (library included)\nSmaller (library separate)\n\n\nPortability\nEasier to distribute\nRequires library on target system\n\n\nUpdates\nRecompile to update\nCan update without recompiling\n\n\nPerformance\nSlightly faster (no indirection)\nMay have overhead at runtime\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nUse gcc -static for static linking, or -l&lt;libname&gt; with -L&lt;path&gt; for dynamic linking\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nDetails differ from library to library: check the specific documentation"
  },
  {
    "objectID": "index.html#gnu-scientific-library",
    "href": "index.html#gnu-scientific-library",
    "title": "Scientific C for programmers",
    "section": "GNU Scientific Library",
    "text": "GNU Scientific Library\n\nThe GNU Scientific Library (GSL) provides a wide range of mathematical routines\nHow to get it:\n\nOn the cluster: load it as a module, module load GSL/2.8-GCC-13.3.0 for example\nOn your machine: install it as a system package, apt-get install libgsl-dev for example\n\nHow to use it:\n\nInclude the relevant headers in your code\nFind relevant link flags with pkg-config --libs gsl for example\n\n\n\n\n\n\n\n\n\nTip\n\n\nBy loading a module on the cluster, some variables are set to make it easier to use libraries. For instance CPATH will include the path of the header files, LD_LIBRARY_PATH will include the path of the libraries."
  },
  {
    "objectID": "index.html#minimizing-a-function-with-gsl",
    "href": "index.html#minimizing-a-function-with-gsl",
    "title": "Scientific C for programmers",
    "section": "Minimizing a function with GSL",
    "text": "Minimizing a function with GSL\nSee https://www.gnu.org/software/gsl/doc/html/min.html for documentation about one dimensional minimization\n#include &lt;stdio.h&gt;\n#include &lt;gsl/gsl_errno.h&gt;\n#include &lt;gsl/gsl_min.h&gt;\n#include &lt;gsl/gsl_math.h&gt;\n\ntypedef struct {\n    double a, b, sigma;\n} Params;\n\n// Define a function f according to the GSL rules\ndouble f(double x, void *params) {\n    Params *p = (Params *) params;\n    return exp(-p-&gt;sigma*x*x)*sin(p-&gt;a + p-&gt;b*x);\n}"
  },
  {
    "objectID": "index.html#minimizing-a-function-with-gsl-1",
    "href": "index.html#minimizing-a-function-with-gsl-1",
    "title": "Scientific C for programmers",
    "section": "Minimizing a function with GSL",
    "text": "Minimizing a function with GSL\nint main() {\n    Params params = {0.3, 1.0, 0.05};\n\n    double minimum = -2.5, lower = -3.0, upper = 0.0;\n    int iter = 0, maxIter = 100, status;\n\n    const gsl_min_fminimizer_type *T = gsl_min_fminimizer_brent;\n    gsl_min_fminimizer *minimizer = gsl_min_fminimizer_alloc(T);\n    gsl_function F;\n    F.function = &f;\n    F.params = (void *) &params;\n\n    gsl_min_fminimizer_set(minimizer, &F, minimum, lower, upper);\n\n    do {\n        gsl_min_fminimizer_iterate(minimizer);\n        lower = gsl_min_fminimizer_x_lower(minimizer);\n        upper = gsl_min_fminimizer_x_upper(minimizer);\n        status = gsl_min_test_interval(lower, upper, 1.0e-6, 0.0);\n    } while (status == GSL_CONTINUE && ++iter &lt; maxIter);\n\n    if (status == GSL_SUCCESS) {\n        minimum = gsl_min_fminimizer_x_minimum(minimizer);\n        printf(\"f reached the minimum %.6f at %.6f after %d iterations\\n\", f(minimum, F.params), minimum, iter);\n    }\n\n    gsl_min_fminimizer_free(minimizer);\n    return 0;\n}"
  },
  {
    "objectID": "index.html#blas-basic-linear-algebra-subprograms",
    "href": "index.html#blas-basic-linear-algebra-subprograms",
    "title": "Scientific C for programmers",
    "section": "BLAS: Basic Linear Algebra Subprograms",
    "text": "BLAS: Basic Linear Algebra Subprograms\n\nLow-level routines for vector and matrix operations\nLevels:\n\nLevel 1: Vector-vector (e.g., dot product)\nLevel 2: Matrix-vector (e.g., solving triangular systems)\nLevel 3: Matrix-matrix (e.g., matrix multiplication)"
  },
  {
    "objectID": "index.html#lapack-linear-algebra-package",
    "href": "index.html#lapack-linear-algebra-package",
    "title": "Scientific C for programmers",
    "section": "LAPACK: Linear Algebra PACKage",
    "text": "LAPACK: Linear Algebra PACKage\n\nBuilt on top of BLAS\nHigh-level routines for:\n\nSolving linear systems\nEigenvalue problems\nSingular value decomposition"
  },
  {
    "objectID": "index.html#blas-lapack",
    "href": "index.html#blas-lapack",
    "title": "Scientific C for programmers",
    "section": "BLAS & LAPACK",
    "text": "BLAS & LAPACK\n\n\nWhy use them?\n\nHighly optimized for performance\nPortable across platforms\nWidely used in scientific and engineering applications\n\n\n\n\n\nMany implementations are available\n\nOpenBLAS - Intel MKL - ATLAS\n\n\n\n\n\nOften implemented (partially) in Fortran and assembly\n\nC bindings nearly always available though\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nLink typically happens with -lblas -llapack, but this can be different for optimized implementations like OpenBLAS, Intel MKL, or ATLAS."
  },
  {
    "objectID": "index.html#dot-product-in-blas",
    "href": "index.html#dot-product-in-blas",
    "title": "Scientific C for programmers",
    "section": "Dot product in BLAS",
    "text": "Dot product in BLAS\n#include &lt;stdio.h&gt;\n#include &lt;cblas.h&gt;\n\nint main() {\n    double x[3] = {1.0, 2.0, 3.0};\n    double y[3] = {4.0, 5.0, 6.0};\n    double result = cblas_ddot(3, x, 1, y, 1);\n    printf(\"Dot product: %f\\n\", result);\n    return 0;\n}\n$ gcc dotproduct.c -o dotproduct -lblas && ./dotproduct\nDot product: 32.000000\n\n\n\n\n\n\n\nTip\n\n\nOn the cluster, use module load OpenBLAS/0.3.27-GCC-13.3.0 and link with -lopenblas"
  },
  {
    "objectID": "index.html#hdf5-managing-scientific-data-in-c",
    "href": "index.html#hdf5-managing-scientific-data-in-c",
    "title": "Scientific C for programmers",
    "section": "HDF5: Managing Scientific Data in C",
    "text": "HDF5: Managing Scientific Data in C\n\nHDF5 (Hierarchical Data Format v5)\n\nDesigned for storing and organizing large, complex datasets\nSupports n-dimensional arrays, tables, images, and metadata\nCommon in physics, climate modeling, bioinformatics, and engineering\n\nFeatures\n\nPortable and self-describing binary format\nHierarchical structure: groups and datasets (like folders and files)\nSupports compression, parallel I/O, and chunking"
  },
  {
    "objectID": "index.html#hdf5-schematic-view-of-an-hdf5-file",
    "href": "index.html#hdf5-schematic-view-of-an-hdf5-file",
    "title": "Scientific C for programmers",
    "section": "HDF5: schematic view of an HDF5 file",
    "text": "HDF5: schematic view of an HDF5 file"
  },
  {
    "objectID": "index.html#hdf5-writing-a-dataset",
    "href": "index.html#hdf5-writing-a-dataset",
    "title": "Scientific C for programmers",
    "section": "HDF5: writing a dataset",
    "text": "HDF5: writing a dataset\n#include \"hdf5.h\"\n\nint main() {\n    hid_t file_id, dataset_id, dataspace_id;\n    hsize_t dims[2] = {4, 6};\n    double data[4][6] = { /* initialize with values */ };\n\n    file_id = H5Fcreate(\"example.h5\", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    dataspace_id = H5Screate_simple(2, dims, NULL);\n    dataset_id = H5Dcreate(file_id, \"/mydata\", H5T_NATIVE_DOUBLE, dataspace_id,\n                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);\n    H5Dclose(dataset_id);\n    H5Sclose(dataspace_id);\n    H5Fclose(file_id);\n    return 0;\n}"
  },
  {
    "objectID": "index.html#solve-a-linear-system-of-equations-with-gsl",
    "href": "index.html#solve-a-linear-system-of-equations-with-gsl",
    "title": "Scientific C for programmers",
    "section": "Solve a linear system of equations with GSL",
    "text": "Solve a linear system of equations with GSL\nGoal:\n\nWrite a program that balances a chemical equation by solving a linear system of equations using GSL.\n\nLearning outcomes:\n\nLearn how to call functions in GSL.\n\nInstructions:\n\nConsider the chemical equation \\(a C_3H_8 + b O_2 \\leftrightarrow c CO_2 + d H_2O\\). Write a program that determines values for a,b,c,d such that the equation is balanced (i.e., each element appears as often on the left hand side as on the right hand side). Make use of GSL linear algebra functions to do this.\nBonus: Find a way to make sure the coefficients are integer"
  },
  {
    "objectID": "index.html#handwriting-recognition",
    "href": "index.html#handwriting-recognition",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nGoal:\n\nTrain a model that can recognize handwritten digits\n\nLearning outcomes:\n\nLearn how to read “production” C code without understanding all details\nWork with HDF5 and BLAS libraries\n\n\n\n\n\n\n\n\nTip\n\n\nIt is not necessary or even wanted to fully understand the mathematics of the model. The following slides contain the essential things you need to know."
  },
  {
    "objectID": "index.html#handwriting-recognition-1",
    "href": "index.html#handwriting-recognition-1",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nSupervised machine learning models:\n\nPropose a model \\(y = f(x; A)\\) that relates the input \\(x\\) to the output \\(y\\) with a function \\(f\\) that depends on (currently unknown) parameters \\(A\\)\nCollect a training set of known input-output pairs of \\(\\{x, y\\}\\) and determine the parameters \\(A\\) such that the model predicts the expected outputs for the training set\n\nTechnically: minimize a cost function using gradient descent\n\nUse the estimated parameters to compute output for new inputs (inference)"
  },
  {
    "objectID": "index.html#handwriting-recognition-2",
    "href": "index.html#handwriting-recognition-2",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\n\nInput \\(\\mathbf{x}\\): vector of size \\(784\\) representing grayscale values of an image of \\(28 \\times 28\\) pixels\nOutput \\(\\mathbf{y}\\): vector of size \\(10\\), representing probabilities that image is classified as integer \\(\\{ 0, 1, ..., 9\\}\\)\nModel \\(\\mathbf{y} = \\sigma \\left( W \\mathbf{x} + \\mathbf{B} \\right)\\)\n\nPerceptron: neuron whose activation depends on weights, biases and inputs\n\\(\\sigma\\) is an activation function, in this case a softmax\n\nParameters: \\(W\\) (\\(782 \\times 10\\)) matrix and \\(\\mathbf{B}\\) (vector of size 10)\n\n\n\n\n\n\n\n\nTip\n\n\nThis is not a state-of-the art model, but does demonstrate the essence of even very modern machine learning."
  },
  {
    "objectID": "index.html#handwriting-recognition-3",
    "href": "index.html#handwriting-recognition-3",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nAn excellent tutorial is available at https://www.3blue1brown.com/lessons/neural-networks (it uses multiple layers, so more parameters than in our case)"
  },
  {
    "objectID": "index.html#handwriting-recognition-4",
    "href": "index.html#handwriting-recognition-4",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition",
    "text": "Handwriting recognition\nInstructions:\n\nUse https://github.com/AndrewCarterUK/mnist-neural-network-plain-c as a starting point\nGo through the code and try to get a high-level overview, without getting lost in the implementation details\nAdd checkpointing: allow storing parameters at the end of training in HDF5 format. Also allow reading them back in as initial guess to resume training\nReplace the linear algebra operations by calls to BLAS. Compare the performance with the original implementation\nWrite a companion program that does inference by using precalculated parameters\nImplement your own feature that you think would improve the code"
  },
  {
    "objectID": "index.html#handwriting-recognition-discussion",
    "href": "index.html#handwriting-recognition-discussion",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.00%\nP(1) =   0.01%\nP(2) =   0.11%\nP(3) =  99.81%\nP(4) =   0.00%\nP(5) =   0.02%\nP(6) =   0.00%\nP(7) =   0.00%\nP(8) =   0.05%\nP(9) =   0.00%\nDigit prediction: 3"
  },
  {
    "objectID": "index.html#handwriting-recognition-discussion-1",
    "href": "index.html#handwriting-recognition-discussion-1",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.05%\nP(1) =   0.00%\nP(2) =   0.01%\nP(3) =  96.88%\nP(4) =   0.00%\nP(5) =   3.06%\nP(6) =   0.00%\nP(7) =   0.00%\nP(8) =   0.00%\nP(9) =   0.00%\nDigit prediction: 3"
  },
  {
    "objectID": "index.html#handwriting-recognition-discussion-2",
    "href": "index.html#handwriting-recognition-discussion-2",
    "title": "Scientific C for programmers",
    "section": "Handwriting recognition discussion",
    "text": "Handwriting recognition discussion\n\nAfter training for 500 epochs: accuracty for test set is about 90%\nInference for examples outside of test set:\n\n\n\n\n\nP(0) =   0.00%\nP(1) =   0.08%\nP(2) =   0.68%\nP(3) =   0.01%\nP(4) =   0.00%\nP(5) =   0.00%\nP(6) =  99.08%\nP(7) =   0.00%\nP(8) =   0.14%\nP(9) =   0.00%\nDigit prediction: 6"
  },
  {
    "objectID": "index.html#segmentation-faults-1",
    "href": "index.html#segmentation-faults-1",
    "title": "Scientific C for programmers",
    "section": "Segmentation faults",
    "text": "Segmentation faults\n\nA segmentation fault occurs when a program accesses memory it does not own.\nCommon causes:\n\nDereferencing NULL or uninitialized pointers\nAccessing memory out of bounds (arrays, strings)\nWriting to read-only memory"
  },
  {
    "objectID": "index.html#segmentation-fault-example",
    "href": "index.html#segmentation-fault-example",
    "title": "Scientific C for programmers",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\n#include &lt;stdio.h&gt;\n \nint main(void) {\n    int n = 4;\n    int A[n];\n    for (int i = 0; i &lt;= n; i++) printf(\"A[%5d] = %12d\\n\", i, A[i]);\n    for (int i = 1; i &lt;= n; i++) printf(\"A[%5d] = %12d\\n\", i * 30000, A[i * 30000]);\n    return 0;\n}\nWhat will happen when you compile and run this program?\n\nThe program will not compile\nThe program will crash when accessing A[0] since its value is not initialized\nThe program will crash when accessing A[4] since it is outside of the array\nThe program might crash when accessing any element outside of the array\nThe program will always run to completion"
  },
  {
    "objectID": "index.html#segmentation-fault-example-1",
    "href": "index.html#segmentation-fault-example-1",
    "title": "Scientific C for programmers",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\nA[    0] =            0\nA[    1] =            0\nA[    2] =      4199005\nA[    3] =            0\nA[    4] =  -2103564768\nA[30000] =   1818850658\nA[60000] =    774974819\nSegmentation fault (core dumped)\n\nSome elements of the array (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[30000]) have a garbage value\n\nMakes sense, you just get what happens to be in memory at (A + 30000)\n\nThe access of A[90000] gives a segmentation fault\n\n???"
  },
  {
    "objectID": "index.html#virtual-vs-physical-memory",
    "href": "index.html#virtual-vs-physical-memory",
    "title": "Scientific C for programmers",
    "section": "Virtual vs physical memory",
    "text": "Virtual vs physical memory\n\n\n\nAs a user/programmer, you see virtual memory\nVirtual memory creates the illusion of a large, contiguous, uniform address space\n\nHides fragmentation of physical memory\nDelegates managing memory hierarchy (caches, RAM, disk) to OS\nProvides safety mechanism to isolate process’ address space\n\n\n\n\n\n\n\nMapping to phyical memory in page table\n\nOut-of-bound memory access can pick up garbage mapping address\nYou might be accessing another process’ memory, even on read access the CPU throws a segmentation fault"
  },
  {
    "objectID": "index.html#segmentation-fault-example-2",
    "href": "index.html#segmentation-fault-example-2",
    "title": "Scientific C for programmers",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\nA[    0] =            0\nA[    1] =            0\nA[    2] =      4199005\nA[    3] =            0\nA[    4] =  -2103564768\nA[30000] =   1818850658\nA[60000] =    774974819\nSegmentation fault (core dumped)\n\nSome elements of the array (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[30000]) have a garbage value\n\nMakes sense, you just get what happens to be in memory at (A + 3000)\n\nThe access of A[90000] gives a segmentation fault\n\nThis virtual address corresponds to a physical address that is not part of the process\nThe operating system reports this as a segmentation fault"
  },
  {
    "objectID": "index.html#handling-segmentation-faults",
    "href": "index.html#handling-segmentation-faults",
    "title": "Scientific C for programmers",
    "section": "Handling segmentation faults",
    "text": "Handling segmentation faults\n\nDo not make coding mistakes :)\nAsk the compiler to instrument executable to\n\ngcc -fsanitize=bounds-strict segmentation_fault.c\nCan lead to lower performance\n\nRun the program under a debugger such as gdb\n\nCompile with debug symbols (-g)"
  },
  {
    "objectID": "index.html#versions-of-c-1",
    "href": "index.html#versions-of-c-1",
    "title": "Scientific C for programmers",
    "section": "Versions of C 1",
    "text": "Versions of C 1\nAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#a-brief-history-of-c",
    "href": "index.html#a-brief-history-of-c",
    "title": "Scientific C for programmers",
    "section": "A brief history of C",
    "text": "A brief history of C\n\nC development starts in the early 1970s\nFirst standard published in 1989: ANSI C or C89\nUpdate in 1999: C99 standard\nUpdate in 2011: C11 standard\nMinor bugfixes in 2017: C17 (sometimes referred to as C18)\nUpdate in 2023: C23"
  },
  {
    "objectID": "index.html#different-c-standards",
    "href": "index.html#different-c-standards",
    "title": "Scientific C for programmers",
    "section": "Different C standards",
    "text": "Different C standards\n\nThe C89 standard is still considered the default\nCompiler has to be instructed to use specific standard: gcc -std=c11\n\nYou need a recent compiler for the most recent standard\n\nCompilers often do not stick exactly to standard\n\ngcc provides some C99 constructions by default\nOptions like -std=c89 -pedantic make it more strict"
  },
  {
    "objectID": "index.html#the-c99-standard-additions",
    "href": "index.html#the-c99-standard-additions",
    "title": "Scientific C for programmers",
    "section": "The C99 standard additions",
    "text": "The C99 standard additions\n\nSingle-line comments with //\nVariable length arrays\nMark functions with inline to avoid call overhead\nUse restrict to indicate arrays do not overlap\nBoolean and complex types in &lt;bool.h&gt; and &lt;complex.h&gt;\nType-generic macros in &lt;tgmath.h&gt;\nIEEE 754 floating point support"
  },
  {
    "objectID": "index.html#inline-functions",
    "href": "index.html#inline-functions",
    "title": "Scientific C for programmers",
    "section": "Inline functions",
    "text": "Inline functions\n\nFunction call: expensive\n\ncall stack must be maintained\nstack variables allocated, initialized\n\nSmall functions, called often: lots of overhead\nInline functions: function code inserted in caller\n\ngood compilers try that anyway\nhelping compilers: better optimization!\n\n\ninline double sqr(double x) {\n    return x*x;\n}"
  },
  {
    "objectID": "index.html#restrict-keyword-for-arrays",
    "href": "index.html#restrict-keyword-for-arrays",
    "title": "Scientific C for programmers",
    "section": "Restrict keyword for arrays",
    "text": "Restrict keyword for arrays\n\nArrays in C:\n\ndecay into pointers, just contain address of first element\nno semantics for compiler\n\nMultiple arrays as function arguments, do they overlap?\nHelp compiler, use restrict\n\nprogrammer assures to compiler that arrays don’t overlap\n\n\nvoid daxpy_r(double * restrict z, double a, double * restrict x,\n             double * restrict y, int n);"
  },
  {
    "objectID": "index.html#complex-numbers",
    "href": "index.html#complex-numbers",
    "title": "Scientific C for programmers",
    "section": "Complex numbers",
    "text": "Complex numbers\n\nTypes:\n\nfloat complex: single precision\ndouble complex: double precision\nlong double complex: extended precision\n\nDeclarations in complex.h\n\ntypes\nliteral: I\nfunctions, e.g., creal, cimag, csqrt, cexp, …"
  },
  {
    "objectID": "index.html#type-generic-math",
    "href": "index.html#type-generic-math",
    "title": "Scientific C for programmers",
    "section": "Type-generic math",
    "text": "Type-generic math\n\nAutomatically selects the correct version of a math function:\n\nfloat, double, or long double\ncomplex or real types\n\nCleaner code: No need to manually choose sinf, sin, or sinl.\nType safety: Matches function to argument type at compile time.\n\n#include &lt;tgmath.h&gt;\n\ndouble x = 0.5;\nfloat y = 0.5f;\n\ndouble result1 = sin(x);  // uses sin()\nfloat result2 = sin(y);   // uses sinf()"
  },
  {
    "objectID": "index.html#ieee-754-floating-point-support",
    "href": "index.html#ieee-754-floating-point-support",
    "title": "Scientific C for programmers",
    "section": "IEEE 754 floating point support",
    "text": "IEEE 754 floating point support\n\nfloat: 4 byte, single precision\ndouble: 8 byte, double precision\nlong double: 12 byte, extended precision\nRounding well-defined\nSupport for Inf, -Inf, NaN"
  },
  {
    "objectID": "index.html#the-c11-standard",
    "href": "index.html#the-c11-standard",
    "title": "Scientific C for programmers",
    "section": "The C11 standard",
    "text": "The C11 standard\nThe _Generic Keyword\n\nEnables type-generic programming (like tgmath.h)\nExample:\n#define my_abs(x) _Generic((x), \\\n    int: abs, \\\n    float: fabsf, \\\n    double: fabs \\\n)(x)"
  },
  {
    "objectID": "index.html#mathematics-in-c23",
    "href": "index.html#mathematics-in-c23",
    "title": "Scientific C for programmers",
    "section": "Mathematics in C23",
    "text": "Mathematics in C23\n\nNew mathematical functions in math.h\n\nsinpi(x) is the same as sin(pi*x) with better precision\nexp10 et al.\n\nChecked integer arithmetic in stdckdint.h\n\nckd_add et al.\n\nSupport for 1'000 and 1'133.023 notation\nDecimal floating-point math (IEEE 754-2008/2019)"
  },
  {
    "objectID": "index.html#syntax-changes-in-c23",
    "href": "index.html#syntax-changes-in-c23",
    "title": "Scientific C for programmers",
    "section": "Syntax changes in C23",
    "text": "Syntax changes in C23\n\nnullptr (keyword) rather than NULL (macro)\ntrue/false keywords, stdbool.h not required\nUnnamed function parameters\nstdbit.h: bit manipulation functions\nstrdup/strndup: simple string duplication\nconstexpr for compile-time constants\nstatic_assert for compile-time asserts\ntypeof to determine type at compile time"
  },
  {
    "objectID": "index.html#c23-attributes",
    "href": "index.html#c23-attributes",
    "title": "Scientific C for programmers",
    "section": "C23 attributes",
    "text": "C23 attributes\n\nDefensive programming\n\n[[fallthrough]]: intentional fall-through in switch\n[[nodiscard]]: don’t ignore return value\n[[maybe_unused]]: don’t warn if not used (function/parameter)\n[[deprecated]]\n\nPerformance related\n\n[[unsequenced]]: function has no side-effects, calls can be out-of-order\n[[reproducible]]: function has no side-effect, calls have to be in-order (e.g., random numbers)"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-4",
    "href": "index.html#scientific-programming-landscape-4",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#more-to-explore",
    "href": "index.html#more-to-explore",
    "title": "Scientific C for programmers",
    "section": "More to explore",
    "text": "More to explore\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "index.html#more-to-explore-1",
    "href": "index.html#more-to-explore-1",
    "title": "Scientific C for programmers",
    "section": "More to explore",
    "text": "More to explore\n\n\n\n\n\n\nTip\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/."
  },
  {
    "objectID": "code_examples/swap_naive.html",
    "href": "code_examples/swap_naive.html",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach-1",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach-1",
    "title": "",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach-2",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach-2",
    "title": "",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach-3",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach-3",
    "title": "",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach-4",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach-4",
    "title": "",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n10\n\n\nb\n0x10C\n5\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach-5",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach-5",
    "title": "",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\nOutput:\nx = 5, y = 10\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10"
  },
  {
    "objectID": "c_basics.html",
    "href": "c_basics.html",
    "title": "Basics of C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_basics.html#outline",
    "href": "c_basics.html#outline",
    "title": "Basics of C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_basics.html#data-types-operators-and-expressions-1",
    "href": "c_basics.html#data-types-operators-and-expressions-1",
    "title": "Basics of C",
    "section": "Data types, operators and expressions 1 2",
    "text": "Data types, operators and expressions 1 2\n\nVariables are the basic data objects manipulated in a C program\nC is statically typed: a variable is of a specific type defined at compile time\nC allows manipulation of variables by expressions with operators"
  },
  {
    "objectID": "c_basics.html#the-very-basics",
    "href": "c_basics.html#the-very-basics",
    "title": "Basics of C",
    "section": "The very basics",
    "text": "The very basics\n\n\n\nC statements 3 end with a semicolon\nBraces {} are used to group statements into a code block\nWhitespace is mostly ignored, allows to improve readability\nCompiler ignores what comes after // and between /* and */\n\n\nint a = 10;\nif (a &gt; 0) {\n    b = 2; // Single-line comment\n    c = 3;\n}\n/* Multi-line\n   comment */"
  },
  {
    "objectID": "c_basics.html#names-of-data-objects-in-c",
    "href": "c_basics.html#names-of-data-objects-in-c",
    "title": "Basics of C",
    "section": "Names of data objects in C",
    "text": "Names of data objects in C\n\nare case sensitive\nconsist of {A,...,Z,a,...,z,_,0,...,9}\nstart with {A,...,Z,a,...,z,_}\ncan have any length, but at most:\n\nvariables: 31 significant, 64 for C99+\nfunctions: 6 significant4, 32 for C99+\n\ncannot be reserved words such as if, while, char, int, …"
  },
  {
    "objectID": "c_basics.html#conventions-for-names",
    "href": "c_basics.html#conventions-for-names",
    "title": "Basics of C",
    "section": "Conventions for names",
    "text": "Conventions for names\n\nvariables, functions: start with lowercase\nconstants, type names: start with uppercase or fully capitalized\nnames reflect semantics of entity!\n\nvariables with very small scope have a short name\n\ncamelCase (e.g., nrOfRuns) or underscores nr_of_runs\n\n\n\n\n\n\n\nTip\n\n\n\nTry to be consistent within a project. If you might share code with others, try to stick to a generally accepted code style, e.g. the GNU coding standard"
  },
  {
    "objectID": "c_basics.html#overview-of-data-types",
    "href": "c_basics.html#overview-of-data-types",
    "title": "Basics of C",
    "section": "Overview of data types",
    "text": "Overview of data types\n\nchar: single character\nint: integer, allows qualifiers (signed, long, …)\nfloat/double/long double: real numbers\nenum: list of constants\nstruct: structure, group of related variables"
  },
  {
    "objectID": "c_basics.html#characters",
    "href": "c_basics.html#characters",
    "title": "Basics of C",
    "section": "Characters",
    "text": "Characters\n\na char holds 1 character of the local character set\nusually 1 byte, check with the sizeof operator\nlimits are defined in limits.h header as CHAR_MIN and CHAR_MAX\nchar can be signed or unsigned\n\nalmost always irrelevant, just use char\n\nExample: char myChar = 'b';\n\n\"b\" is a string (=array of chars)!"
  },
  {
    "objectID": "c_basics.html#special-characters-are-escaped-with",
    "href": "c_basics.html#special-characters-are-escaped-with",
    "title": "Basics of C",
    "section": "Special characters are escaped with \\",
    "text": "Special characters are escaped with \\\n\n'\\a': bell\n'\\n': new line\n'\\r': carriage return\n'\\t': horizontal tab\n'\\\\': backslash\n'\\'': single quote\n'\\\"': double quote\n'\\0': null character (terminates strings)"
  },
  {
    "objectID": "c_basics.html#strings",
    "href": "c_basics.html#strings",
    "title": "Basics of C",
    "section": "Strings?",
    "text": "Strings?\n\nC does not have a basic string type\nThere are two ways to declare a string constant:\n\nAn array of characters: 5\nchar amessage[] = \"My first string\";\nA character pointer: 6\nchar *pmessage = \"My second string\";"
  },
  {
    "objectID": "c_basics.html#strings-1",
    "href": "c_basics.html#strings-1",
    "title": "Basics of C",
    "section": "Strings?",
    "text": "Strings?\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "c_basics.html#integers",
    "href": "c_basics.html#integers",
    "title": "Basics of C",
    "section": "Integers",
    "text": "Integers\n\nint: typically 4 bytes, offers \\(2^{32}\\) distinct values\nmodifiers:\n\nunsigned int: only non-negative integers, natural for array indices\nshort int/long int/long long int: different ranges compared to plain int, can be combined with unsigned\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe range of int can be a limitation in practice, think about the range you need and choose the appropriate type."
  },
  {
    "objectID": "c_basics.html#fixed-size-integers",
    "href": "c_basics.html#fixed-size-integers",
    "title": "Basics of C",
    "section": "Fixed-size integers",
    "text": "Fixed-size integers\nThe C standard only imposes a minimal range for integers:\n\nFor example, int should at least cover \\([−32767, +32767]\\)\nSome platforms provide larger range =&gt; code is potentially platform dependent\n\nIf you need a fixed range:\n\nInclude the stdint.h header\nUse uint8_t, int16_t, …, which provide exactly the specified number of bits"
  },
  {
    "objectID": "c_basics.html#real-numbers",
    "href": "c_basics.html#real-numbers",
    "title": "Basics of C",
    "section": "Real numbers",
    "text": "Real numbers\n\n\n\nReal numbers are represented in a computer in a format very similar to exponential notation7\nComputer uses binary representation, e.g., the IEEE SP standard:\n\nExponent determines range\nMantissa determines precision"
  },
  {
    "objectID": "c_basics.html#double-precision",
    "href": "c_basics.html#double-precision",
    "title": "Basics of C",
    "section": "Double precision",
    "text": "Double precision\n\n\n\n\n\na double is usually 8 bytes and gives about 15 decimal digit precision\nthe float.h header provides:\n\nDBL_MAX: largest positive double\nDBL_MIN: smallest positive double\nDBL_EPSILON: difference between 1.0 and next representable value (\\(\\approx\\) machine precision)\nBLD_DIG: number of significant decimal digits"
  },
  {
    "objectID": "c_basics.html#basic-floating-point-representations",
    "href": "c_basics.html#basic-floating-point-representations",
    "title": "Basics of C",
    "section": "Basic floating-point representations",
    "text": "Basic floating-point representations\n\ndouble: most often used in science\nfloat: half the number of bits compared to double, usually 7 decimal digit precision\nlong double: usually larger range than double, not used often\n\n\n\n\n\n\n\nNote\n\n\n\nIn deep learning, reduced-precision formats (FP16, FP8) are often used. Only dedicated devices like GPUs give hardware support."
  },
  {
    "objectID": "c_basics.html#enumeration",
    "href": "c_basics.html#enumeration",
    "title": "Basics of C",
    "section": "Enumeration",
    "text": "Enumeration\n\nenum makes it convenient to refer to constants symbolically\nUsing automatic integer numbering:\n\nenum Level = {LOW, MEDIUM, HIGH};\nenum Level myLevel = MEDIUM; // myLevel will be 1\n\nUsing custom values:\n\nenum Pieces = {King = 'K', Queen = 'Q', Rook = 'R', Bishop = 'B', Knight = 'N'};\nenum Pieces myPiece = Bishop; // myPiece will be 'B'"
  },
  {
    "objectID": "c_basics.html#type-conversion",
    "href": "c_basics.html#type-conversion",
    "title": "Basics of C",
    "section": "Type conversion",
    "text": "Type conversion\n\nIn constants, use suffix, e.g. 123456789L is a long int\nIn expressions, automatic conversion to largest type, e.g. 5/9.0 is interpreted as 5.0/9.0\nExplicit casting with brackets, e.g. (int) 5.3\n\nthis evaluates to the integer 5, so information is lost"
  },
  {
    "objectID": "c_basics.html#accidental-type-conversion",
    "href": "c_basics.html#accidental-type-conversion",
    "title": "Basics of C",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nWhat do you expect the following code will do?\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    double a = -1.6e12;\n    if (abs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n    else printf(\"abs(a) is smaller or equal to 0\\n\");\n}\n\n\nBehaviour is unexpected?\n\n$ gcc conversion.c -o conversion && ./conversion\nabs(a) is smaller or equal to 0"
  },
  {
    "objectID": "c_basics.html#accidental-type-conversion-1",
    "href": "c_basics.html#accidental-type-conversion-1",
    "title": "Basics of C",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nCompilation with -Wconversion flags provide a hint\n\n$ gcc -Wconversion conversion.c  -o conversion\nconversion.c: In function ‘main’:\nconversion.c:6:13: warning: conversion from ‘double’ to ‘int’ may change value [-Wfloat-conversion]\n    6 |     if (abs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n\n\nThe abs function is for int, double a was silently converted\nSolution: use the fabs function\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main() {\n    double a = -1.6e12;\n    if (fabs(a) &gt; 0) printf(\"abs(a) is greater than 0\\n\");\n    else printf(\"abs(a) is smaller or equal to 0\\n\");\n}"
  },
  {
    "objectID": "c_basics.html#variable-declaration",
    "href": "c_basics.html#variable-declaration",
    "title": "Basics of C",
    "section": "Variable declaration",
    "text": "Variable declaration\n\nC is statically typed, each variable has to be declared with type information: int a, b;\nCan be combined with an assignment, but no automatic initalization:\n\ndouble x = 3.2, y;\ndouble z = sqrt(2.0);\n\nConstants cannot be modified during runtime, must be assigned on declaration: const int MINUTESPERHOUR = 60;\n\nConvention: names of constants are capitalized"
  },
  {
    "objectID": "c_basics.html#booleans",
    "href": "c_basics.html#booleans",
    "title": "Basics of C",
    "section": "Booleans",
    "text": "Booleans\n\nThe original C89 standard does not have a boolean type\n\ntrue: non-zero integer, non-NULL pointer\nfalse: zero, NULL pointer\n\nThe C99 standard adds the bool type and true/false keywords (after including &lt;stdbool.h&gt;)\nThe C23 standard provides booleans by default\nYou can get by with the C89 approach, dedicated bool type might be somewhat more efficient in some cases"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes",
    "href": "c_basics.html#exercise-data-type-sizes",
    "title": "Basics of C",
    "section": "Exercise: data type sizes",
    "text": "Exercise: data type sizes\nGoal:\n\nPrint information about sizes and ranges of several types\n\nLearning outcomes:\n\nUnderstand C data types\n\nInstructions:\n\nExtend the program provided in exercises/04_data_type_sizes to print information about more types and ranges\nExplain the relation between sizes and ranges"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes-solution",
    "href": "c_basics.html#exercise-data-type-sizes-solution",
    "title": "Basics of C",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The size of int is %zu bytes; it ranges from %d to %d\\n\",\n       sizeof(int), INT_MIN, INT_MAX);\nprintf(\"The size of unsigned long int is %zu bytes; its max is %lu\\n\",\n       sizeof(unsigned long int), ULONG_MAX);\nOutput:\nThe size of int is 4 bytes; it ranges from -2147483648 to 2147483647\nThe size of unsigned long int is 8 bytes; its max is 18446744073709551615\n\n4 bytes = 32 bits: int is in \\([-2^{31}, 2^{31}-1]\\)\n8 bytes = 64 bits: unsigned long int is in \\([0, 2^{64}-1]\\)"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes-solution-1",
    "href": "c_basics.html#exercise-data-type-sizes-solution-1",
    "title": "Basics of C",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The largest double that can be represented is %6.1e\\n\", DBL_MAX);\nprintf(\"The smallest positive double that can be represented is %6.1e\\n\", DBL_MIN);\nprintf(\"The machine epsilon is %6.1e\\n\", DBL_EPSILON);\nprintf(\"The number of digits is %d\\n\", DBL_DIG);\nOutput:\nThe largest double that can be represented is 1.8e+308\nThe smallest positive double that can be represented is 2.2e-308\nThe machine epsilon is 2.2e-16\nThe number of digits is 15\n\nExponent has 11 bits -&gt; in range [-1023,1024] -&gt; \\(2^{1024} \\approx 10^{308}\\)\nMantissa has 52 bits -&gt; 52 significant digits in binary -&gt; \\(52 \\log_{10} 2 \\approx 15.6\\)"
  },
  {
    "objectID": "c_basics.html#overview-of-operators",
    "href": "c_basics.html#overview-of-operators",
    "title": "Basics of C",
    "section": "Overview of operators",
    "text": "Overview of operators\n\narithmetic operators\nrelational operators\nlogical operators\nbitwise operators\nassignment operators\nincremental operators\nconditional operator"
  },
  {
    "objectID": "c_basics.html#arithmetic-operators",
    "href": "c_basics.html#arithmetic-operators",
    "title": "Basics of C",
    "section": "Arithmetic operators",
    "text": "Arithmetic operators\n\naddition, subtraction: +, -\nmultiplication, division: *, /\n\ninteger division truncates fractional part, 5/9 equals 0\n\nmodulo (only for integers): %\n*, /, % take precedence over + and -\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse brackets for clarity instead of relying on precedence rules"
  },
  {
    "objectID": "c_basics.html#relational-operators",
    "href": "c_basics.html#relational-operators",
    "title": "Basics of C",
    "section": "Relational operators",
    "text": "Relational operators\n\norder:\n\nsmaller, smaller or equal: &lt;, &lt;=\nlarger, larger or equal: &gt;, &gt;=\n\nequality:\n\nequal to, not equal to: ==, !=\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBe careful when comparing doubles, e.g. pow(sqrt(5.0), 2) == 5.0 is false!"
  },
  {
    "objectID": "c_basics.html#logical-operators",
    "href": "c_basics.html#logical-operators",
    "title": "Basics of C",
    "section": "Logical operators",
    "text": "Logical operators\n\nlogical and, logical or: &&, ||\n\nevaluated left to right with early stopping, (i &lt; N) && (a[i] &gt; 0) will not access a[i] unless i &lt; N\n\nunary negation !\n\nconverts non-zero operand into 0 and zero operand into 1\nzero is false, non-zero is true"
  },
  {
    "objectID": "c_basics.html#incrementdecrement-operators",
    "href": "c_basics.html#incrementdecrement-operators",
    "title": "Basics of C",
    "section": "Increment/decrement operators",
    "text": "Increment/decrement operators\n\nC specific shorthand notation\n\nincrement: i = i + 1; is the same as i++; or ++i;\ndecrement: i = i - 1; is the same as i--; or --i;\n\npost/pre increment matters when value is used, for example in assignment:\n\nint j = ++i;: first increment i, then assign it to j\nint j = i++;: first assign i to j, then increment i\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe name C++ can be interpreted as “incremented C”"
  },
  {
    "objectID": "c_basics.html#bitwise-operators",
    "href": "c_basics.html#bitwise-operators",
    "title": "Basics of C",
    "section": "Bitwise operators",
    "text": "Bitwise operators\nManipulate bits of integers (signed and unsigned char, int, long, …)\n\nBitwise and, or, xor: &, |, ^\n\n0011 & 0101 -&gt; 0001\n\nShift bits left, right: &lt;&lt;, &gt;&gt;\n\n0111 1000 &gt;&gt; 2 -&gt; xx01 1110\nx is zero if unsigned, undefined otherwise\n\nOne’s complement: ~\n\n~1101 -&gt; 0010\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBitwise operators are powerful, but also tedious. Use with care!"
  },
  {
    "objectID": "c_basics.html#assignment-operators",
    "href": "c_basics.html#assignment-operators",
    "title": "Basics of C",
    "section": "Assignment operators",
    "text": "Assignment operators\n\nSimple assignment is done with = (do not confuse with comparison ==)\nAssignment operators allow to compress statements:\n\ni = i + 2; is the same as i += 2;\nMost binary operators have a corresponding assignment operator\nMore concise, but often more intuitive as well"
  },
  {
    "objectID": "c_basics.html#conditional-expression",
    "href": "c_basics.html#conditional-expression",
    "title": "Basics of C",
    "section": "Conditional expression",
    "text": "Conditional expression\nConditional expression is a ternary operator condition ? expr_true : expr_false\n\nEvaluate the condition\n\nIf true, evaluate expr_true as the result\nIf false, evaluate expr_false as the result\n\n\n// z = max(a, b)\nif (a &gt; b) {\n    z = a;\n} else {\n    z = b;\n}\n// same thing but shorter\nz = (a &gt; b) ? a : b;"
  },
  {
    "objectID": "c_basics.html#precedence-and-associativity",
    "href": "c_basics.html#precedence-and-associativity",
    "title": "Basics of C",
    "section": "Precedence and associativity",
    "text": "Precedence and associativity\n\nK&R provide a table with precedence rules (2.12)\n\nMake your code readable and maintable by using brackets\n\nC does not specify order of evaluation for most operators:\n\norder can even depend on compiler options\nx = f() + g(); might evaluate g before f\n\nimportant if g alters variable used by f\n\na + b + c; could be (a + b) + c or a + (b + c)\n\nfloating-point arithmetic does not preserve mathematical associativity"
  },
  {
    "objectID": "c_basics.html#exercise-operators",
    "href": "c_basics.html#exercise-operators",
    "title": "Basics of C",
    "section": "Exercise: operators",
    "text": "Exercise: operators\nGoal: Solve a few operator-related programming questions Learning outcome: Understand the basics of C operators Instructions: See exercises/05_operators\n\n\n\n\n\n\nTip\n\n\n\nThis exercise uses the assert() function to check your solution. This function can be useful for debugging, but should not be used in production code.\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can easily “cheat” the assert() statements, but that is not the intention of course."
  },
  {
    "objectID": "c_basics.html#exercise-operators-solution",
    "href": "c_basics.html#exercise-operators-solution",
    "title": "Basics of C",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\nImplement a function that returns if a year is a leap year: easy to achieve by combining modulo and logical operators.\nint isLeapYear(int year) {\n    /* Return 1 if year is a leap year and return 0 otherwise\n       A year is a leap year if:\n       - it is divisible by 4 but not by 100 OR\n       - it is disisible by 400\n    */\n    if ( (year % 4 == 0 && year % 100 != 0) || (year % 400) == 0) return 1;\n    else return 0;\n}"
  },
  {
    "objectID": "c_basics.html#exercise-operators-solution-1",
    "href": "c_basics.html#exercise-operators-solution-1",
    "title": "Basics of C",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\n// Multiply i by 8 and store it in j, but without making use of the * operator\n// Hint: use a bitwise operator\nint i = 5;\nint j = i &lt;&lt; 3;\nassert(j == 40);\n\n// Compute c as the minimal value of a and b without using an if-else statement\nint a = 126;\nint b = 45;\nint c = (a &lt; b) ? a : b;\nassert(c == b);"
  },
  {
    "objectID": "c_basics.html#control-flow-1",
    "href": "c_basics.html#control-flow-1",
    "title": "Basics of C",
    "section": "Control flow 8 9",
    "text": "Control flow 8 9\n\nControl flow statements specify order in which computations are performed\nOften multiple ways to achieve the same end result\n\nInvolves an element of personal preference\nOne way might provide faster code than another"
  },
  {
    "objectID": "c_basics.html#statements-and-blocks",
    "href": "c_basics.html#statements-and-blocks",
    "title": "Basics of C",
    "section": "Statements and blocks",
    "text": "Statements and blocks\n\nUse ; to terminate a statement\nGroup multiple statements in blocks with braces {}\n\nblocks can be nested\nvariables can be redeclared and have block scope\n{\n   int i = 3; // from here, i is 3\n   {\n      int i = 5; //from here, i is 5\n   }\n   // from here, i is 3 again\n}\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse blocks to make your code more readable, unless you want to participate in the The International Obfuscated C Code Contest"
  },
  {
    "objectID": "c_basics.html#if-else-statement",
    "href": "c_basics.html#if-else-statement",
    "title": "Basics of C",
    "section": "if-else statement",
    "text": "if-else statement\n\n\nif (expression != 0) {\n    statement_true;\n} else {\n    statement_false;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression != 0} --&gt;|true| C[statement_true]\n    B --&gt;|false| E[statement_false]\n\n\n\n\n\n\n\n\n\nThe else clause is optional\nFor a single-line statement, braces are optional\nIndentation is only for style, but helps for readability\nif (expression) is the same as if (expression != 0)"
  },
  {
    "objectID": "c_basics.html#else-if-statement",
    "href": "c_basics.html#else-if-statement",
    "title": "Basics of C",
    "section": "else-if statement",
    "text": "else-if statement\n\n\nif (expression1) {\n    statement1;\n} else if (expression2) {\n    statement2;\n} else {\n    statement3;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression1} --&gt;|true| C[statement1]\n    B --&gt;|false| E{expression2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n\n\n\n\n\n\n\n\n\nGeneral way to write a multi-way decision\nThe else clause is optional"
  },
  {
    "objectID": "c_basics.html#switch",
    "href": "c_basics.html#switch",
    "title": "Basics of C",
    "section": "Switch",
    "text": "Switch\n\n\nswitch (expression) {\n    case const-expr1: statements1\n    case const-expr2: statements2\n    default: statements3\n}\n\n\n\n\n\nMulti-way decision to branch based on comparison with constant integer values\nFall through: execution goes to next case\n\nYou can leave a switch with break or return\n\nCase expressions must be constant and unique\ndefault is optional"
  },
  {
    "objectID": "c_basics.html#switch-example",
    "href": "c_basics.html#switch-example",
    "title": "Basics of C",
    "section": "Switch example",
    "text": "Switch example\n// Count occurrence of odd and even digits in a string\nswitch (c) {\ncase '0': case '2': case '4': case '6': case '8':\n    neven++;\n    break;\ncase '1': case '3': case '5': case '7': case '9':\n    nodd++;\n    break;"
  },
  {
    "objectID": "c_basics.html#for-loop",
    "href": "c_basics.html#for-loop",
    "title": "Basics of C",
    "section": "For loop",
    "text": "For loop\n// General for loop\nfor (expr1; expr2; expr3) {\n    statements;\n}\n// Most common usage\nfor (int i = 0; i &lt; N; i++) {\n    statements;\n}\n\nexpr1: executed once at start, typically for initialization\nexpr2: evaluated at start of each iteration, for loop stops if false\nexpr3: evaluated at end of each iteration"
  },
  {
    "objectID": "c_basics.html#for-loop-1",
    "href": "c_basics.html#for-loop-1",
    "title": "Basics of C",
    "section": "For loop",
    "text": "For loop\n\nShould be used when number of repetitions is known or computed\nEach expression is optional, for (;;) {} is an infinite loop\nbreak in loop body terminates loop\ncontinue in loop body goes to next iteration"
  },
  {
    "objectID": "c_basics.html#while-loop",
    "href": "c_basics.html#while-loop",
    "title": "Basics of C",
    "section": "While loop",
    "text": "While loop\n// General while loop\nwhile (expression) {\n    statements;\n}\n// Check if str contains c\nwhile (i &lt; strlen(str) && !found) {\n    if (str[i] == c)\n        found = True;\n    else\n        i++;\n}\n\nstatements are executed zero or more times, as long as expression is true\nshould be used when number of repetitions is unknown"
  },
  {
    "objectID": "c_basics.html#do-while-loop",
    "href": "c_basics.html#do-while-loop",
    "title": "Basics of C",
    "section": "Do-While loop",
    "text": "Do-While loop\n// General while loop\ndo {\n    statements;\n} while (expression);\n\nstatements are executed at least once, until expression is false\nSimilar to while loop, but expression is evaluated at end of iteration"
  },
  {
    "objectID": "c_basics.html#goto-and-labels",
    "href": "c_basics.html#goto-and-labels",
    "title": "Basics of C",
    "section": "Goto and labels",
    "text": "Goto and labels\ngoto label;\n...\nlabel:\n    statements;\n\ngoto allows to branch to a specified label\nnever necessary, often makes code hard to read\neven C inventors discourage it, do do not use it"
  },
  {
    "objectID": "c_basics.html#functions-and-program-structure-1",
    "href": "c_basics.html#functions-and-program-structure-1",
    "title": "Basics of C",
    "section": "Functions and Program Structure 10 11",
    "text": "Functions and Program Structure 10 11\n\nFunctions break large computing tasks into smaller ones\nHelp to bring structure into code\nHide implementations details\nMake it easier to reuse existing code"
  },
  {
    "objectID": "c_basics.html#basics-of-functions",
    "href": "c_basics.html#basics-of-functions",
    "title": "Basics of C",
    "section": "Basics of functions",
    "text": "Basics of functions\n// General function definition\nreturn-type function-name(type1 arg1, type2 arg2, ...) {\n    declarations and statements;\n    return expression;\n} \n\nA function can have no arguments: int myFunction(void);\nA function can return nothing: void myFunction(int A);\n\nNo return statement in body required\n\nThe compiler requires a function to be known before it can process a call\n\nDeclare the function: return-type function-name(type1 arg1, type2 arg2);\nDeclaration is promise to provide implementation later"
  },
  {
    "objectID": "c_basics.html#function-examples",
    "href": "c_basics.html#function-examples",
    "title": "Basics of C",
    "section": "Function examples",
    "text": "Function examples\n// The most minimal (useless) function\ndummy() {}\n// Compute the square of a floating-point number\ndouble square(double a) {\n    return a * a;\n}"
  },
  {
    "objectID": "c_basics.html#return-statements",
    "href": "c_basics.html#return-statements",
    "title": "Basics of C",
    "section": "Return statement(s)",
    "text": "Return statement(s)\n\nA return statements returns a value (or nothing), but also returns control to the caller\nA function can have multiple return statements, but at most one is executed in each call\n\nint index(char c, char s[]) {\n    unsigned i;\n    for (i = 0; i &lt; strlen(s); i++)\n        if (s[i] == c)\n            return i;\n    return -1;\n}\n\nThe returned expression is converted to function’s return type\n\n// Valid, but dubious\nint returnInt() {\n    double a = 5.0;\n    return a;\n}"
  },
  {
    "objectID": "c_basics.html#more-on-functions",
    "href": "c_basics.html#more-on-functions",
    "title": "Basics of C",
    "section": "More on functions",
    "text": "More on functions\n\nmain function is special: always the entry point of the program\nC passes arguments by value, inside the function a local copy is made\n\nchanges to values are invisible outside of function\npointers (see Day 3) allow to circumvent limitations\n\nA function can only return one variable\n\npack multiple values in a struct\nuse pointers (see Day 3) to pass out values\nexternal variables (usually a bad idea)"
  },
  {
    "objectID": "c_basics.html#return-code-of-main-function",
    "href": "c_basics.html#return-code-of-main-function",
    "title": "Basics of C",
    "section": "Return code of main function",
    "text": "Return code of main function\n\nThe return code of main is passed as exit code to calling process\nConvention is to return 0 in case of success, non-zero otherwise\nAllows chaining dependent commands, for example in bash:\n\n&& only executes next command if previous one had exit code 0\n\ncompile && execute"
  },
  {
    "objectID": "c_basics.html#return-code-of-main-function-1",
    "href": "c_basics.html#return-code-of-main-function-1",
    "title": "Basics of C",
    "section": "Return code of main function",
    "text": "Return code of main function\n\nstdlib.h defines some macros\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    FILE* fp = fopen(\"data.txt\", \"r\");\n    if (fp == NULL)\n    {\n       fprintf(stderr, \"fopen() failed in file %s at line #%d\", __FILE__, __LINE__);\n       exit(EXIT_FAILURE);\n    }\n\n    /* Normal processing continues here. */\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "objectID": "c_basics.html#external-variables",
    "href": "c_basics.html#external-variables",
    "title": "Basics of C",
    "section": "External variables",
    "text": "External variables\n\ninternal variable: defined inside function\n\nlifetime and scope limited to function call\n\nexternal variable: defined outside function\n\nbigger scope: globally accessible inside any function\nlonger lifetime: keeps value between calls\nalternative for long list of function arguments\n\n\n\n\n\n\n\n\nTip\n\n\n\nExternal variables typically make code less reusable, so generally they should be avoided"
  },
  {
    "objectID": "c_basics.html#external-variables-example",
    "href": "c_basics.html#external-variables-example",
    "title": "Basics of C",
    "section": "External variables example",
    "text": "External variables example\n#include &lt;stdio.h&gt;\nint external_variable;\n\nvoid someFunction(void) {\n    printf(\"In someFunction, external variable is %d\\n\", external_variable);\n    external_variable++;\n    }\n\nint main(void) {\n    external_variable = 1;\n    someFunction();\n    printf(\"in main, external variable is %d\\n\", external_variable);\n    return 0;\n}\n\nValue of external_variable persists:\n$ ./a.out\nIn someFunction, external variable is 1\nin main, external variable is 2"
  },
  {
    "objectID": "c_basics.html#scope",
    "href": "c_basics.html#scope",
    "title": "Basics of C",
    "section": "Scope",
    "text": "Scope\nThe scope of a variable or function is the part of the program where the variable of function can be used\n\nLocal variables\n\nFrom definition until end of block\nIncludes function arguments\n\nExternal variables\n\nFrom definition until end of file\nCan be used in multiple files by declaring with extern (not covered)"
  },
  {
    "objectID": "c_basics.html#header-files-and-build-systems",
    "href": "c_basics.html#header-files-and-build-systems",
    "title": "Basics of C",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nSo far: small programs in one .c file: easy to compile\nLarger projects: many source files\n\nOrder of compilation can matter because of dependencies\nDifficult to remember compilation commands (linking and flags)\nEditing one file does not require recompiling entirely"
  },
  {
    "objectID": "c_basics.html#header-files-and-build-systems-1",
    "href": "c_basics.html#header-files-and-build-systems-1",
    "title": "Basics of C",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nUse header files:\n\n.h files containing shared definitions and declarations\n#include \"example.h\" or #include &lt;stdio.h&gt;\n\nUse a build system (not covered here)\n\nMakefile (https://github.com/hpcleuven/Makefile-intro]\nCMake (https://github.com/hpcleuven/CMake-intro]\nMeson\n\n\n\n\n\n\n\n\nTip\n\n\n\nMost exercises can be compiled by running the make command in the exercise directory"
  },
  {
    "objectID": "c_basics.html#static-variables",
    "href": "c_basics.html#static-variables",
    "title": "Basics of C",
    "section": "Static variables",
    "text": "Static variables\n\nInternal variables with static declaration\n\nRemain in existing across function calls\nProvide permanent private storage within a single function\n\n\nunsigned uniqueIdentifier() {\n    // id Indicates how many times the function has been called\n    static unsigned id = 0;\n    return id++;\n}"
  },
  {
    "objectID": "c_basics.html#static-functions",
    "href": "c_basics.html#static-functions",
    "title": "Basics of C",
    "section": "Static functions",
    "text": "Static functions\n\nFunctions with static declaration\n\nA static function is only visible within the file where it is declared\nA normal function is visible everywhere\n\nExternal variables with static declaration\n\nCan only be used in file where they are declared"
  },
  {
    "objectID": "c_basics.html#initialization",
    "href": "c_basics.html#initialization",
    "title": "Basics of C",
    "section": "Initialization",
    "text": "Initialization\n\nAutomatic internal variables\n\nWithout explicit initialization (such as int x;), values are “garbage”\nInitial value can come from expression: double y = sqrt(6.0);\nRe-initialized each time the block is entered\nCompiler can warn about uninitialized variables\n\nE.g., -Wuninitialized for gcc (not perfect)"
  },
  {
    "objectID": "c_basics.html#initialization-1",
    "href": "c_basics.html#initialization-1",
    "title": "Basics of C",
    "section": "Initialization",
    "text": "Initialization\n\nStatic internal variables\n\nGuaranteed to initialize to zero\nInitialization first time it is encountered\nExpression or constant expression\n\nExternal variables\n\nGuaranteed to initialize to zero\nInitialized at start of execution\nConstant expression"
  },
  {
    "objectID": "c_basics.html#recursion",
    "href": "c_basics.html#recursion",
    "title": "Basics of C",
    "section": "Recursion",
    "text": "Recursion\nFunctions can call themselves (i.e. recursion)\nunsigned long fac(unsigned long n) {\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n*fac(n-1);\n}\n\nEach function call has overhead (pushing frame on stack)\nOften not the fastest or lowest footprint\n\nDeep recursion levels can even cause stack overflow\n\nOften closer to mathematical description\n\n\n\n\n\n\n\nTip\n\n\n\nWhen turning on compiler optimizations, recursive functions might be automatically converted to a loop, especially in case of tail recursion (where the recursive call is the last statement)."
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor",
    "href": "c_basics.html#the-c-preprocessor",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA few statements are processed before compilation\n\n#include \"filename\" or include &lt;filename&gt;\n#define name replacement\nconditional inclusions with #if, #elif, #else, #endif\n\nIn your head, do not interpret these as C code, but imagine their impact on the code presented to compiler."
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-1",
    "href": "c_basics.html#the-c-preprocessor-1",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\n\n#include \"myheader.h\": includes content from myheader.h in current directory verbatim\n#include &lt;math.h&gt;: includes content from math.h in include directory verbatim\nguarantees all source files have same definitions and variable declarations"
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-2",
    "href": "c_basics.html#the-c-preprocessor-2",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA macro substitution replaces each occurrence of a name with a replacement, for example #define max(A, B) ((A) &gt; (B) ? (A) : (B))\n\nEvery occurence of max(x, y) will be replaced\nUse with care, can make code more readable, but also obfuscate when reading code for the first time\nMacros avoid overhead associated with function call"
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-3",
    "href": "c_basics.html#the-c-preprocessor-3",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nConditional inclusion gives control over preprocessor statements\n// Prevent redefinition\n#ifndef FOUR_PI\n#define FOUR_PI 4 * M_PI\n#endif\n// Use SYSTEM to decide which header is included\n#if SYSTEM == SYSV\n    #define HDR \"sysv.h\"\n#elif SYSTEM == MSDOS\n    #define HDR \"msdos.h\"\n#else\n    #define HDR \"default.h\"\n#endif"
  },
  {
    "objectID": "c_basics.html#variadic-functions",
    "href": "c_basics.html#variadic-functions",
    "title": "Basics of C",
    "section": "Variadic functions",
    "text": "Variadic functions\n\nC allows variable-length argument lists (variadic functions)\nThe printf function is an example we already encountered\nstdarg.h header provides utilities like va_list,va_start,va_arg,va_end\n\n\n\n\n\n\n\nTip\n\n\n\nUse sparingly, variadic functions are somewhat unconventional"
  },
  {
    "objectID": "c_basics.html#variadic-functions-1",
    "href": "c_basics.html#variadic-functions-1",
    "title": "Basics of C",
    "section": "Variadic functions",
    "text": "Variadic functions\n\nExample: add variable number of integers:\n\n#include &lt;stdarg.h&gt;\n\nint add_integers(int count, ...)\n{\n    int result = 0;\n    va_list args;\n    va_start(args, count); // count can be omitted since C23\n    for (int i = 0; i &lt; count; ++i) {\n        result += va_arg(args, int);\n    }\n    va_end(args);\n    return result;\n}"
  },
  {
    "objectID": "c_basics.html#compute-pi-using-monte-carlo",
    "href": "c_basics.html#compute-pi-using-monte-carlo",
    "title": "Basics of C",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo\nGoal:\n\nWrite a program that approximates \\(\\pi\\) by using a Monte Carlo algorithm\n\nLearning outcomes:\n\nWrite a loop and use control flow\n\nInstructions:\n\nThe quarter unit circle in the first quadrant has area \\(\\frac{\\pi}{4}\\). Approximate this area by generating uniformly distributed points in \\([0,1] \\times [0,1]\\) (get_random_double is provided) and selecting points inside a unit circle\nHow does the estimate converge with the number of samples?\nSee exercises/06_mc_pi."
  },
  {
    "objectID": "c_basics.html#compute-pi-using-monte-carlo-1",
    "href": "c_basics.html#compute-pi-using-monte-carlo-1",
    "title": "Basics of C",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo"
  },
  {
    "objectID": "c_basics.html#compiler-optimization",
    "href": "c_basics.html#compiler-optimization",
    "title": "Basics of C",
    "section": "Compiler optimization",
    "text": "Compiler optimization\n\nMost compilers have flags to control to which extent executable is optimized\nExamples of optimizations\n\nFunction inlining\nEliminating common subexpressions\nVectorization\nStatements of source code are reordered\nLoop reordering"
  },
  {
    "objectID": "c_basics.html#gcc-optimization-levels",
    "href": "c_basics.html#gcc-optimization-levels",
    "title": "Basics of C",
    "section": "GCC optimization levels",
    "text": "GCC optimization levels\n\n-O0:\n\nNo optimization, machine code stays close to source code\nFast compilation, but slow at runtime\nGood for debugging, never use for production runs!\n\n-O2 or -O3:\n\nOptimize, but comply with standards\nSlower compilation, but fast at runtime\nUsually the best option for production runs\n\n-Ofast:\n\nOptimize and possibly ignore standards compliance\nIn principle the fastest execution\nNever use without checking results!"
  },
  {
    "objectID": "c_basics.html#monte-carlo-pi-timings",
    "href": "c_basics.html#monte-carlo-pi-timings",
    "title": "Basics of C",
    "section": "Monte Carlo \\(\\pi\\) timings",
    "text": "Monte Carlo \\(\\pi\\) timings\n\nCompilation without optimizations:\n$ gcc -O0 -o mc_pi mc_pi.c && ./mc_pi\nWalltime =    2.490s,      4.0e+07 iterations/s\nNsamples = 100000000 Estimated pi =   3.14169792 Error =   1.0527e-04\nCompilation with optimizations:\n$ gcc -O2 -o mc_pi mc_pi.c && ./mc_pi\nWalltime =    1.768s,      5.7e+07 iterations/s\nNsamples = 100000000 Estimated pi =   3.14169792 Error =   1.0527e-04\nMain optimization in this case is probably inlining get_random_double"
  },
  {
    "objectID": "c_basics.html#fibonacci",
    "href": "c_basics.html#fibonacci",
    "title": "Basics of C",
    "section": "Fibonacci",
    "text": "Fibonacci\nGoal:\n\nWrite a program to compute the Fibonacci sequence\n\nLearning outcome:\n\nWrite (recursive) functions\n\nInstructions:\n\nThe Fibonacci sequence is defined by \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) and \\(F_0=0, F_1=1\\)\nCompute the nth element by using a recursive function\nTry to trigger a stack overflow for large n\nWrite a function without recursion\nSee exercises/07_recursion"
  },
  {
    "objectID": "c_basics.html#footnotes",
    "href": "c_basics.html#footnotes",
    "title": "Basics of C",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nKernighan and Ritchie, Chapter 2, Types, operators and expressions↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nA statement is roughly a programming instruction, something to do↩︎\nguaranteed by standard, nowadays most compilers allow longer lengths↩︎\narrays are discussed later on↩︎\npointers are discussed later on↩︎\nnot part of the C standard, but quite universal↩︎\nKernighan and Ritchie, Chapter 3, Control Flow↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 4, Functions and Program Structure↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎"
  },
  {
    "objectID": "wrapping_up.html",
    "href": "wrapping_up.html",
    "title": "Wrapping up",
    "section": "",
    "text": "Wrapping up"
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "outline.html#outline",
    "href": "outline.html#outline",
    "title": "",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  }
]