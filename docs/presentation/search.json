[
  {
    "objectID": "c_advanced.html#pointers-and-arrays-1",
    "href": "c_advanced.html#pointers-and-arrays-1",
    "title": "Advanced C",
    "section": "Pointers and arrays 1 2",
    "text": "Pointers and arrays 1 2\n\nA pointer is a variable that contains the address of a variable\nThe & operator gives the address of an object\nThe * operator dereferences a pointer\nDeclarations like int *px indicate that px is a pointer and *px is an int"
  },
  {
    "objectID": "c_advanced.html#virtual-memory-layout",
    "href": "c_advanced.html#virtual-memory-layout",
    "title": "Advanced C",
    "section": "Virtual memory layout",
    "text": "Virtual memory layout\n\n\n\nVirtual memory looks like a table with two columns\n\nAddress column in hexadecimal format\nValue column in decimal format\nRemember that internally it’s all binary\nSome variables take up more than one address\nThe Variable column is just for mnemonics\n\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nint x\n0x0000\n42\n\n\nint y\n0x0004\n43\n\n\ndouble a\n0x0008\n12.6e10\n\n\ndouble a\n0x000c\n\n\n\nfloat b\n0x0010\n3.14"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-naive-approach",
    "href": "c_advanced.html#swapping-variables-naive-approach",
    "title": "Advanced C",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#working-with-large-arrays",
    "href": "c_advanced.html#working-with-large-arrays",
    "title": "Advanced C",
    "section": "Working with large arrays",
    "text": "Working with large arrays\n\nSuppose you construct vectors using a struct (see later)\nYou want a function double innerProduct(struct vector v1, struct vector v2) that computes the inner product\nSince C uses pass-by-value, those objects would be copied when function is called\nMemory access is slow, this would give bad performance for large cases\n\n=&gt; This is also addressed by pointers"
  },
  {
    "objectID": "c_advanced.html#pointer-basics",
    "href": "c_advanced.html#pointer-basics",
    "title": "Advanced C",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the address of a variable\nPointer arguments allow modifying object in the calling function\nThere are different pointer types, depending on the object they point to\n\nint *px;\ndouble *pa;\n\n\n\n\n\n\n\n\nTip\n\n\n\nMnemonic: read int *px as *px is of type int. Sometimes people also use int* px to declare an integer pointer."
  },
  {
    "objectID": "c_advanced.html#pointer-basics-1",
    "href": "c_advanced.html#pointer-basics-1",
    "title": "Advanced C",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nThe & operator gives the address of an object\nThe * operator dereferences a pointer\n\nint x = 1, y;\nint *px;\n\npx = &x; // px now points to x, i.e. it holds the address of x\ny = *px; // y now holds the value of the object px points to, i.e. y = 1\n*px = 10; // the value of the object px points to is set, i.e. x = 10"
  },
  {
    "objectID": "c_advanced.html#swapping-variables-pointers",
    "href": "c_advanced.html#swapping-variables-pointers",
    "title": "Advanced C",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_advanced.html#pointers-and-arrays-2",
    "href": "c_advanced.html#pointers-and-arrays-2",
    "title": "Advanced C",
    "section": "Pointers and arrays",
    "text": "Pointers and arrays\n\nAn array is a block of consecutive objects of a specified type\n\nint a[10]; declares 10 consecutive int objects\nThe i-th element can be accessed as a[i]\n\nPointers are a natural way to loop over arrays\n\nint a[10];\nint *pa;\npa = &a[0]; // pa points to first element of a\npa++; // pa now points to second element of a\n\n\n\n\n\n\nWarning\n\n\n\nWhen pointing to array elements, incrementing a pointer always means going to the next object irrespective of the object type!"
  },
  {
    "objectID": "c_advanced.html#array-indexing-sourcery",
    "href": "c_advanced.html#array-indexing-sourcery",
    "title": "Advanced C",
    "section": "Array indexing sourcery",
    "text": "Array indexing sourcery\n\nIn C, the name of an array is a synonym for the location of the initial element\n\nint *pa = &a[0] is identical to int *pa = a\n\nAccess to the i-th element a[i] is translated to *(a+i)\nBecause integer addition is a[i] is identical to i[a]!"
  },
  {
    "objectID": "c_advanced.html#arrays-as-function-arguments",
    "href": "c_advanced.html#arrays-as-function-arguments",
    "title": "Advanced C",
    "section": "Arrays as function arguments",
    "text": "Arrays as function arguments\n\nWhen passing an array to a function, the location of the initial element is passed\nWithin the called function, the corresponding local variable is a pointer\nYou can pass a part of an array to a function\n\nf(&a[2]) pass the subarray that starts at a[2]\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou cannot pass a slice of an array, the called function is responsible to respect the bounds of the array. This is one of the reasons why C programs are often considered at risk for unsafe memory management."
  },
  {
    "objectID": "c_advanced.html#character-pointers",
    "href": "c_advanced.html#character-pointers",
    "title": "Advanced C",
    "section": "Character pointers",
    "text": "Character pointers\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation",
    "href": "c_advanced.html#dynamic-memory-allocation",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nThe C89 standard does not allow variable length arrays\n\nArray size must be known at compile time\nsize_t len = 5; int a[len]; is stricly speaking invalid\nSince C99 it is supported and many compilers allow it by default\n\nEven if you can have VLAs, there are some downsides\n\nAllocated on stack, so limited in size\nScope is local, similar as other variables\nVLA might be less efficient\n\n\n\n\n\n\n\n\nTip\n\n\n\nVariable length refers to the fact that length is only known at runtime, a variable length array remains of the same size during its lifetime."
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation-1",
    "href": "c_advanced.html#dynamic-memory-allocation-1",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nMemory for arrays can be dynamically allocated on the heap\n\nHeap is a large area of memory used at runtime\nSignature: void *malloc(size_t size);\nsize is in bytes: make use of sizeof\nreturns void pointer, cast it to correct pointer type\nif memory cannot be allocated, null pointer is returned\nalways free() the memory exactly once!\ncalloc: includes initializing to zero (so slower than malloc)"
  },
  {
    "objectID": "c_advanced.html#dynamic-memory-allocation-2",
    "href": "c_advanced.html#dynamic-memory-allocation-2",
    "title": "Advanced C",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n    size_t len = atoi(argv[1]);\n    double *pa = (double *) malloc(len * sizeof(double));\n    if (pa == NULL) { return 1;}\n    free(pa);\n}"
  },
  {
    "objectID": "c_advanced.html#multidimensional-arrays",
    "href": "c_advanced.html#multidimensional-arrays",
    "title": "Advanced C",
    "section": "Multidimensional arrays",
    "text": "Multidimensional arrays\n\nC supports multidimensional arrays by using multiple []\n\nint matrix[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n\nIndexing is done with [i][j] (not [i,j])\n\nint x = matrix[1][2]\n\nC uses row-major storage: last dimension is fastest in memory"
  },
  {
    "objectID": "c_advanced.html#pointers-to-pointers",
    "href": "c_advanced.html#pointers-to-pointers",
    "title": "Advanced C",
    "section": "Pointers to pointers",
    "text": "Pointers to pointers\n\nA pointer is also a variable -&gt; another pointer can point to its address\nIn contrast to multidimensional arrays, we can now have irregular structures\nExample: storing an upper triangular matrix\n\ndouble **lower;\nlower = (double **)malloc( n * sizeof(double *))\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}\nfree(lower);"
  },
  {
    "objectID": "c_advanced.html#arrays-of-pointers",
    "href": "c_advanced.html#arrays-of-pointers",
    "title": "Advanced C",
    "section": "Arrays of pointers",
    "text": "Arrays of pointers\n\nBy now it should be clear pointers and arrays are very similar\nThe previous example as an array of pointers:\n\ndouble *lower[n];\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}"
  },
  {
    "objectID": "c_advanced.html#pointers-to-function",
    "href": "c_advanced.html#pointers-to-function",
    "title": "Advanced C",
    "section": "Pointers to function",
    "text": "Pointers to function\n\nExample\n\nWhen \\(a\\) and \\(b\\) are close, the integral \\(\\int_a^{b} f(x) dx \\approx \\frac{1}{2} \\frac{f(a) + f(a)}{b-a}\\)\nThis rule can be written for any \\(f(x)\\) as:\n\n\ndouble trapezoidRule (double (*f)(double), double a, double b) {\n    return (b-a)*(f(a) + f(b))/2;\n}\ndouble trap = trapezoidRule(cos, 0, M_PI);"
  },
  {
    "objectID": "c_advanced.html#quadrature",
    "href": "c_advanced.html#quadrature",
    "title": "Advanced C",
    "section": "Quadrature",
    "text": "Quadrature\nGoal:\n\nWrite a program that can numerically integrate arbitrary functions\n\nLearning outcome:\n\nUse pointers to let functions operate on arrays and functions\n\nInstructions:\n\nWrite a function that allocates an array, with evenly spaced real numbers in a chosen interval as entries\nWrite a function that approximates the integral of sin and tan on the chosen interval\nSee exercises/08_quadrature"
  },
  {
    "objectID": "c_advanced.html#heat-equation",
    "href": "c_advanced.html#heat-equation",
    "title": "Advanced C",
    "section": "Heat equation",
    "text": "Heat equation\nGoal:\n\nWrite a program that solves the 2D heat equation\n\nLearning outcome:\n\nLearn to work with multi-dimensional arrays\n\nInstructions:\n\nSee exercises/09_heat_equation"
  },
  {
    "objectID": "c_advanced.html#structures-1",
    "href": "c_advanced.html#structures-1",
    "title": "Advanced C",
    "section": "Structures 3 4",
    "text": "Structures 3 4\n\nA structure is a collection of one or more variables\nMakes it convenient to organize and handle complicated data\nA very lightweight class (but do not call C object-oriented):\n\nNo inheritance\nNo class methods"
  },
  {
    "objectID": "c_advanced.html#structure-example",
    "href": "c_advanced.html#structure-example",
    "title": "Advanced C",
    "section": "Structure example",
    "text": "Structure example\n\nA structure is defined with struct, usually followed by a tag as a name\n\nstruct particle {\n    double x;\n    double y;\n    double z;\n    double mass;\n}\n\nThe variables named in the struct are members and can be accessed with the . operator"
  },
  {
    "objectID": "c_advanced.html#structure-example-1",
    "href": "c_advanced.html#structure-example-1",
    "title": "Advanced C",
    "section": "Structure example",
    "text": "Structure example\n\nA struct can be initialized directly or member-by-member\n\nstruct particle p1;\np1.x = 1.0;\np1.y = 2.0;\np1.z = 3.0;\np1.m = 1.000784;\nstruct particle p2 = {2.0, 4.0, 5.0, 4.002602};"
  },
  {
    "objectID": "c_advanced.html#structures-and-functions",
    "href": "c_advanced.html#structures-and-functions",
    "title": "Advanced C",
    "section": "Structures and functions",
    "text": "Structures and functions\n\nFunctions can operate on structures much the same way as basic types\n\nstruct particle centerOfMass(struct particle p1, struct particle p2) {\n    double mass = p1.m + p2.m;\n    struct particle com;\n    com.x = (p1.x * p1.m + p2.x * p2.m) / mass;\n    com.y = (p1.y * p1.m + p2.y * p2.m) / mass;\n    com.z = (p1.z * p1.m + p2.z * p2.m) / mass;\n    com.mass = mass\n    return com;\n}"
  },
  {
    "objectID": "c_advanced.html#arrays-of-structures",
    "href": "c_advanced.html#arrays-of-structures",
    "title": "Advanced C",
    "section": "Arrays of structures",
    "text": "Arrays of structures\n\nArrays can be made up of structs\n\n// Make an array with n particles\nstruct particle particles[n];\n\nDefined in this way, accessing all x coordinates would give strided memory access\n\nHaving a struct with arrays can be more efficient than an array of structs\nDepends on the specific application"
  },
  {
    "objectID": "c_advanced.html#structures-and-pointers",
    "href": "c_advanced.html#structures-and-pointers",
    "title": "Advanced C",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nStructures are variables, so you can point to their address\n\nvoid translateX(struct particle *p, double distance) {\n    (*p).x += distance;\n}\n\nA member of a pointer can be accessed with -&gt;\n\nIf p is a pointer to a struct particle, (*p).x is the same as p-&gt;x\n\n\nvoid translateX(struct particle *p, double distance) {\n    p-&gt;x += distance;\n}"
  },
  {
    "objectID": "c_advanced.html#structures-and-pointers-1",
    "href": "c_advanced.html#structures-and-pointers-1",
    "title": "Advanced C",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nThe . and -&gt; operators have highest precedence:\n\n*p.x would be interpreted as *(p.x) (unwanted in our example)\nuse brackets to make your intention clear"
  },
  {
    "objectID": "c_advanced.html#self-referencing-structures-linked-list",
    "href": "c_advanced.html#self-referencing-structures-linked-list",
    "title": "Advanced C",
    "section": "Self-referencing structures: linked list",
    "text": "Self-referencing structures: linked list\n\nA member can have the same type as the structure it is a member of\nSelf-referencing structures are quite common: linked list, tree, …"
  },
  {
    "objectID": "c_advanced.html#linked-list",
    "href": "c_advanced.html#linked-list",
    "title": "Advanced C",
    "section": "Linked list",
    "text": "Linked list\nTODO"
  },
  {
    "objectID": "c_advanced.html#typedef",
    "href": "c_advanced.html#typedef",
    "title": "Advanced C",
    "section": "Typedef",
    "text": "Typedef\nTODO"
  },
  {
    "objectID": "c_advanced.html#size-of-structure",
    "href": "c_advanced.html#size-of-structure",
    "title": "Advanced C",
    "section": "Size of structure",
    "text": "Size of structure\nGoal:\n\nWrite a program centered around a Person structure\n\nLearning outcomes:\n\nDefine a structure and functions operating ont\nThink about memory alignment\n\nInstructions:\n\nCreate a Person structure with members height, weight, year of birth, and first letter of name\nWrite a function that computes the total weight of a group of persons\nCheck the size of the structure in memory and explain the result\nSee exercises/10_struct_basics"
  },
  {
    "objectID": "c_advanced.html#dna-transcription",
    "href": "c_advanced.html#dna-transcription",
    "title": "Advanced C",
    "section": "DNA transcription",
    "text": "DNA transcription\nTODO"
  },
  {
    "objectID": "c_advanced.html#input-and-output-1",
    "href": "c_advanced.html#input-and-output-1",
    "title": "Advanced C",
    "section": "Input and output 5 6",
    "text": "Input and output 5 6\n\nInput/output is not part of C, but of standard library =&gt; need for #include &lt;stdio.h&gt;\nConverting input/output can be tedious (use AI assistant?)\nMake use of dedicated libraries/formats such as HDF5, NetCDF, Zarr\nAnnotate input/output with metadata (units, meaning, etc…)\nLimited coverage in this course, see K&R Appendix B"
  },
  {
    "objectID": "c_advanced.html#writing-to-standard-out-stdout",
    "href": "c_advanced.html#writing-to-standard-out-stdout",
    "title": "Advanced C",
    "section": "Writing to standard out (stdout)",
    "text": "Writing to standard out (stdout)\nprintf allows to print internal values as characters in terminal\n// int with minimal width 5\nprintf(\"a = %5d\\n\", a); // a =    10\n// int with minimal width 5 and zero padding\nprintf(\"a = %05d\\n\", a); // a = 00010\n// double with 8 digits after comma\nprintf(\"pi = %.8f\\n\", M_PI); // pi = 3.14159265\n// double in exponential notation\nprintf(\"pi = %8.2e\\n\", M_PI); // pi = 3.14e+00\n// fixed-width string\nprintf(\"%.10s\\n\", \"Hello, world\"); // Hello, wor"
  },
  {
    "objectID": "c_advanced.html#reading-from-standard-in-stdin",
    "href": "c_advanced.html#reading-from-standard-in-stdin",
    "title": "Advanced C",
    "section": "Reading from standard in (stdin)",
    "text": "Reading from standard in (stdin)\nint day;\nchar month[20];\nprintf(\"Enter data in format '01 January'\\n\");\nscanf(\"%d %s\", &day, month); // Make sure to check values!\nscanf:\n\nreturns number of matched items\nstops when format string is exhausted or input fails to match specification\n\n\n\n\n\n\n\nTip\n\n\n\nTo run non-interactively, you can redirect file contents to stdin on Linux with ./a.out &lt;inputfile"
  },
  {
    "objectID": "c_advanced.html#command-line-arguments",
    "href": "c_advanced.html#command-line-arguments",
    "title": "Advanced C",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n\nCommand-line arguments are passed to main\nFirst argument: number of command-line arguments + 1 (typically argc)\nSecond argument: pointer to array of character strings (typically argv)\n\nFirst array element (at index 0) has name of program"
  },
  {
    "objectID": "c_advanced.html#command-line-arguments-1",
    "href": "c_advanced.html#command-line-arguments-1",
    "title": "Advanced C",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"There are %d command-line arguments\\n\", argc);\n    printf(\"The program is called %s\\n\", argv[0]);\n    for (int i = 1; i &lt; argc; i++)\n        printf(\"Command-line argument %d is %s\\n\", i, argv[i]);\n    return 0;\n}\n$ ./a.out Hello World\nThere are 3 command-line arguments\nThe program is called ./a.out\nCommand-line argument 1 is Hello\nCommand-line argument 2 is World"
  },
  {
    "objectID": "c_advanced.html#file-access",
    "href": "c_advanced.html#file-access",
    "title": "Advanced C",
    "section": "File access",
    "text": "File access\n\nFiles are accessed using a FILE structure defined in stdio.h:\n\nFILE *fp; fp = fopen(name, mode);\n\nmode can be read r, append a, or write w\nMake sure to check if fopen was succesful by comparing with NULL pointer\nMake for to close file again with fclose(fp);"
  },
  {
    "objectID": "c_advanced.html#file-access-example",
    "href": "c_advanced.html#file-access-example",
    "title": "Advanced C",
    "section": "File access example",
    "text": "File access example\n    FILE *values = fopen(\"values.txt\", \"r\");\n    if (values == NULL) {\n        printf(\"Failed to open values.txt\\n\");\n        return 1;\n    }\n    char line[256];\n    while (fgets(line, sizeof(line), fp)) {\n        double value;\n        if (sscanf(line, \"%lf\", &value) == 2) {\n            printf(\"Read value %f\\n\", value);\n        }\n    }\n    fclose(values);\n$ cat values.txt\n42\n3.14\n981.12\n$ ./a.out\nRead value 42.000000\nRead value 3.140000\nRead value 981.120000"
  },
  {
    "objectID": "c_advanced.html#exercise-regression",
    "href": "c_advanced.html#exercise-regression",
    "title": "Advanced C",
    "section": "Exercise: regression",
    "text": "Exercise: regression\nGoal:\n\nWrite a program that reads temperature anomalies and predicts future values using simple linear regression\n\nLearning outcomes:\n\nLearn how to read numbers from a structured input file and process them\n\nInstructions:\n\nSee exercises/12_regression"
  },
  {
    "objectID": "c_advanced.html#footnotes",
    "href": "c_advanced.html#footnotes",
    "title": "Advanced C",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nKernighan and Ritchie, Chapter 5, Pointers and arrays↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 6, Structures↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 7, Input and Output↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎"
  },
  {
    "objectID": "jumping_in.html",
    "href": "jumping_in.html",
    "title": "Jumping in",
    "section": "",
    "text": "Goal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program\n\nCreate a text file called hello.c containing:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world\\n\");\n    return 0;\n}\nCompile and run it in a terminal as follows:\ngcc hello.c -o hello\n./hello\n\n\n\n\n\n\nTip\n\n\n\nYou can use another compiler such as clang if you prefer, some options can be different.\n\n\n\n\n\nGoal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors\n\n\nInstructions:\n\nThe training repository contains files needed for the exercices\n\nDownload the repository with\ngit clone https://github.com/stevenvdb/Scientific-C-for-programmers/\nAlternatively, visit https://github.com/stevenvdb/Scientific-C-for-programmers/ in a browser\n\nThis exercise is located in exercises/01_temperature_conversion\n\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    float fahr, celcius;\n    float lower, upper, step;\n\n    lower = 0;   // Lowest temperature in Fahrenheit\n    upper = 100; // Highest temperature in Fahrenheit\n    step = 10;   // Increment of temperature\n\n    fahr = lower;\n    while (fahr &lt; upper) {\n        celcius = (5 / 9) * (fahr - 32);\n        printf(\"%8.1f %8.1f\\n\", fahr, celcius);\n        fahr = fahr + step\n    }\n    return 0;\n}\nFix the problems (there are 3) to compile and run the code:\ngcc convert_temperatures.c -o convert_temperatures\n./convert_temperatures\n\n\n\n\nSimple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)\n\n\n\n\nGoal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercices/02_logistic_map\n\n\n\n\ndouble update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input\n\n\n\n\n\n\nComparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate\n\nExample of a chaotic system"
  },
  {
    "objectID": "jumping_in.html#the-obligatory-hello-world",
    "href": "jumping_in.html#the-obligatory-hello-world",
    "title": "Jumping in",
    "section": "",
    "text": "Goal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program\n\nCreate a text file called hello.c containing:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world\\n\");\n    return 0;\n}\nCompile and run it in a terminal as follows:\ngcc hello.c -o hello\n./hello\n\n\n\n\n\n\nTip\n\n\n\nYou can use another compiler such as clang if you prefer, some options can be different."
  },
  {
    "objectID": "jumping_in.html#temperature-conversion",
    "href": "jumping_in.html#temperature-conversion",
    "title": "Jumping in",
    "section": "",
    "text": "Goal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors\n\n\nInstructions:\n\nThe training repository contains files needed for the exercices\n\nDownload the repository with\ngit clone https://github.com/stevenvdb/Scientific-C-for-programmers/\nAlternatively, visit https://github.com/stevenvdb/Scientific-C-for-programmers/ in a browser\n\nThis exercise is located in exercises/01_temperature_conversion\n\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    float fahr, celcius;\n    float lower, upper, step;\n\n    lower = 0;   // Lowest temperature in Fahrenheit\n    upper = 100; // Highest temperature in Fahrenheit\n    step = 10;   // Increment of temperature\n\n    fahr = lower;\n    while (fahr &lt; upper) {\n        celcius = (5 / 9) * (fahr - 32);\n        printf(\"%8.1f %8.1f\\n\", fahr, celcius);\n        fahr = fahr + step\n    }\n    return 0;\n}\nFix the problems (there are 3) to compile and run the code:\ngcc convert_temperatures.c -o convert_temperatures\n./convert_temperatures"
  },
  {
    "objectID": "jumping_in.html#logistic-map",
    "href": "jumping_in.html#logistic-map",
    "title": "Jumping in",
    "section": "",
    "text": "Simple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)"
  },
  {
    "objectID": "jumping_in.html#logistic-map-1",
    "href": "jumping_in.html#logistic-map-1",
    "title": "Jumping in",
    "section": "",
    "text": "Goal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercices/02_logistic_map"
  },
  {
    "objectID": "jumping_in.html#logistic-map-solution",
    "href": "jumping_in.html#logistic-map-solution",
    "title": "Jumping in",
    "section": "",
    "text": "double update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input"
  },
  {
    "objectID": "jumping_in.html#logistic-map-discussion",
    "href": "jumping_in.html#logistic-map-discussion",
    "title": "Jumping in",
    "section": "",
    "text": "Comparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate\n\nExample of a chaotic system"
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Main lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modelling\n\nSupport during hands-on sessions from Jan De Laet\n\n\n\nPlease present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C\n\n\n\n\n\nFour sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference.\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#who-am-i",
    "href": "introduction.html#who-am-i",
    "title": "Introduction",
    "section": "",
    "text": "Main lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modelling\n\nSupport during hands-on sessions from Jan De Laet"
  },
  {
    "objectID": "introduction.html#who-are-you",
    "href": "introduction.html#who-are-you",
    "title": "Introduction",
    "section": "",
    "text": "Please present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C"
  },
  {
    "objectID": "introduction.html#practical-aspects",
    "href": "introduction.html#practical-aspects",
    "title": "Introduction",
    "section": "",
    "text": "Four sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference."
  },
  {
    "objectID": "introduction.html#outline",
    "href": "introduction.html#outline",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c",
    "href": "introduction.html#why-learn-to-program-in-c",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-1",
    "href": "introduction.html#why-learn-to-program-in-c-1",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nDidn’t AI agents take over programming? In my opinion:\n\nAI agents are invaluable assistants\nStill benefit greatly from a prompter with expertise because:\n\nThey will confidently write code that is wrong\nThey will often produce suboptimal code (speed, maintainability, …)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis opinion might be outdated very soon."
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-2",
    "href": "introduction.html#why-learn-to-program-in-c-2",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nI encourage you to use AI assistance during this course\n\nYou will use it in real-life coding\nYou need to learn how to use it\n\nwith two caveats:\n\nThe exercises are educational,AI might perform better than for your real problems\nDon’t cheat on yourself,try to understand the answers to learn something"
  },
  {
    "objectID": "introduction.html#why-learn-to-program-in-c-3",
    "href": "introduction.html#why-learn-to-program-in-c-3",
    "title": "Introduction",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\n\nRelatively low level, close to hardware\n\nPopular to write system software (OS for example)\nGives insight into computer architecture\n\nPotentially gives good performance\n\nFairly popular in scientific computing\n\nSmall and stable language, syntax can be learned quickly\nGood basis to learn other programming languages\nYou inherited a project written in C\n\nNot a good intrinsic motivation, but a reality"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape",
    "href": "introduction.html#scientific-programming-landscape",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "introduction.html#assembly",
    "href": "introduction.html#assembly",
    "title": "Introduction",
    "section": "Assembly",
    "text": "Assembly\n\nVery low level, essentially machine code in readable format\nMachine dependent, specific to each architecture\nUsed in performance-critical parts of low-level libraries\nIf you are not sure you need it, you don’t\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe godbolt project gives a taste of what assembly looks like."
  },
  {
    "objectID": "introduction.html#c",
    "href": "introduction.html#c",
    "title": "Introduction",
    "section": "C",
    "text": "C\n\nFirst appeared in 1972, successor of B\nFirst standard in 1989, four revisions since\nCompiled language with static typing\nSmall language and standard library\nGives a lot of low-level control (e.g., memory management)"
  },
  {
    "objectID": "introduction.html#c-1",
    "href": "introduction.html#c-1",
    "title": "Introduction",
    "section": "C++",
    "text": "C++\n\nExtension of C, adding object-oriented features\nCompiled language with static typing\nAllows better and more complex project constructs\nMore syntax and much larger standard library\nIn principle retains all benefits from C,in practice you program differently"
  },
  {
    "objectID": "introduction.html#rust",
    "href": "introduction.html#rust",
    "title": "Introduction",
    "section": "Rust",
    "text": "Rust\n\n“Modern” version of C/C++\nVery different approach to memory management:\n\nC/C++ are prone to bugs causing safety issues\nRust is proposed as an alternative, see DARPA: Translating all C to Rust\nNot as problematic for programs you run locally\n\nEcosystem for scientific computing not as advanced as {C/C++}, but efforts are under way"
  },
  {
    "objectID": "introduction.html#fortran",
    "href": "introduction.html#fortran",
    "title": "Introduction",
    "section": "Fortran",
    "text": "Fortran\n\nFortran (Formula Translating System) appeared in 1957\nCompiled language with static typing\nObject-oriented features added in 2003 standard\nStill a lot of Fortran compilers produce fast code\nGood fit for mathematical applications"
  },
  {
    "objectID": "introduction.html#java",
    "href": "introduction.html#java",
    "title": "Introduction",
    "section": "Java",
    "text": "Java\n\nSyntax influences by C/C++, support object orientation\nSource code compiled to Java bytecode which runs in virtual machine\n\nin principle slower code execution\n\nMemory safety and automatic garbage collection\nQuite often used in bioinformatics"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-1",
    "href": "introduction.html#scientific-programming-landscape-1",
    "title": "Introduction",
    "section": "Scientific programming landscape 2",
    "text": "Scientific programming landscape 2"
  },
  {
    "objectID": "introduction.html#julia",
    "href": "introduction.html#julia",
    "title": "Introduction",
    "section": "Julia",
    "text": "Julia\n\nDesigned for technical and numerical computing\nDynamically typed, supports multiple paradigms\nScripted language with some support for compiling\nDesigned for parallel computing"
  },
  {
    "objectID": "introduction.html#python",
    "href": "introduction.html#python",
    "title": "Introduction",
    "section": "Python",
    "text": "Python\n\nScripting language, runs in Python interpreter\nDynamically typed, garbage collection\nPerceived as easy to learn\nNot very performant (unless actual work is done by C/Fortran)\nPopular in scientific computing, including machine learning 3"
  },
  {
    "objectID": "introduction.html#r",
    "href": "introduction.html#r",
    "title": "Introduction",
    "section": "R",
    "text": "R\n\nAimed at statistical computing and visualization\nInterpreted language, runs in R interpreter\nSimilar in many aspects to Python\nPopular in some fields such as social sciences and economics"
  },
  {
    "objectID": "introduction.html#matlab",
    "href": "introduction.html#matlab",
    "title": "Introduction",
    "section": "Matlab",
    "text": "Matlab\n\nProprietary numeric computing environment\nExtensive built-in functions for linear algebra, signal processing, optimization, and statistics"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-2",
    "href": "introduction.html#scientific-programming-landscape-2",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "introduction.html#programming-accelerators",
    "href": "introduction.html#programming-accelerators",
    "title": "Introduction",
    "section": "Programming accelerators",
    "text": "Programming accelerators\n\nThus far: general-purpose programming languages for CPUs\nGPUs (originally for visualization) are well suited for scientific computing\n\nRequire dedicated programming languages\nCUDA for NVIDIA GPUs\nROCm for AMD GPUs\nOpenCL/OpenMP/… support multiple devices"
  },
  {
    "objectID": "introduction.html#parallelization",
    "href": "introduction.html#parallelization",
    "title": "Introduction",
    "section": "Parallelization",
    "text": "Parallelization\n\nHigh performance computing (HPC) is all about parallelization\nNearly all programming languages are inherently serial,parallelization has to be added\nSeveral paradigms:\n\npthreads (OS level)\nOpenMP: shared-memory parallel programming in C/C++ and Fortran\nMPI: message passing interface for communication between processes"
  },
  {
    "objectID": "introduction.html#scientific-programming-landscape-3",
    "href": "introduction.html#scientific-programming-landscape-3",
    "title": "Introduction",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape\nConclusions:\n\nKnowing multiple languages is useful\n\nAllows you to use the right tool for the right job\nFor example, C for computationally-intensive parts, Python for postprocessing\n\nSelect a few languages in which you become an expert\nLook beyond intrinsic properties, the ecosystem and support is important"
  },
  {
    "objectID": "introduction.html#what-you-will-learn-in-this-course",
    "href": "introduction.html#what-you-will-learn-in-this-course",
    "title": "Introduction",
    "section": "What you will learn in this course",
    "text": "What you will learn in this course\n\nthe place of C in the landscape of scientific programming languages\nlearn (most of) the C syntax 4\nwrite and run basic C programs with a focus on programming concepts encountered in science\nhow to use external libraries when writing C code"
  },
  {
    "objectID": "introduction.html#what-you-will-not-learn-in-this-course",
    "href": "introduction.html#what-you-will-not-learn-in-this-course",
    "title": "Introduction",
    "section": "What you will not learn in this course 5",
    "text": "What you will not learn in this course 5\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "introduction.html#what-you-will-not-learn-in-this-course-1",
    "href": "introduction.html#what-you-will-not-learn-in-this-course-1",
    "title": "Introduction",
    "section": "What you will not learn in this course 6",
    "text": "What you will not learn in this course 6\n\n\n\n\n\n\nTip\n\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/."
  },
  {
    "objectID": "introduction.html#outline-1",
    "href": "introduction.html#outline-1",
    "title": "Introduction",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "introduction.html#footnotes",
    "href": "introduction.html#footnotes",
    "title": "Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.vscentrum.be↩︎\nThe line between compiled and interpreted is not as clear as indicated in this picture↩︎\nThe heavy computational lifting is usually not done in Python↩︎\nBased on “The C Programming Language” second edition by Kernighan and Ritchie↩︎\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course↩︎\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course↩︎"
  },
  {
    "objectID": "code_examples/swap_pointers.html",
    "href": "code_examples/swap_pointers.html",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_pointers.html#swapping-variables-pointers",
    "href": "code_examples/swap_pointers.html#swapping-variables-pointers",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "beyond_c_core.html",
    "href": "beyond_c_core.html",
    "title": "External libraries",
    "section": "",
    "text": "External libraries extend C’s capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting).\nCommon scientific libraries:\n\nGSL (GNU Scientific Library)\nBLAS/LAPACK (Linear Algebra)\nFFTW (Fast Fourier Transforms)\nHDF5 (Hierarchical data format)\n\nBenefits:\n\nAvoid reinventing the wheel\nLeverage optimized, tested code\nImprove performance and portability\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeature\nStatic Library (.a/.lib)\nDynamic Library (.so/.dll)\n\n\n\n\nLinking time\nCompile time\nRuntime\n\n\nBinary size\nLarger (library included)\nSmaller (library separate)\n\n\nPortability\nEasier to distribute\nRequires library on target system\n\n\nUpdates\nRecompile to update\nCan update without recompiling\n\n\nPerformance\nSlightly faster (no indirection)\nMay have overhead at runtime\n\n\n\n\nUse gcc -static for static linking, or -l&lt;libname&gt; with -L&lt;path&gt; for dynamic linking. Details differ from library to library: check the documentation\n\n\n\n\n\nThe GNU Scientific Library (GSL) provides a wide range of mathematical routines\nHow to get it:\n\nOn the cluster: load it as a module, module load GSL/2.8-GCC-13.3.0 for example\nOn your machine: install it as a system package, apt-get install libgsl-dev for example\n\nHow to use it:\n\nInclude the relevant headers in your code\nFind relevant link flags with pkg-config --libs gsl for example\n\n\n\n\n\ndouble f(double x, void *params) {\n    Params *p = (Params *) params;\n    return exp(-p-&gt;sigma*x*x)*sin(p-&gt;a + p-&gt;b*x);\n}\ntypedef struct {\n    double a, b, sigma;\n} Params;\n\nParams params = {0.3, 1.0, 0.05};\n\ndouble minimum = -1.0, lower = -3.0, upper = 0.0;\nint iter = 0, maxIter = 100, status;\nconst gsl_min_fminimizer_type *T = gsl_min_fminimizer_brent;\ngsl_min_fminimizer *minimizer = gsl_min_fminimizer_alloc(T);\ngsl_function F;\nF.function = &f;\nF.params = (void *) &params;\ngsl_min_fminimizer_set(minimizer, &F, minimum, lower, upper);\ndo {\n    gsl_min_fminimizer_iterate(minimizer);\n    lower = gsl_min_fminimizer_x_lower(minimizer);\n    upper = gsl_min_fminimizer_x_upper(minimizer);\n    status = gsl_min_test_interval(lower, upper, 1.0e-6, 0.0);\n} while (status == GSL_CONTINUE && ++iter &lt; maxIter);\nif (status == GSL_SUCCESS) {\n    minimum = gsl_min_fminimizer_x_minimum(minimizer);\n    …\n}\ngsl_min_fminimizer_free(minimizer);\n\n\n\n\nBLAS (Basic Linear Algebra Subprograms)\n\nLow-level routines for vector and matrix operations\nLevels:\n\nLevel 1: Vector-vector (e.g., dot product)\nLevel 2: Matrix-vector (e.g., solving triangular systems)\nLevel 3: Matrix-matrix (e.g., multiplication)\n\n\nLAPACK (Linear Algebra PACKage)\n\nBuilt on top of BLAS\nHigh-level routines for:\n\nSolving linear systems\nEigenvalue problems\nSingular value decomposition\n\n\n\n\n\n\n\nWhy use them?\n\nHighly optimized for performance\nPortable across platforms\nWidely used in scientific and engineering applications\n\nMany implementations are available\n\nOpenBLAS\nIntel MKL\nATLAS\n\n\n\nLink with -lblas -llapack or use optimized implementations like OpenBLAS, Intel MKL, or ATLAS.\n\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;cblas.h&gt;\n\nint main() {\n    double x[3] = {1.0, 2.0, 3.0};\n    double y[3] = {4.0, 5.0, 6.0};\n    double result = cblas_ddot(3, x, 1, y, 1);\n    printf(\"Dot product: %f\\n\", result);\n    return 0;\n}\n\n\n\n\nHDF5 (Hierarchical Data Format v5)\n\nDesigned for storing and organizing large, complex datasets\nSupports n-dimensional arrays, tables, images, and metadata\nCommon in physics, climate modeling, bioinformatics, and engineering\n\nFeatures\n\nPortable and self-describing binary format\nHierarchical structure: groups and datasets (like folders and files)\nSupports compression, parallel I/O, and chunking\n\n\n\n\n\nSimple Example: Writing a Dataset\n\n#include \"hdf5.h\"\n\nint main() {\n    hid_t file_id, dataset_id, dataspace_id;\n    hsize_t dims[2] = {4, 6};\n    double data[4][6] = { /* initialize with values */ };\n\n    file_id = H5Fcreate(\"example.h5\", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    dataspace_id = H5Screate_simple(2, dims, NULL);\n    dataset_id = H5Dcreate(file_id, \"/mydata\", H5T_NATIVE_DOUBLE, dataspace_id,\n                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);\n    H5Dclose(dataset_id);\n    H5Sclose(dataspace_id);\n    H5Fclose(file_id);\n    return 0;\n}"
  },
  {
    "objectID": "beyond_c_core.html#external-libraries-1",
    "href": "beyond_c_core.html#external-libraries-1",
    "title": "External libraries",
    "section": "",
    "text": "External libraries extend C’s capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting).\nCommon scientific libraries:\n\nGSL (GNU Scientific Library)\nBLAS/LAPACK (Linear Algebra)\nFFTW (Fast Fourier Transforms)\nHDF5 (Hierarchical data format)\n\nBenefits:\n\nAvoid reinventing the wheel\nLeverage optimized, tested code\nImprove performance and portability"
  },
  {
    "objectID": "beyond_c_core.html#static-vs-dynamic-libraries",
    "href": "beyond_c_core.html#static-vs-dynamic-libraries",
    "title": "External libraries",
    "section": "",
    "text": "Feature\nStatic Library (.a/.lib)\nDynamic Library (.so/.dll)\n\n\n\n\nLinking time\nCompile time\nRuntime\n\n\nBinary size\nLarger (library included)\nSmaller (library separate)\n\n\nPortability\nEasier to distribute\nRequires library on target system\n\n\nUpdates\nRecompile to update\nCan update without recompiling\n\n\nPerformance\nSlightly faster (no indirection)\nMay have overhead at runtime\n\n\n\n\nUse gcc -static for static linking, or -l&lt;libname&gt; with -L&lt;path&gt; for dynamic linking. Details differ from library to library: check the documentation"
  },
  {
    "objectID": "beyond_c_core.html#gnu-scientific-library",
    "href": "beyond_c_core.html#gnu-scientific-library",
    "title": "External libraries",
    "section": "",
    "text": "The GNU Scientific Library (GSL) provides a wide range of mathematical routines\nHow to get it:\n\nOn the cluster: load it as a module, module load GSL/2.8-GCC-13.3.0 for example\nOn your machine: install it as a system package, apt-get install libgsl-dev for example\n\nHow to use it:\n\nInclude the relevant headers in your code\nFind relevant link flags with pkg-config --libs gsl for example"
  },
  {
    "objectID": "beyond_c_core.html#minimizing-a-function-with-gsl",
    "href": "beyond_c_core.html#minimizing-a-function-with-gsl",
    "title": "External libraries",
    "section": "",
    "text": "double f(double x, void *params) {\n    Params *p = (Params *) params;\n    return exp(-p-&gt;sigma*x*x)*sin(p-&gt;a + p-&gt;b*x);\n}\ntypedef struct {\n    double a, b, sigma;\n} Params;\n\nParams params = {0.3, 1.0, 0.05};\n\ndouble minimum = -1.0, lower = -3.0, upper = 0.0;\nint iter = 0, maxIter = 100, status;\nconst gsl_min_fminimizer_type *T = gsl_min_fminimizer_brent;\ngsl_min_fminimizer *minimizer = gsl_min_fminimizer_alloc(T);\ngsl_function F;\nF.function = &f;\nF.params = (void *) &params;\ngsl_min_fminimizer_set(minimizer, &F, minimum, lower, upper);\ndo {\n    gsl_min_fminimizer_iterate(minimizer);\n    lower = gsl_min_fminimizer_x_lower(minimizer);\n    upper = gsl_min_fminimizer_x_upper(minimizer);\n    status = gsl_min_test_interval(lower, upper, 1.0e-6, 0.0);\n} while (status == GSL_CONTINUE && ++iter &lt; maxIter);\nif (status == GSL_SUCCESS) {\n    minimum = gsl_min_fminimizer_x_minimum(minimizer);\n    …\n}\ngsl_min_fminimizer_free(minimizer);"
  },
  {
    "objectID": "beyond_c_core.html#blas-lapack-high-performance-linear-algebra",
    "href": "beyond_c_core.html#blas-lapack-high-performance-linear-algebra",
    "title": "External libraries",
    "section": "",
    "text": "BLAS (Basic Linear Algebra Subprograms)\n\nLow-level routines for vector and matrix operations\nLevels:\n\nLevel 1: Vector-vector (e.g., dot product)\nLevel 2: Matrix-vector (e.g., solving triangular systems)\nLevel 3: Matrix-matrix (e.g., multiplication)\n\n\nLAPACK (Linear Algebra PACKage)\n\nBuilt on top of BLAS\nHigh-level routines for:\n\nSolving linear systems\nEigenvalue problems\nSingular value decomposition"
  },
  {
    "objectID": "beyond_c_core.html#blas-lapack",
    "href": "beyond_c_core.html#blas-lapack",
    "title": "External libraries",
    "section": "",
    "text": "Why use them?\n\nHighly optimized for performance\nPortable across platforms\nWidely used in scientific and engineering applications\n\nMany implementations are available\n\nOpenBLAS\nIntel MKL\nATLAS\n\n\n\nLink with -lblas -llapack or use optimized implementations like OpenBLAS, Intel MKL, or ATLAS."
  },
  {
    "objectID": "beyond_c_core.html#dot-product-in-blas",
    "href": "beyond_c_core.html#dot-product-in-blas",
    "title": "External libraries",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;cblas.h&gt;\n\nint main() {\n    double x[3] = {1.0, 2.0, 3.0};\n    double y[3] = {4.0, 5.0, 6.0};\n    double result = cblas_ddot(3, x, 1, y, 1);\n    printf(\"Dot product: %f\\n\", result);\n    return 0;\n}"
  },
  {
    "objectID": "beyond_c_core.html#hdf5-managing-scientific-data-in-c",
    "href": "beyond_c_core.html#hdf5-managing-scientific-data-in-c",
    "title": "External libraries",
    "section": "",
    "text": "HDF5 (Hierarchical Data Format v5)\n\nDesigned for storing and organizing large, complex datasets\nSupports n-dimensional arrays, tables, images, and metadata\nCommon in physics, climate modeling, bioinformatics, and engineering\n\nFeatures\n\nPortable and self-describing binary format\nHierarchical structure: groups and datasets (like folders and files)\nSupports compression, parallel I/O, and chunking\n\n\n\n\n\nSimple Example: Writing a Dataset\n\n#include \"hdf5.h\"\n\nint main() {\n    hid_t file_id, dataset_id, dataspace_id;\n    hsize_t dims[2] = {4, 6};\n    double data[4][6] = { /* initialize with values */ };\n\n    file_id = H5Fcreate(\"example.h5\", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    dataspace_id = H5Screate_simple(2, dims, NULL);\n    dataset_id = H5Dcreate(file_id, \"/mydata\", H5T_NATIVE_DOUBLE, dataspace_id,\n                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);\n    H5Dclose(dataset_id);\n    H5Sclose(dataspace_id);\n    H5Fclose(file_id);\n    return 0;\n}"
  },
  {
    "objectID": "beyond_c_core.html#solve-a-linear-system-of-equations-with-gsl",
    "href": "beyond_c_core.html#solve-a-linear-system-of-equations-with-gsl",
    "title": "External libraries",
    "section": "Solve a linear system of equations with GSL",
    "text": "Solve a linear system of equations with GSL"
  },
  {
    "objectID": "beyond_c_core.html#training-a-neural-network-for-handwriting-recognition",
    "href": "beyond_c_core.html#training-a-neural-network-for-handwriting-recognition",
    "title": "External libraries",
    "section": "Training a neural network for handwriting recognition",
    "text": "Training a neural network for handwriting recognition"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-faults-1",
    "href": "beyond_c_core.html#segmentation-faults-1",
    "title": "External libraries",
    "section": "Segmentation faults",
    "text": "Segmentation faults\nTODO"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-fault-example",
    "href": "beyond_c_core.html#segmentation-fault-example",
    "title": "External libraries",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n = 4;\n    int A[n];\n    for (int i = 0; i &lt;= n; i++) {\n        printf(\"A[%5d] = %12d\\n\", i, A[i]);\n        printf(\"A[%5d] = %12d\\n\", i * 3000, A[i*3000]);\n    }\n    return 0;\n}\nWhat will happen when you compile and run this program?"
  },
  {
    "objectID": "beyond_c_core.html#segmentation-fault-example-1",
    "href": "beyond_c_core.html#segmentation-fault-example-1",
    "title": "External libraries",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\n$ ./segmentation_fault\nA[    0] =            0\nA[    0] =            0\nA[    1] =            0\nA[ 3000] =   1815048801\nA[    2] =      4198989\nA[ 6000] =   2034381655\nA[    3] =            0\nSegmentation fault (core dumped)\n\nSome true elements (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[3000]) have a garbage value\n\nMakes sense, it is not checked if this is actually a memory argument, you just get what happens to be in memory at (A + 3000)\n\nThe access of A[9000] gives a segmentation fault\n\n???"
  },
  {
    "objectID": "beyond_c_core.html#virtual-vs-physical-memory-background-colorlightgrey",
    "href": "beyond_c_core.html#virtual-vs-physical-memory-background-colorlightgrey",
    "title": "External libraries",
    "section": "Virtual vs physical memory {background-color=“lightgrey”}",
    "text": "Virtual vs physical memory {background-color=“lightgrey”}\n\n\n\nAs a user/programmer, you see virtual memory\nVirtual memory creates the illusion of a large, contiguous, uniform address space\n\nHides fragmentation of physical memory\nDelegates managing memory hierarchy (caches, RAM, disk) to OS\nProvides safety mechanism to isolate process’ address space\n\nMapping to phyical memory in page table\n\nOut-of-bound memory access can pick up garbage mapping address\nYou might be accessing another process’ memory, even on read access the CPU throws a segmentation fault"
  },
  {
    "objectID": "beyond_c_core.html#handling-segmentation-faults",
    "href": "beyond_c_core.html#handling-segmentation-faults",
    "title": "External libraries",
    "section": "Handling segmentation faults",
    "text": "Handling segmentation faults\n\nDo not make coding mistakes :)\nAsk the compiler to instrument executable to\n\ngcc -fsanitize=bounds-strict segmentation_fault.c\nCan lead to lower performance\n\nRun the program under a debugger such as gdb\n\nCompile with debug symbols (-g)"
  },
  {
    "objectID": "beyond_c_core.html#a-brief-history-of-c",
    "href": "beyond_c_core.html#a-brief-history-of-c",
    "title": "External libraries",
    "section": "A brief history of C",
    "text": "A brief history of C\n\nC development starts in the early 1970s\nFirst standard published in 1989: ANSI C or C89\nUpdate in 1999: C99 standard\nUpdate in 2011: C11 standard\nMinor bugfixes in 2017: C17 (sometimes referred to as C18)\nUpdate in 2023: C23"
  },
  {
    "objectID": "beyond_c_core.html#different-c-standards",
    "href": "beyond_c_core.html#different-c-standards",
    "title": "External libraries",
    "section": "Different C standards",
    "text": "Different C standards\n\nThe C89 standard is still considered the default\nCompiler has to be instructed to use specific standard: gcc -std=c11\n\nYou need a recent compiler for the most recent standard\n\nCompilers often to not stick exactly to standard\n\ngcc provides some C99 constructions by default\nOptions like -std=c89 -pedantic make it more strict"
  },
  {
    "objectID": "beyond_c_core.html#the-c99-standard-additions",
    "href": "beyond_c_core.html#the-c99-standard-additions",
    "title": "External libraries",
    "section": "The C99 standard additions",
    "text": "The C99 standard additions\n\nSingle-line comments with //\nVariable length arrays\nMark functions with inline to avoid call overhead\nUse restrict to indicate arrays do not overlap\nBoolean and complex types in &lt;bool.h&gt; and &lt;complex.h&gt;\nType-generic macros in &lt;tgmath.h&gt;\nIEEE 754 floating point support"
  },
  {
    "objectID": "beyond_c_core.html#inline-functions",
    "href": "beyond_c_core.html#inline-functions",
    "title": "External libraries",
    "section": "Inline functions",
    "text": "Inline functions\n\nFunction call: expensive\n\ncall stack must be maintained\nstack variables allocated, initialized\n\nSmall functions, called often: lots of overhead\nInline functions: function code inserted in caller\n\ngood compilers try that anyway\nhelping compilers: better optimization!\n\n\ninline double sqr(double x) {\n    return x*x;\n}"
  },
  {
    "objectID": "beyond_c_core.html#restrict-keyword-for-arrays",
    "href": "beyond_c_core.html#restrict-keyword-for-arrays",
    "title": "External libraries",
    "section": "Restrict keyword for arrays",
    "text": "Restrict keyword for arrays\n\nArrays in C\n\naddress of first element\nno semantics for compiler\n\nMultiple arrays as function arguments, do they overlap?\nHelp compiler, use restrict\n\nprogrammer assures to compiler that arrays don’t overlap\n\n\nvoid daxpy_r(double * restrict z, double a,                      double * restrict x, double * restrict y, int n);"
  },
  {
    "objectID": "beyond_c_core.html#complex-numbers",
    "href": "beyond_c_core.html#complex-numbers",
    "title": "External libraries",
    "section": "Complex numbers",
    "text": "Complex numbers\n\nTypes:\n\nfloat complex: single precision\ndouble complex: double precision\nlong double complex: extended precision\n\nDeclarations in complex.h\n\ntypes\nliteral: I\nfunctions, e.g., creal, cimag, csqrt, cexp, …"
  },
  {
    "objectID": "beyond_c_core.html#type-generic-math",
    "href": "beyond_c_core.html#type-generic-math",
    "title": "External libraries",
    "section": "Type-generic math",
    "text": "Type-generic math\n\nAutomatically selects the correct version of a math function:\n\nfloat, double, or long double\ncomplex or real types\n\nCleaner code: No need to manually choose sinf, sin, or sinl.\nType safety: Matches function to argument type at compile time.\n\n#include &lt;tgmath.h&gt;\n\ndouble x = 0.5;\nfloat y = 0.5f;\n\ndouble result1 = sin(x);  // uses sin()\nfloat result2 = sin(y);   // uses sinf()"
  },
  {
    "objectID": "beyond_c_core.html#ieee-754-floating-point-support",
    "href": "beyond_c_core.html#ieee-754-floating-point-support",
    "title": "External libraries",
    "section": "IEEE 754 floating point support",
    "text": "IEEE 754 floating point support\n\nfloat: 4 byte, single precision\ndouble: 8 byte, double precision\nlong double: 12 byte, extended precision\nRounding well-defined\nSupport for Inf, -Inf, NaN"
  },
  {
    "objectID": "beyond_c_core.html#the-c11-standard",
    "href": "beyond_c_core.html#the-c11-standard",
    "title": "External libraries",
    "section": "The C11 standard",
    "text": "The C11 standard\nThe _Generic Keyword\n\nEnables type-generic programming (like tgmath.h)\nExample:\n#define my_abs(x) _Generic((x), \\\n    int: abs, \\\n    float: fabsf, \\\n    double: fabs \\\n)(x)"
  },
  {
    "objectID": "beyond_c_core.html#mathematics-in-c23",
    "href": "beyond_c_core.html#mathematics-in-c23",
    "title": "External libraries",
    "section": "Mathematics in C23",
    "text": "Mathematics in C23\n\nNew mathematical functions in math.h\n\nsinpi(x) is the same as sin(pi*x) with better precision\nexp10 et al.\n\nChecked integer artithmetic in stdckdint.h\n\nckd_add et al.\n\nSupport for 1'000 and 1'133.023 notation\nDecimal floating-point math (IEEE 754-2008/2019)"
  },
  {
    "objectID": "beyond_c_core.html#syntax-changes-in-c23",
    "href": "beyond_c_core.html#syntax-changes-in-c23",
    "title": "External libraries",
    "section": "Syntax changes in C23",
    "text": "Syntax changes in C23\n\nnullptr`` (keyword) rather thanNULL` (macro)\ntrue/false keywords, stdbool.h not required\nUnnamed function parameters\nstdbit.h: bit manipulation functions\nstrdup/strndup: simple string duplication\nconstexpr for compile-time constants\nstatic_assert for compile-time asserts\ntypeof to determine type at compile time"
  },
  {
    "objectID": "beyond_c_core.html#c23-attributes",
    "href": "beyond_c_core.html#c23-attributes",
    "title": "External libraries",
    "section": "C23 attributes",
    "text": "C23 attributes\n\nDefensive programming\n\n[[fallthrough]]: intentional fall-through in switch\n[[nodiscard]]: don’t ignore return value\n[[maybe_unused]]: don’t warn if not used (function/parameter)\n[[deprecated]]\n\nPerformance related\n\n[[unsequenced]]: function has no side-effects, calls can be out-of-order\n[[reproducible]]: function has no side-effect, calls have to be in-order (e.g., random numbers)"
  },
  {
    "objectID": "beyond_c_core.html#scientific-programming-landscape",
    "href": "beyond_c_core.html#scientific-programming-landscape",
    "title": "External libraries",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "beyond_c_core.html#more-to-explore",
    "href": "beyond_c_core.html#more-to-explore",
    "title": "External libraries",
    "section": "More to explore",
    "text": "More to explore\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "beyond_c_core.html#more-to-explore-1",
    "href": "beyond_c_core.html#more-to-explore-1",
    "title": "External libraries",
    "section": "More to explore",
    "text": "More to explore\n\n\n\n\n\n\nTip\n\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/."
  },
  {
    "objectID": "index.html#who-am-i",
    "href": "index.html#who-am-i",
    "title": "Scientific C for programmers",
    "section": "Who am I?",
    "text": "Who am I?\nMain lecturer: Steven Vandenbrande\n\nMember of the HPC Support Team of ICTS\nHPC (High Performance Computing): KU Leuven offers Tier-2 cluster to researchers, part of the Vlaams Supercomputer Centrum (VSC 1)\nBackground in molecular modelling\n\nSupport during hands-on sessions from Jan De Laet\nhttps://www.vscentrum.be"
  },
  {
    "objectID": "index.html#who-are-you",
    "href": "index.html#who-are-you",
    "title": "Scientific C for programmers",
    "section": "Who are you?",
    "text": "Who are you?\nPlease present yourself:\n\nYour name\nYour scientific background\nYour programming background\nWhy you want to learn scientific C"
  },
  {
    "objectID": "index.html#practical-aspects",
    "href": "index.html#practical-aspects",
    "title": "Scientific C for programmers",
    "section": "Practical aspects",
    "text": "Practical aspects\n\nFour sessions of 3 hours (with a break)\nCourse website:https://stevenvdb.github.io/Scientific-C-for-programmers/\nHands on: make sure you have a working C environment\n\n\n\n\n\n\n\n\nTip\n\n\nFirst run of this course, feedback is much appreciated.\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThese slides are not intended as a reference manual, but to accompany a talk. A book like The C programming language is better suited as a reference."
  },
  {
    "objectID": "index.html#outline",
    "href": "index.html#outline",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c",
    "href": "index.html#why-learn-to-program-in-c",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-1",
    "href": "index.html#why-learn-to-program-in-c-1",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nDidn’t AI agents take over programming? In my opinion:\n\nAI agents are invaluable assistants\nStill benefit greatly from a prompter with expertise because:\n\nThey will confidently write code that is wrong\nThey will often produce suboptimal code (speed, maintainability, …)\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThis opinion might be outdated very soon."
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-2",
    "href": "index.html#why-learn-to-program-in-c-2",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\nI encourage you to use AI assistance during this course\n\nYou will use it in real-life coding\nYou need to learn how to use it\n\nwith two caveats:\n\nThe exercises are educational,AI might perform better than for your real problems\nDon’t cheat on yourself,try to understand the answers to learn something"
  },
  {
    "objectID": "index.html#why-learn-to-program-in-c-3",
    "href": "index.html#why-learn-to-program-in-c-3",
    "title": "Scientific C for programmers",
    "section": "Why learn to program in C?",
    "text": "Why learn to program in C?\n\nRelatively low level, close to hardware\n\nPopular to write system software (OS for example)\nGives insight into computer architecture\n\nPotentially gives good performance\n\nFairly popular in scientific computing\n\nSmall and stable language, syntax can be learned quickly\nGood basis to learn other programming languages\nYou inherited a project written in C\n\nNot a good intrinsic motivation, but a reality"
  },
  {
    "objectID": "index.html#scientific-programming-landscape",
    "href": "index.html#scientific-programming-landscape",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#assembly",
    "href": "index.html#assembly",
    "title": "Scientific C for programmers",
    "section": "Assembly",
    "text": "Assembly\n\nVery low level, essentially machine code in readable format\nMachine dependent, specific to each architecture\nUsed in performance-critical parts of low-level libraries\nIf you are not sure you need it, you don’t\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe godbolt project gives a taste of what assembly looks like."
  },
  {
    "objectID": "index.html#c",
    "href": "index.html#c",
    "title": "Scientific C for programmers",
    "section": "C",
    "text": "C\n\nFirst appeared in 1972, successor of B\nFirst standard in 1989, four revisions since\nCompiled language with static typing\nSmall language and standard library\nGives a lot of low-level control (e.g., memory management)"
  },
  {
    "objectID": "index.html#c-1",
    "href": "index.html#c-1",
    "title": "Scientific C for programmers",
    "section": "C++",
    "text": "C++\n\nExtension of C, adding object-oriented features\nCompiled language with static typing\nAllows better and more complex project constructs\nMore syntax and much larger standard library\nIn principle retains all benefits from C,in practice you program differently"
  },
  {
    "objectID": "index.html#rust",
    "href": "index.html#rust",
    "title": "Scientific C for programmers",
    "section": "Rust",
    "text": "Rust\n\n“Modern” version of C/C++\nVery different approach to memory management:\n\nC/C++ are prone to bugs causing safety issues\nRust is proposed as an alternative, see DARPA: Translating all C to Rust\nNot as problematic for programs you run locally\n\nEcosystem for scientific computing not as advanced as {C/C++}, but efforts are under way"
  },
  {
    "objectID": "index.html#fortran",
    "href": "index.html#fortran",
    "title": "Scientific C for programmers",
    "section": "Fortran",
    "text": "Fortran\n\nFortran (Formula Translating System) appeared in 1957\nCompiled language with static typing\nObject-oriented features added in 2003 standard\nStill a lot of Fortran compilers produce fast code\nGood fit for mathematical applications"
  },
  {
    "objectID": "index.html#java",
    "href": "index.html#java",
    "title": "Scientific C for programmers",
    "section": "Java",
    "text": "Java\n\nSyntax influences by C/C++, support object orientation\nSource code compiled to Java bytecode which runs in virtual machine\n\nin principle slower code execution\n\nMemory safety and automatic garbage collection\nQuite often used in bioinformatics"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-1",
    "href": "index.html#scientific-programming-landscape-1",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape 1",
    "text": "Scientific programming landscape 1\n\nThe line between compiled and interpreted is not as clear as indicated in this picture"
  },
  {
    "objectID": "index.html#julia",
    "href": "index.html#julia",
    "title": "Scientific C for programmers",
    "section": "Julia",
    "text": "Julia\n\nDesigned for technical and numerical computing\nDynamically typed, supports multiple paradigms\nScripted language with some support for compiling\nDesigned for parallel computing"
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Scientific C for programmers",
    "section": "Python",
    "text": "Python\n\nScripting language, runs in Python interpreter\nDynamically typed, garbage collection\nPerceived as easy to learn\nNot very performant (unless actual work is done by C/Fortran)\nPopular in scientific computing, including machine learning 1\n\nThe heavy computational lifting is usually not done in Python"
  },
  {
    "objectID": "index.html#r",
    "href": "index.html#r",
    "title": "Scientific C for programmers",
    "section": "R",
    "text": "R\n\nAimed at statistical computing and visualization\nInterpreted language, runs in R interpreter\nSimilar in many aspects to Python\nPopular in some fields such as social sciences and economics"
  },
  {
    "objectID": "index.html#matlab",
    "href": "index.html#matlab",
    "title": "Scientific C for programmers",
    "section": "Matlab",
    "text": "Matlab\n\nProprietary numeric computing environment\nExtensive built-in functions for linear algebra, signal processing, optimization, and statistics"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-2",
    "href": "index.html#scientific-programming-landscape-2",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#programming-accelerators",
    "href": "index.html#programming-accelerators",
    "title": "Scientific C for programmers",
    "section": "Programming accelerators",
    "text": "Programming accelerators\n\nThus far: general-purpose programming languages for CPUs\nGPUs (originally for visualization) are well suited for scientific computing\n\nRequire dedicated programming languages\nCUDA for NVIDIA GPUs\nROCm for AMD GPUs\nOpenCL/OpenMP/… support multiple devices"
  },
  {
    "objectID": "index.html#parallelization",
    "href": "index.html#parallelization",
    "title": "Scientific C for programmers",
    "section": "Parallelization",
    "text": "Parallelization\n\nHigh performance computing (HPC) is all about parallelization\nNearly all programming languages are inherently serial,parallelization has to be added\nSeveral paradigms:\n\npthreads (OS level)\nOpenMP: shared-memory parallel programming in C/C++ and Fortran\nMPI: message passing interface for communication between processes"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-3",
    "href": "index.html#scientific-programming-landscape-3",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape\nConclusions:\n\nKnowing multiple languages is useful\n\nAllows you to use the right tool for the right job\nFor example, C for computationally-intensive parts, Python for postprocessing\n\nSelect a few languages in which you become an expert\nLook beyond intrinsic properties, the ecosystem and support is important"
  },
  {
    "objectID": "index.html#what-you-will-learn-in-this-course",
    "href": "index.html#what-you-will-learn-in-this-course",
    "title": "Scientific C for programmers",
    "section": "What you will learn in this course",
    "text": "What you will learn in this course\n\nthe place of C in the landscape of scientific programming languages\nlearn (most of) the C syntax 1\nwrite and run basic C programs with a focus on programming concepts encountered in science\nhow to use external libraries when writing C code\n\nBased on “The C Programming Language” second edition by Kernighan and Ritchie"
  },
  {
    "objectID": "index.html#what-you-will-not-learn-in-this-course",
    "href": "index.html#what-you-will-not-learn-in-this-course",
    "title": "Scientific C for programmers",
    "section": "What you will not learn in this course 1",
    "text": "What you will not learn in this course 1\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)\n\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course"
  },
  {
    "objectID": "index.html#what-you-will-not-learn-in-this-course-1",
    "href": "index.html#what-you-will-not-learn-in-this-course-1",
    "title": "Scientific C for programmers",
    "section": "What you will not learn in this course 1",
    "text": "What you will not learn in this course 1\n\n\n\n\n\n\nTip\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/.\n\n\n\nDo not worry if you currently do not understand all terminology, we will come back to this at the end of the course"
  },
  {
    "objectID": "index.html#outline-1",
    "href": "index.html#outline-1",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#the-obligatory-hello-world",
    "href": "index.html#the-obligatory-hello-world",
    "title": "Scientific C for programmers",
    "section": "The obligatory “Hello, world”",
    "text": "The obligatory “Hello, world”\nGoal: Print Hello, world on the screen\nLearning outcome: Compile and run a C program"
  },
  {
    "objectID": "index.html#temperature-conversion",
    "href": "index.html#temperature-conversion",
    "title": "Scientific C for programmers",
    "section": "Temperature conversion",
    "text": "Temperature conversion\nGoal:\n\nPrint a table with temperatures in Fahrenheit and Celcius, the formula is \\(^\\circ C= \\frac{5}{9}(^\\circ F - 32)\\)\n\nLearning outcome:\n\nExposure to variables, operators and loops\nCorrect some common errors"
  },
  {
    "objectID": "index.html#logistic-map",
    "href": "index.html#logistic-map",
    "title": "Scientific C for programmers",
    "section": "Logistic map",
    "text": "Logistic map\n\nSimple formula to model evolution of population size \\(N_n\\):\n\n\\[\nN_{n+1} = (a-bN_n)N_n\n\\]\n\nIntuitive explanation:\n\n\\(N_{n+1} \\propto N_n\\): increases with more offspring\n\\(N_{n+1} \\propto (a-bN_n)\\): decreases because of competition\n\nNormalized version: \\(x_{n+1} = r(1-x_n)x_n\\) with \\(0\\leq x_n \\leq 1\\)"
  },
  {
    "objectID": "index.html#logistic-map-1",
    "href": "index.html#logistic-map-1",
    "title": "Scientific C for programmers",
    "section": "Logistic map",
    "text": "Logistic map\nGoal:\n\nPrint evolution of a population according to logistic map\n\nLearning outcome:\n\nWrite your first function\nLearn how to read input values\n\nInstructions:\n\nImplement the update_population function\nRead the initial population from input\nCheck README.md in exercices/02_logistic_map"
  },
  {
    "objectID": "index.html#logistic-map-solution",
    "href": "index.html#logistic-map-solution",
    "title": "Scientific C for programmers",
    "section": "Logistic map: solution",
    "text": "Logistic map: solution\ndouble update_population(double current_population, double growth_rate) {\n    return growth_rate * current_population * (1.0 - current_population);\n}\n\nA function can accept multiple typed arguments\nA function can at most return 1 typed value\nMathematical expressions should be fairly intuitive\n\n    printf(\"Please enter the initial population: \");\n    scanf(\"%lf\", &current_population);\n\nInput can be read interactively with scanf\n\nBe careful, you should thoroughly check input"
  },
  {
    "objectID": "index.html#logistic-map-discussion",
    "href": "index.html#logistic-map-discussion",
    "title": "Scientific C for programmers",
    "section": "Logistic map: discussion",
    "text": "Logistic map: discussion\n\nComparison of two populations with slightly different initial populations (\\(r=3.8\\))\nInitially, two populations stay relatively close\nAfter a certain time they completely decorrelate\n\nExample of a chaotic system"
  },
  {
    "objectID": "index.html#outline-2",
    "href": "index.html#outline-2",
    "title": "Scientific C for programmers",
    "section": "Outline",
    "text": "Outline\n\n\n\nDay 1\n\n\n\nIntroduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\nDay 2\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\nDay 3\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\nDay 4\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "index.html#data-types-operators-and-expressions-1",
    "href": "index.html#data-types-operators-and-expressions-1",
    "title": "Scientific C for programmers",
    "section": "Data types, operators and expressions 1 2",
    "text": "Data types, operators and expressions 1 2\n\nVariables are the basic data objects manipulated in a C program\nC is statically typed: a variable is of a specific type defined at compile time\nC allows manipulation of variables by expressions with operators\n\nKernighan and Ritchie, Chapter 2, Types, operators and expressionsAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#the-very-basics",
    "href": "index.html#the-very-basics",
    "title": "Scientific C for programmers",
    "section": "The very basics",
    "text": "The very basics\n\n\n\nC statements 1 end with a semicolon\nBraces {} are used to group statements into a code block\nWhitespace is mostly ignored, allows to improve readability\nCompiler ignores what comes after // and between /* and */\n\n\nint a = 10;\nif (a &gt; 0) {\n    b = 2; // Single-line comment\n    c = 3;\n}\n/* Multi-line\n   comment */\n\nA statement is roughly a programming instruction, something to do"
  },
  {
    "objectID": "index.html#names-of-data-objects-in-c",
    "href": "index.html#names-of-data-objects-in-c",
    "title": "Scientific C for programmers",
    "section": "Names of data objects in C",
    "text": "Names of data objects in C\n\nare case sensitive\nconsist of {A,...,Z,a,...,z,_,0,...,9}\nstart with {A,...,Z,a,...,z,_}\ncan have any length, but at most:\n\nvariables: 31 significant, 64 for C99+\nfunctions: 6 significant1, 32 for C99+\n\ncannot be reserved words such as if, while, char, int, …\n\nguaranteed by standard, nowadays most compilers allow longer lengths"
  },
  {
    "objectID": "index.html#conventions-for-names",
    "href": "index.html#conventions-for-names",
    "title": "Scientific C for programmers",
    "section": "Conventions for names",
    "text": "Conventions for names\n\nvariables, functions: start with lowercase\nconstants, type names: start with uppercase\nnames reflect semantics of entity!\n\nvariables with very small scope have a short name\n\ncamelCase (e.g., nrOfRuns) or underscores nr_of_runs\n\n\n\n\n\n\n\nTip\n\n\nTry to be consistent within a project. If you might share code with others, try to stick to a generally accepted code style, e.g. the GNU coding standard"
  },
  {
    "objectID": "index.html#overview-of-data-types",
    "href": "index.html#overview-of-data-types",
    "title": "Scientific C for programmers",
    "section": "Overview of data types",
    "text": "Overview of data types\n\nchar: single character\nint: integer, allows qualifiers (signed, long, …)\nfloat/double/long double: real numbers\nenum: list of constants\nstruct: structure, group of related variables"
  },
  {
    "objectID": "index.html#characters",
    "href": "index.html#characters",
    "title": "Scientific C for programmers",
    "section": "Characters",
    "text": "Characters\n\na char holds 1 character of the local character set\nusually 1 byte, check with the sizeof operator\nlimits are defined in limits.h header as CHAR_MIN and CHAR_MAX\nchar can be signed or unsigned\n\nalmost always irrelevant, just use char\n\nExample: char myChar = 'b';\n\n\"b\" is a string (=array of chars)!"
  },
  {
    "objectID": "index.html#special-characters-are-escaped-with",
    "href": "index.html#special-characters-are-escaped-with",
    "title": "Scientific C for programmers",
    "section": "Special characters are escaped with \\",
    "text": "Special characters are escaped with \\\n\n'\\a': bell\n'\\n': new line\n'\\r': carriage return\n'\\t': horizontal tab\n'\\\\': backslash\n'\\'': single quote\n'\\\"': double quote\n'\\0': null character (terminates strings)"
  },
  {
    "objectID": "index.html#strings",
    "href": "index.html#strings",
    "title": "Scientific C for programmers",
    "section": "Strings?",
    "text": "Strings?\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nThe second example is a character pointer, we discuss pointers later on\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "index.html#integers",
    "href": "index.html#integers",
    "title": "Scientific C for programmers",
    "section": "Integers",
    "text": "Integers\n\nint: typically 4 bytes, offers \\(2^{32}\\) distinct values\nmodifiers:\n\nunsigned int: only non-negative integers, natural for array indices\nshort int/long int/long long int: different ranges compared to plain int, can be combined with unsigned\n\n\n\n\n\n\n\n\nTip\n\n\nThe range of int can be a limitation in practice, think about the range you need and choose the appropriate type."
  },
  {
    "objectID": "index.html#fixed-size-integers",
    "href": "index.html#fixed-size-integers",
    "title": "Scientific C for programmers",
    "section": "Fixed-size integers",
    "text": "Fixed-size integers\nThe C standard only imposes a minimal range for integers:\n\nFor example, int should at least cover \\([−32767, +32767]\\)\nSome platforms provide larger range =&gt; code is potentially platform dependent\n\nIf you need a fixed range:\n\nInclude the stdint.h header\nUse uint8_t, int16_t, …, which provide exactly the specified number of bits"
  },
  {
    "objectID": "index.html#real-numbers",
    "href": "index.html#real-numbers",
    "title": "Scientific C for programmers",
    "section": "Real numbers",
    "text": "Real numbers\n\n\n\nReal numbers are represented in a computer in a format very similar to exponential notation1:\nComputer uses binary representation, e.g., the IEEE SP standard:\n\nExponent determines range\nMantissa determines precision\n\n\n\n \n\nnot part of the C standard, but quite universal"
  },
  {
    "objectID": "index.html#double-precision",
    "href": "index.html#double-precision",
    "title": "Scientific C for programmers",
    "section": "Double precision",
    "text": "Double precision\n\n\n\n\n\na double is usually 8 bytes and gives about 15 decimal digit precision\nthe float.h header provides:\n\nDBL_MAX: largest positive double\nDBL_MIN: smallest positive double\nDBL_EPSILON: difference between 1.0 and next representable value (\\(\\approx\\) machine precision)\nBLD_DIG: number of significant decimal digits"
  },
  {
    "objectID": "index.html#other-floating-point-representations",
    "href": "index.html#other-floating-point-representations",
    "title": "Scientific C for programmers",
    "section": "Other floating-point representations",
    "text": "Other floating-point representations\n\ndouble: most often used in science\nfloat: half the number of bits compared to double, usually 7 decimal digit precision\nlong double: usually larger range than double, not used often\n\n\n\n\n\n\n\nNote\n\n\nIn deep learning, reduced-precision formats (FP16, FP8) are often used. Only dedicated devices like GPUs give hardware support."
  },
  {
    "objectID": "index.html#enumeration",
    "href": "index.html#enumeration",
    "title": "Scientific C for programmers",
    "section": "Enumeration",
    "text": "Enumeration\n\nenum makes it convenient to refer to constants symbolically\nUsing automatic integer numbering:\n\nenum Level = {LOW, MEDIUM, HIGH};\nenum Level myLevel = MEDIUM; // myLevel will be 1\n\nUsing custom values:\n\nenum Pieces = {King = 'K', Queen = 'Q', Rook = 'R', Bishop = 'B', Knight = 'N'};\nenum Pieces myPiece = Bishop; // myPiece will be 'B'"
  },
  {
    "objectID": "index.html#type-conversion",
    "href": "index.html#type-conversion",
    "title": "Scientific C for programmers",
    "section": "Type conversion",
    "text": "Type conversion\n\nIn constants, use suffix, e.g. 123456789L is a long int\nIn expressions, automatic conversion to largest type, e.g. 5/9.0 is interpreted as 5.0/9.0\nExplicit casting with brackets, e.g. (int) 5.3 becomes the int 5 (information is lost)"
  },
  {
    "objectID": "index.html#accidental-type-conversion",
    "href": "index.html#accidental-type-conversion",
    "title": "Scientific C for programmers",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nWhat do you expect the following code will do?\n\ndouble a = -1.6e5;\nif (abs(a) &gt;= 0) {\n    printf(\"a is positive\\n\");\n}\nelse {\n    printf(\"a is strictly negative\\n\");\n}    \n\n\nBehaviour is unexpected?\n\n$ gcc main.c -o main\n$ ./main\na is positive"
  },
  {
    "objectID": "index.html#accidental-type-conversion-1",
    "href": "index.html#accidental-type-conversion-1",
    "title": "Scientific C for programmers",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nCompilation with -Wconversion flags provide a hint\n\n$ gcc -Wconversion main.c -o main\nmain.c: In function ‘main’:\nmain.c:6:13: warning: conversion from ‘double’ to ‘int’ may change value [-Wfloat-conversion]\n    6 |     if (abs(a) &gt;= 0) {\n\n\nThe abs function is for int, double a was silently converted\nSolution: use the fabs function\n\ndouble a = -1.6e5;\nif (fabs(a) &gt;= 0) {\n    printf(\"a is positive\\n\");\n}\nelse {\n    printf(\"a is strictly negative\\n\");\n}"
  },
  {
    "objectID": "index.html#variable-declaration",
    "href": "index.html#variable-declaration",
    "title": "Scientific C for programmers",
    "section": "Variable declaration",
    "text": "Variable declaration\n\nC is statically typed, each variable has to be declared with type information: int a, b;\nCan be combined with an assignmnent, but no automatic initalization:\n\ndouble x = 3.2, y;\ndouble z = sqrt(2.0);\n\nConstants cannot be modified during runtime, must be assigned on declaration: const int MINUTESPERHOUR = 60;\n\nConvention: names of constants are capitalized"
  },
  {
    "objectID": "index.html#booleans",
    "href": "index.html#booleans",
    "title": "Scientific C for programmers",
    "section": "Booleans",
    "text": "Booleans\n\nThe original C89 standard does not have a boolean type\n\ntrue: non-zero integer, non-NULL pointer\nflase: zero, NULL pointer\n\nThe C99 standard adds the bool type and true/false keywords (after including &lt;stdbool.h&gt;)\nThe C23 standard provides booleans by default\nYou can get by with the C89 approach, dedicated bool type might be somewhat more efficient in some cases"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes",
    "href": "index.html#exercise-data-type-sizes",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes",
    "text": "Exercise: data type sizes\nGoal:\n\nPrint information about sizes and ranges of several types\n\nLearning outcomes:\n\nUnderstand C data types\n\nInstructions:\n\nExtend the program provided in exercises/04_data_type_sizes to print information about more types and ranges\nExplain the relation between sizes and ranges"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes-solution",
    "href": "index.html#exercise-data-type-sizes-solution",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The size of int is %zu bytes; it ranges from %d to %d\\n\",\n       sizeof(int), INT_MIN, INT_MAX);\nprintf(\"The size of unsigned long int is %zu bytes; its max is %lu\\n\",\n       sizeof(unsigned long int), ULONG_MAX);\nOutput:\nThe size of int is 4 bytes; it ranges from -2147483648 to 2147483647\nThe size of unsigned long int is 8 bytes; its max is 18446744073709551615\n\n4 bytes = 32 bits: int is in \\([-2^{31}, 2^{31}-1]\\)\n8 bytes = 64 bits: unsigned long int is in \\([0, 2^{64}-1]\\)"
  },
  {
    "objectID": "index.html#exercise-data-type-sizes-solution-1",
    "href": "index.html#exercise-data-type-sizes-solution-1",
    "title": "Scientific C for programmers",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The largest double that can be represented is %6.1e\\n\", DBL_MAX);\nprintf(\"The smallest positive double that can be represented is %6.1e\\n\", DBL_MIN);\nprintf(\"The machine epsilon is %6.1e\\n\", DBL_EPSILON);\nprintf(\"The number of digits is %d\\n\", DBL_DIG);\nOutput:\nThe largest double that can be represented is 1.8e+308\nThe smallest positive double that can be represented is 2.2e-308\nThe machine epsilon is 2.2e-16\nThe number of digits is 15\n\nExponent has 11 bits -&gt; in range [-1023,1024] -&gt; \\(2^{1024} \\approx 10^{308}\\)\nSignificant has 52 bits -&gt; 52 significant digits in binary -&gt; \\(52 \\log_{10} 2 \\approx 15.6\\)"
  },
  {
    "objectID": "index.html#overview-of-operators",
    "href": "index.html#overview-of-operators",
    "title": "Scientific C for programmers",
    "section": "Overview of operators",
    "text": "Overview of operators\n\narithmetic operators\nrelational operators\nlogical operators\nbitwise operators\nassignment operators\nincremental operators\nconditional operator"
  },
  {
    "objectID": "index.html#arithmetic-operators",
    "href": "index.html#arithmetic-operators",
    "title": "Scientific C for programmers",
    "section": "Arithmetic operators",
    "text": "Arithmetic operators\n\naddition, subtraction: +, -\nmultiplication, division: *, /\n\ninteger division truncates fractional part, 5/9 equals 0\n\nmodulo (only for integers): %\n*, /, % take precedence over + and -\n\n\n\n\n\n\n\n\nTip\n\n\nUse brackets for clarity instead of relying on precedence rules"
  },
  {
    "objectID": "index.html#relational-operators",
    "href": "index.html#relational-operators",
    "title": "Scientific C for programmers",
    "section": "Relational operators",
    "text": "Relational operators\n\norder:\n\nsmaller, smaller or equal: &lt;, &lt;=\nlarger, larger or equal: &gt;, &gt;=\n\nequality:\n\nequal to, not equal to: ==, !=\n\n\n\n\n\n\n\n\n\nTip\n\n\nBe careful when comparing doubles, e.g. pow(sqrt(5.0), 2) == 5.0 is false!"
  },
  {
    "objectID": "index.html#logical-operators",
    "href": "index.html#logical-operators",
    "title": "Scientific C for programmers",
    "section": "Logical operators",
    "text": "Logical operators\n\nlogical and, logical or: &&, ||\n\nevaluated left to right with early stopping, (i &lt; N) && (a[i] &gt; 0) will not access a[i] unless i &lt; N\n\nunary negation !\n\nconverts non-zero operand into 0 and zero operand into 1\nzero is false, non-zero is true"
  },
  {
    "objectID": "index.html#incrementdecrement-operators",
    "href": "index.html#incrementdecrement-operators",
    "title": "Scientific C for programmers",
    "section": "Increment/decrement operators",
    "text": "Increment/decrement operators\n\nC specific shorthand notation\n\nincrement: i = i + 1; is the same as i++; or ++i;\ndecrement: i = i - 1; is the same as i--; or --i;\n\npost/pre increment matters when value is used, for example in assignment:\n\nint j = ++i;: first increment i, then assign it to j\nint j = i++;: first assign i to j, then increment j\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe name C++ can be interpreted as “incremented C”"
  },
  {
    "objectID": "index.html#bitwise-operators",
    "href": "index.html#bitwise-operators",
    "title": "Scientific C for programmers",
    "section": "Bitwise operators",
    "text": "Bitwise operators\nManipulate bits of integers (signed and unsigned char, int, long, …)\n\nBitwise and, or, xor: &, |, ^\n\n0011 & 0101 -&gt; 0001\n\nShift bits left, right: &lt;&lt;, &gt;&gt;\n\n0111 1000 &gt;&gt; 2 -&gt; xx01 1110\nx is zero if unsigned, undefined otherwise\n\nOne’s complement: ~\n\n~1101 -&gt; 0010\n\n\n\n\n\n\n\n\n\nTip\n\n\nBitwise operators are powerful, but also tedious. Use with care!"
  },
  {
    "objectID": "index.html#assignment-operators",
    "href": "index.html#assignment-operators",
    "title": "Scientific C for programmers",
    "section": "Assignment operators",
    "text": "Assignment operators\n\nSimple assignment is done with = (do not confuse with comparison ==)\nAssignment operators allow to compress statements:\n\ni = i + 2; is the same as i += 2;\nMost binary operators have a corresponding assignment operator\nMore concise, but often more intuitive as well"
  },
  {
    "objectID": "index.html#conditional-expression",
    "href": "index.html#conditional-expression",
    "title": "Scientific C for programmers",
    "section": "Conditional expression",
    "text": "Conditional expression\nConditional expression is a ternary operator condition ? expr_true : expr_false\n\nEvaluate the condition\n\nIf true, evaluate expr_true as the result\nIf false, evaluate expr_false as the result\n\n\n// z = max(a, b)\nif (a &gt; b) {\n    z = a;\n} else {\n    z = b;\n}\n// same thing but shorter\nz = (a &gt; b) ? a : b;"
  },
  {
    "objectID": "index.html#precedence-and-associativity",
    "href": "index.html#precedence-and-associativity",
    "title": "Scientific C for programmers",
    "section": "Precedence and associativity",
    "text": "Precedence and associativity\n\nK&R provide a table with precedence rules (2.12)\n\nMake your code readable and maintable by using brackets\n\nC does not specify order of evaluation for most operators:\n\norder can even depend on compiler options\nx = f() + g(); might evaluate g before f\n\nimportant if g alters variable used by f\n\na + b + c; could be (a + b) + c or a + (b + c)\n\nfloating-point arithmetic does not preserve mathematical associativity"
  },
  {
    "objectID": "index.html#exercise-operators",
    "href": "index.html#exercise-operators",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators",
    "text": "Exercise: operators\nGoal: Solve a few operator-related programming questions Learning outcome: Understand the basics of C operators Instructions: See exercises/05_operators\n\n\n\n\n\n\nTip\n\n\nThis exercise uses the assert() function to check your solution. This function can be useful for debugging, but should not be used in production code.\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can easily “cheat” the assert() statements, but that is not the intention of course."
  },
  {
    "objectID": "index.html#exercise-operators-solution",
    "href": "index.html#exercise-operators-solution",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\nImplement a function that returns if a year is a leap year: easy to achieve by combining modulo and logical operators.\nint isLeapYear(int year) {\n    /* Return 1 if year is a leap year and return 0 otherwise\n       A year is a leap year if:\n       - it is divisible by 4 but not by 100 OR\n       - it is disisible by 400\n    */\n    if ( (year % 4 == 0 && year % 100 != 0) || (year % 400) == 0) return 1;\n    else return 0;\n}"
  },
  {
    "objectID": "index.html#exercise-operators-solution-1",
    "href": "index.html#exercise-operators-solution-1",
    "title": "Scientific C for programmers",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\n    // Multiply i by 8 and store it in j, but without making use of the * operator\n    // Hint: use a bitwise operator\n    int i = 5;\n    int j = i &lt;&lt; 3;\n    assert(j == 40);\n\n    // Compute c as the minimal value of a and b without using an if-else statement\n    int a = 126;\n    int b = 45;\n    int c = (a &lt; b) ? a : b;\n    assert(c == b);"
  },
  {
    "objectID": "index.html#control-flow-1",
    "href": "index.html#control-flow-1",
    "title": "Scientific C for programmers",
    "section": "Control flow 1 2",
    "text": "Control flow 1 2\n\nControl flow statements specify order in which computations are performed\nOften multiple ways to achieve the same end result\n\nInvolves an element of personal preference\nOne way might provide faster code than another\n\n\nKernighan and Ritchie, Chapter 3, Control FlowAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#statements-and-blocks",
    "href": "index.html#statements-and-blocks",
    "title": "Scientific C for programmers",
    "section": "Statements and blocks",
    "text": "Statements and blocks\n\nUse ; to terminate a statement\nGroup multiple statements in blocks with braces {}\n\nblocks can be nested\nvariables can be redeclared and have block scope\n{\n   int i = 3; // from here, i is 3\n   {\n      int i = 5; //from here, i is 5\n   }\n   // from here, i is 3 again\n}\n\n\n\n\n\n\n\n\nTip\n\n\nUse blocks to make your code more readable, unless you want to participate in the The International Obfuscated C Code Contest"
  },
  {
    "objectID": "index.html#if-else-statement",
    "href": "index.html#if-else-statement",
    "title": "Scientific C for programmers",
    "section": "if-else statement",
    "text": "if-else statement\n\n\nif (expression != 0) {\n    statement_true;\n} else {\n    statement_false;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression != 0} --&gt;|true| C[statement_true]\n    B --&gt;|false| E[statement_false]\n\n\n\n\n\n\n\n\nThe else clause is optional\nFor a single-line statement, braces are optional\nIndentation is only for style, but helps for readability\nif (expression) is the same as if (expression != 0)"
  },
  {
    "objectID": "index.html#else-if-statement",
    "href": "index.html#else-if-statement",
    "title": "Scientific C for programmers",
    "section": "else-if statement",
    "text": "else-if statement\n\n\nif (expression1) {\n    statement1;\n} else if (expression2) {\n    statement2;\n} else {\n    statement3;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression1} --&gt;|true| C[statement1]\n    B --&gt;|false| E{expression2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n\n\n\n\n\n\n\n\nGeneral way to write a multi-way decision\nThe else clause is optional"
  },
  {
    "objectID": "index.html#switch",
    "href": "index.html#switch",
    "title": "Scientific C for programmers",
    "section": "Switch",
    "text": "Switch\n\n\nswitch (expression) {\n    case const-expr1: statements1\n    case const-expr2: statements2\n    default: statements3\n}\n\n\n\n\n\n\nflowchart LR\n    B{e == const-expr1} --&gt;|true| C[statements1]\n    B --&gt;|false| E{e == const-expr2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n    C --&gt; E\n\n\n\n\n\n\n\n\nMulti-way decision to branch based on comparison with constant integer values\nFall through: execution goes to next case\n\nYou can leave a switch with break or return\n\nCase expressions must be constant and unique\ndefault is optional"
  },
  {
    "objectID": "index.html#switch-example",
    "href": "index.html#switch-example",
    "title": "Scientific C for programmers",
    "section": "Switch example",
    "text": "Switch example\n// Count occurence of odd and even digits in a string\nswitch (c) {\ncase '0': case '2': case '4': case '6': case '8':\n    neven++;\n    break;\ncase '1': case '3': case '5': case '7': case '9':\n    nodd++;\n    break;"
  },
  {
    "objectID": "index.html#for-loop",
    "href": "index.html#for-loop",
    "title": "Scientific C for programmers",
    "section": "For loop",
    "text": "For loop\n// General for loop\nfor (expr1; expr2; expr3) {\n    statements;\n}\n// Most common usage\nfor (int i = 0; i &lt; N; i++) {\n    statements;\n}\n\nexpr1: executed once at start, typically for initialization\nexpr2: evaluated at start of each iteration, for loop stops if false\nexpr3: evaluated at end of each iteration"
  },
  {
    "objectID": "index.html#for-loop-1",
    "href": "index.html#for-loop-1",
    "title": "Scientific C for programmers",
    "section": "For loop",
    "text": "For loop\n\nShould be used when number of repetitions is known or computed\nEach expression is optional, for (;;) {} is an infinite loop\nbreak in loop body terminates loop\ncontinue in loop body goes to next iteration"
  },
  {
    "objectID": "index.html#while-loop",
    "href": "index.html#while-loop",
    "title": "Scientific C for programmers",
    "section": "While loop",
    "text": "While loop\n// General while loop\nwhile (expression) {\n    statements;\n}\n// Check if str contains c\nwhile (i &lt; strlen(str) && !found) {\n    if (str[i] == c)\n        found = True;\n    else\n        i++;\n}\n\nstatements are executed zero or more times, as long as expression is true\nshould be used when number of repetitions is unknown"
  },
  {
    "objectID": "index.html#do-while-loop",
    "href": "index.html#do-while-loop",
    "title": "Scientific C for programmers",
    "section": "Do-While loop",
    "text": "Do-While loop\n// General while loop\ndo {\n    statements;\n} while (expression);\n\nstatements are executed at least once, until expression is false\nSimilar to while loop, but expression is evaluated at end of iteration"
  },
  {
    "objectID": "index.html#goto-and-labels",
    "href": "index.html#goto-and-labels",
    "title": "Scientific C for programmers",
    "section": "Goto and labels",
    "text": "Goto and labels\ngoto label;\n...\nlabel:\n    statements;\n\ngoto allows to branch to a specified label\nnever necessary, often makes code hard to read\neven C inventors discourage it, do do not use it"
  },
  {
    "objectID": "index.html#functions-and-program-structure-1",
    "href": "index.html#functions-and-program-structure-1",
    "title": "Scientific C for programmers",
    "section": "Functions and Program Structure 1 2",
    "text": "Functions and Program Structure 1 2\n\nFunctions break large computing tasks into smaller ones\nHelp to bring structure into code\nHide implementations details\nMake it easier to reuse existing code\n\nKernighan and Ritchie, Chapter 4, Functions and Program StructureAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#basics-of-functions",
    "href": "index.html#basics-of-functions",
    "title": "Scientific C for programmers",
    "section": "Basics of functions",
    "text": "Basics of functions\n// General function definition\nreturn-type function-name(type1 arg1, type2 arg2, ...) {\n    declarations and statements;\n    return expression;\n} \n\nA function can have no arguments: int myFunction(void);\nA function can return nothing: void myFunction(int A);\n\nNo return statement in body required\n\nThe compiler requires a function to be known before it can process a call\n\nDeclare the function: return-type function-name(type1 arg1, type2 arg2);\nDeclaration is promise to provide implementation later"
  },
  {
    "objectID": "index.html#function-examples",
    "href": "index.html#function-examples",
    "title": "Scientific C for programmers",
    "section": "Function examples",
    "text": "Function examples\n// The most minimal (useless) function\ndummy() {}\n// Compute the square of a floating-point number\ndouble square(double a) {\n    return a * a;\n}"
  },
  {
    "objectID": "index.html#return-statements",
    "href": "index.html#return-statements",
    "title": "Scientific C for programmers",
    "section": "Return statement(s)",
    "text": "Return statement(s)\n\nA return statements returns a value (or nothing), but also returns control to the caller\nA function can have multiple return statements, but at most one is executed in each call\n\nint index(char c, char s[]) {\n    unsigned i;\n    for (i = 0; i &lt; strlen(s); i++)\n        if (s[i] == c)\n            return i;\n    return -1;\n}\n\nThe returned expression is converted to function’s return type\n\n// Valid, but dubious\nint returnInt() {\n    double a = 5.0;\n    return a;\n}"
  },
  {
    "objectID": "index.html#more-on-functions",
    "href": "index.html#more-on-functions",
    "title": "Scientific C for programmers",
    "section": "More on functions",
    "text": "More on functions\n\nmain function is special: always the entry point of the program\nC passes arguments by value, inside the function a local copy is made\n\nchanges to values are invisible outside of function\npointers (see Day 3) allow to circumvent limitations\n\nA function can only return one variable\n\npack multiple values in a struct\nuse pointers (see Day 3) to pass out values\nexternal variables (usually a bad idea)"
  },
  {
    "objectID": "index.html#external-variables",
    "href": "index.html#external-variables",
    "title": "Scientific C for programmers",
    "section": "External variables",
    "text": "External variables\n\ninternal variable: defined inside function\n\nlifetime and scope limited to function call\n\nexternal variable: defined outside function\n\nbigger scope: globally accessible inside any function\nlonger lifetime: keeps value between calls\nalternative for long list of function arguments\n\n\n\n\n\n\n\n\nTip\n\n\nExternal variables typically make code less reusable, so generally they should be avoided"
  },
  {
    "objectID": "index.html#external-variables-example",
    "href": "index.html#external-variables-example",
    "title": "Scientific C for programmers",
    "section": "External variables example",
    "text": "External variables example\n#include &lt;stdio.h&gt;\nint external_variable;\n\nvoid someFunction(void) {\n    printf(\"In someFunction, external variable is %d\\n\", external_variable);\n    external_variable++;\n    }\n\nint main(void) {\n    external_variable = 1;\n    someFunction();\n    printf(\"in main, external variable is %d\\n\", external_variable);\n    return 0;\n}\n\nValue of external_variable persists:\n$ ./a.out\nIn someFunction, external variable is 1\nin main, external variable is 2"
  },
  {
    "objectID": "index.html#scope",
    "href": "index.html#scope",
    "title": "Scientific C for programmers",
    "section": "Scope",
    "text": "Scope\nThe scope of a variable or function is the part of the program where the variable of function can be used\n\nLocal variables\n\nFrom definition until end of block\nIncludes function arguments\n\nExternal variables\n\nFrom definition until end of file\nCan be used in multiple files by declaring with extern (not covered)"
  },
  {
    "objectID": "index.html#header-files-and-build-systems",
    "href": "index.html#header-files-and-build-systems",
    "title": "Scientific C for programmers",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nSo far: small programs in one .c file: easy to compile\nLarger projects: many source files\n\nOrder of compilation can matter because of dependencies\nDifficult to remember compilation commands (linking and flags)\nEditing one file does not require recompiling entirely"
  },
  {
    "objectID": "index.html#header-files-and-build-systems-1",
    "href": "index.html#header-files-and-build-systems-1",
    "title": "Scientific C for programmers",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nUse header files:\n\n.h files containing shared definitions and declarations\n#include \"example.h\" or #include &lt;stdio.h&gt;\n\nUse a build system (not covered here)\n\nMakefile (https://github.com/hpcleuven/Makefile-intro]\nCMake (https://github.com/hpcleuven/CMake-intro]\nMeson\n\n\n\n\n\n\n\n\nTip\n\n\nMost exercises can be compiled by running the make command in the exercise directory"
  },
  {
    "objectID": "index.html#static-variables",
    "href": "index.html#static-variables",
    "title": "Scientific C for programmers",
    "section": "Static variables",
    "text": "Static variables\n\nInternal variables with static declaration\n\nRemain in existing across function calls\nProvide permanent private storage within a single function\n\n\nunsigned uniqueIdentifier() {\n    // id Indicates how many times the function has been called\n    static unsigned id = 0;\n    return id++;\n}"
  },
  {
    "objectID": "index.html#static-functions",
    "href": "index.html#static-functions",
    "title": "Scientific C for programmers",
    "section": "Static functions",
    "text": "Static functions\n\nFunctions with static declaration\n\nA static function is only visible within the file where it is declared\nA normal function is visible everywhere\n\nExternal variables with static declaration\n\nCan only be used in file where they are declared"
  },
  {
    "objectID": "index.html#initialization",
    "href": "index.html#initialization",
    "title": "Scientific C for programmers",
    "section": "Initialization",
    "text": "Initialization\n\nAutomatic internal variables\n\nWithout explicit initialization (such as int x;), values are “garbage”\nInitial value can come from expression: double y = sqrt(6.0);\nRe-initialized each time the block is entered\nCompiler can warn about uninitialized variables\n\nE.g., -Wuninitialized for gcc (not perfect)"
  },
  {
    "objectID": "index.html#initialization-1",
    "href": "index.html#initialization-1",
    "title": "Scientific C for programmers",
    "section": "Initialization",
    "text": "Initialization\n\nStatic internal variables\n\nGuaranteed to initialize to zero\nInitialization first time it is encountered\nExpression or constant expression\n\nExternal variables\n\nGuaranteed to initialize to zero\nInitialized at start of execution\nConstant expression"
  },
  {
    "objectID": "index.html#recursion",
    "href": "index.html#recursion",
    "title": "Scientific C for programmers",
    "section": "Recursion",
    "text": "Recursion\nFunctions can call themselves (i.e. recursion)\nunsigned long fac(unsigned long n) {\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n*fac(n-1);\n}\n\nEach function call has overhead (pushing frame on stack)\nOften not the fastest or lowest footprint\n\nDeep recursion levels can even cause stack overflow\n\nOften closer to mathematical description"
  },
  {
    "objectID": "index.html#the-c-preprocessor",
    "href": "index.html#the-c-preprocessor",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA few statements are processed before compilation\n\n#include \"filename\" or include &lt;filename&gt;\n#define name replacement\nconditional inclusions with #if, #elif, #else, #endif\n\nIn your head, do not interpret these as C code, but imagine their impact on the code presented to compiler."
  },
  {
    "objectID": "index.html#the-c-preprocessor-1",
    "href": "index.html#the-c-preprocessor-1",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\n\n#include \"myheader.h\": includes content from myheader.h in current directory verbatim\n#include &lt;math.h&gt;: includes content from math.h in include directory verbatim\nguarantees all source files have same definitions and variable declarations"
  },
  {
    "objectID": "index.html#the-c-preprocessor-2",
    "href": "index.html#the-c-preprocessor-2",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA macro substitution replaces each occurrence of a name with a replacement, for example #define max(A, B) ((A) &gt; (B) ? (A) : (B))\n\nEvery occurence of max(x, y) will be replaced\nUse with care, can make code more readable, but also obfuscate when reading code for the first time\nMacros avoid overhead associated with function call"
  },
  {
    "objectID": "index.html#the-c-preprocessor-3",
    "href": "index.html#the-c-preprocessor-3",
    "title": "Scientific C for programmers",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nConditional inclusion gives control over preprocessor statements\n// Prevent redefinition\n#ifndef FOUR_PI\n#define FOUR_PI 4 * M_PI\n#endif\n// Use SYSTEM to decide which header is included\n#if SYSTEM == SYSV\n    #define HDR \"sysv.h\"\n#elif SYSTEM == MSDOS\n    #define HDR \"msdos.h\"\n#else\n    #define HDR \"default.h\"\n#endif"
  },
  {
    "objectID": "index.html#variadic-functions",
    "href": "index.html#variadic-functions",
    "title": "Scientific C for programmers",
    "section": "Variadic functions",
    "text": "Variadic functions\nTODO"
  },
  {
    "objectID": "index.html#compute-pi-using-monte-carlo",
    "href": "index.html#compute-pi-using-monte-carlo",
    "title": "Scientific C for programmers",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo\nGoal:\n\nWrite a program that approximates \\(\\pi\\) by using a Monte Carlo algorithm\n\nLearning outcomes:\n\nWrite a loop and use control flow\n\nInstructions:\n\nThe quarter unit circle in the first quadrant has area \\(\\frac{\\pi}{4}\\). Approximate this area by generating uniformly distributed points in \\([0,1] \\times [0,1]\\) (get_random_double is provided) and selecting points inside a unit circle\nHow does the estimate converge with the number of samples?\nSee exercices/06_mc_pi."
  },
  {
    "objectID": "index.html#fibonacci",
    "href": "index.html#fibonacci",
    "title": "Scientific C for programmers",
    "section": "Fibonacci",
    "text": "Fibonacci\nGoal:\n\nWrite a program to compute the Fibonacci sequence\n\nLearning outcome:\n\nWrite (recursive) functions\n\nInstructions:\n\nThe Fibonacci sequence is defined by \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) and \\(F_0=0, F_1=1\\)\nCompute the nth element by using a recursive function\nTry to trigger a stack overflow for large n\nWrite a function without recursion\nSee exercises/07_recursion"
  },
  {
    "objectID": "index.html#pointers-and-arrays-1",
    "href": "index.html#pointers-and-arrays-1",
    "title": "Scientific C for programmers",
    "section": "Pointers and arrays 1 2",
    "text": "Pointers and arrays 1 2\n\nA pointer is a variable that contains the address of a variable\nThe & operator gives the address of an object\nThe * operator dereferences a pointer\nDeclarations like int *px indicate that px is a pointer and *px is an int\n\nKernighan and Ritchie, Chapter 5, Pointers and arraysAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#virtual-memory-layout",
    "href": "index.html#virtual-memory-layout",
    "title": "Scientific C for programmers",
    "section": "Virtual memory layout",
    "text": "Virtual memory layout\n\n\n\nVirtual memory looks like a table with two columns\n\nAddress column in hexadecimal format\nValue column in decimal format\nRemember that internally it’s all binary\nSome variables take up more than one address\nThe Variable column is just for mnemonics\n\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nint x\n0x0000\n42\n\n\nint y\n0x0004\n43\n\n\ndouble a\n0x0008\n12.6e10\n\n\ndouble a\n0x000c\n\n\n\nfloat b\n0x0010\n3.14"
  },
  {
    "objectID": "index.html#swapping-variables-naive-approach",
    "href": "index.html#swapping-variables-naive-approach",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: naive approach",
    "text": "Swapping variables: naive approach\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#working-with-large-arrays",
    "href": "index.html#working-with-large-arrays",
    "title": "Scientific C for programmers",
    "section": "Working with large arrays",
    "text": "Working with large arrays\n\nSuppose you construct vectors using a struct (see later)\nYou want a function double innerProduct(struct vector v1, struct vector v2) that computes the inner product\nSince C uses pass-by-value, those objects would be copied when function is called\nMemory access is slow, this would give bad performance for large cases\n\n=&gt; This is also addressed by pointers"
  },
  {
    "objectID": "index.html#pointer-basics",
    "href": "index.html#pointer-basics",
    "title": "Scientific C for programmers",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nA pointer is a variable that contains the address of a variable\nPointer arguments allow modifying object in the calling function\nThere are different pointer types, depending on the object they point to\n\nint *px;\ndouble *pa;\n\n\n\n\n\n\n\n\nTip\n\n\nMnemonic: read int *px as *px is of type int. Sometimes people also use int* px to declare an integer pointer."
  },
  {
    "objectID": "index.html#pointer-basics-1",
    "href": "index.html#pointer-basics-1",
    "title": "Scientific C for programmers",
    "section": "Pointer basics",
    "text": "Pointer basics\n\nThe & operator gives the address of an object\nThe * operator dereferences a pointer\n\nint x = 1, y;\nint *px;\n\npx = &x; // px now points to x, i.e. it holds the address of x\ny = *px; // y now holds the value of the object px points to, i.e. y = 1\n*px = 10; // the value of the object px points to is set, i.e. x = 10"
  },
  {
    "objectID": "index.html#swapping-variables-pointers",
    "href": "index.html#swapping-variables-pointers",
    "title": "Scientific C for programmers",
    "section": "Swapping variables: pointers",
    "text": "Swapping variables: pointers\n\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n0x100\n\n\nb\n0x10C\n0x104\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "index.html#pointers-and-arrays-2",
    "href": "index.html#pointers-and-arrays-2",
    "title": "Scientific C for programmers",
    "section": "Pointers and arrays",
    "text": "Pointers and arrays\n\nAn array is a block of consecutive objects of a specified type\n\nint a[10]; declares 10 consecutive int objects\nThe i-th element can be accessed as a[i]\n\nPointers are a natural way to loop over arrays\n\nint a[10];\nint *pa;\npa = &a[0]; // pa points to first element of a\npa++; // pa now points to second element of a\n\n\n\n\n\n\nWarning\n\n\nWhen pointing to array elements, incrementing a pointer always means going to the next object irrespective of the object type!"
  },
  {
    "objectID": "index.html#array-indexing-sourcery",
    "href": "index.html#array-indexing-sourcery",
    "title": "Scientific C for programmers",
    "section": "Array indexing sourcery",
    "text": "Array indexing sourcery\n\nIn C, the name of an array is a synonym for the location of the initial element\n\nint *pa = &a[0] is identical to int *pa = a\n\nAccess to the i-th element a[i] is translated to *(a+i)\nBecause integer addition is a[i] is identical to i[a]!"
  },
  {
    "objectID": "index.html#arrays-as-function-arguments",
    "href": "index.html#arrays-as-function-arguments",
    "title": "Scientific C for programmers",
    "section": "Arrays as function arguments",
    "text": "Arrays as function arguments\n\nWhen passing an array to a function, the location of the initial element is passed\nWithin the called function, the corresponding local variable is a pointer\nYou can pass a part of an array to a function\n\nf(&a[2]) pass the subarray that starts at a[2]\n\n\n\n\n\n\n\n\nWarning\n\n\nYou cannot pass a slice of an array, the called function is responsible to respect the bounds of the array. This is one of the reasons why C programs are often considered at risk for unsafe memory management."
  },
  {
    "objectID": "index.html#character-pointers",
    "href": "index.html#character-pointers",
    "title": "Scientific C for programmers",
    "section": "Character pointers",
    "text": "Character pointers\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "index.html#dynamic-memory-allocation",
    "href": "index.html#dynamic-memory-allocation",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nThe C89 standard does not allow variable length arrays\n\nArray size must be known at compile time\nsize_t len = 5; int a[len]; is stricly speaking invalid\nSince C99 it is supported and many compilers allow it by default\n\nEven if you can have VLAs, there are some downsides\n\nAllocated on stack, so limited in size\nScope is local, similar as other variables\nVLA might be less efficient\n\n\n\n\n\n\n\n\nTip\n\n\nVariable length refers to the fact that length is only known at runtime, a variable length array remains of the same size during its lifetime."
  },
  {
    "objectID": "index.html#dynamic-memory-allocation-1",
    "href": "index.html#dynamic-memory-allocation-1",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n\nMemory for arrays can be dynamically allocated on the heap\n\nHeap is a large area of memory used at runtime\nSignature: void *malloc(size_t size);\nsize is in bytes: make use of sizeof\nreturns void pointer, cast it to correct pointer type\nif memory cannot be allocated, null pointer is returned\nalways free() the memory exactly once!\ncalloc: includes initializing to zero (so slower than malloc)"
  },
  {
    "objectID": "index.html#dynamic-memory-allocation-2",
    "href": "index.html#dynamic-memory-allocation-2",
    "title": "Scientific C for programmers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\n#include &lt;stdlib.h&gt;\nint main(int argc, char **argv) {\n    size_t len = atoi(argv[1]);\n    double *pa = (double *) malloc(len * sizeof(double));\n    if (pa == NULL) { return 1;}\n    free(pa);\n}"
  },
  {
    "objectID": "index.html#multidimensional-arrays",
    "href": "index.html#multidimensional-arrays",
    "title": "Scientific C for programmers",
    "section": "Multidimensional arrays",
    "text": "Multidimensional arrays\n\nC supports multidimensional arrays by using multiple []\n\nint matrix[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n\nIndexing is done with [i][j] (not [i,j])\n\nint x = matrix[1][2]\n\nC uses row-major storage: last dimension is fastest in memory"
  },
  {
    "objectID": "index.html#pointers-to-pointers",
    "href": "index.html#pointers-to-pointers",
    "title": "Scientific C for programmers",
    "section": "Pointers to pointers",
    "text": "Pointers to pointers\n\nA pointer is also a variable -&gt; another pointer can point to its address\nIn contrast to multidimensional arrays, we can now have irregular structures\nExample: storing an upper triangular matrix\n\ndouble **lower;\nlower = (double **)malloc( n * sizeof(double *))\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}\nfree(lower);"
  },
  {
    "objectID": "index.html#arrays-of-pointers",
    "href": "index.html#arrays-of-pointers",
    "title": "Scientific C for programmers",
    "section": "Arrays of pointers",
    "text": "Arrays of pointers\n\nBy now it should be clear pointers and arrays are very similar\nThe previous example as an array of pointers:\n\ndouble *lower[n];\nfor (int i=0; i&lt;n; i++) {\n    lower[i] = (double *)malloc( (n - i) * sizeof(double));\n}\n...\nfor (int i=0; i&lt;n; i++) {\n    free(lower[i]);\n}"
  },
  {
    "objectID": "index.html#pointers-to-function",
    "href": "index.html#pointers-to-function",
    "title": "Scientific C for programmers",
    "section": "Pointers to function",
    "text": "Pointers to function\n\nExample\n\nWhen \\(a\\) and \\(b\\) are close, the integral \\(\\int_a^{b} f(x) dx \\approx \\frac{1}{2} \\frac{f(a) + f(a)}{b-a}\\)\nThis rule can be written for any \\(f(x)\\) as:\n\n\ndouble trapezoidRule (double (*f)(double), double a, double b) {\n    return (b-a)*(f(a) + f(b))/2;\n}\ndouble trap = trapezoidRule(cos, 0, M_PI);"
  },
  {
    "objectID": "index.html#quadrature",
    "href": "index.html#quadrature",
    "title": "Scientific C for programmers",
    "section": "Quadrature",
    "text": "Quadrature\nGoal:\n\nWrite a program that can numerically integrate arbitrary functions\n\nLearning outcome:\n\nUse pointers to let functions operate on arrays and functions\n\nInstructions:\n\nWrite a function that allocates an array, with evenly spaced real numbers in a chosen interval as entries\nWrite a function that approximates the integral of sin and tan on the chosen interval\nSee exercises/08_quadrature"
  },
  {
    "objectID": "index.html#heat-equation",
    "href": "index.html#heat-equation",
    "title": "Scientific C for programmers",
    "section": "Heat equation",
    "text": "Heat equation\nGoal:\n\nWrite a program that solves the 2D heat equation\n\nLearning outcome:\n\nLearn to work with multi-dimensional arrays\n\nInstructions:\n\nSee exercises/09_heat_equation"
  },
  {
    "objectID": "index.html#structures-1",
    "href": "index.html#structures-1",
    "title": "Scientific C for programmers",
    "section": "Structures 1 2",
    "text": "Structures 1 2\n\nA structure is a collection of one or more variables\nMakes it convenient to organize and handle complicated data\nA very lightweight class (but do not call C object-oriented):\n\nNo inheritance\nNo class methods\n\n\nKernighan and Ritchie, Chapter 6, StructuresAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#structure-example",
    "href": "index.html#structure-example",
    "title": "Scientific C for programmers",
    "section": "Structure example",
    "text": "Structure example\n\nA structure is defined with struct, usually followed by a tag as a name\n\nstruct particle {\n    double x;\n    double y;\n    double z;\n    double mass;\n}\n\nThe variables named in the struct are members and can be accessed with the . operator"
  },
  {
    "objectID": "index.html#structure-example-1",
    "href": "index.html#structure-example-1",
    "title": "Scientific C for programmers",
    "section": "Structure example",
    "text": "Structure example\n\nA struct can be initialized directly or member-by-member\n\nstruct particle p1;\np1.x = 1.0;\np1.y = 2.0;\np1.z = 3.0;\np1.m = 1.000784;\nstruct particle p2 = {2.0, 4.0, 5.0, 4.002602};"
  },
  {
    "objectID": "index.html#structures-and-functions",
    "href": "index.html#structures-and-functions",
    "title": "Scientific C for programmers",
    "section": "Structures and functions",
    "text": "Structures and functions\n\nFunctions can operate on structures much the same way as basic types\n\nstruct particle centerOfMass(struct particle p1, struct particle p2) {\n    double mass = p1.m + p2.m;\n    struct particle com;\n    com.x = (p1.x * p1.m + p2.x * p2.m) / mass;\n    com.y = (p1.y * p1.m + p2.y * p2.m) / mass;\n    com.z = (p1.z * p1.m + p2.z * p2.m) / mass;\n    com.mass = mass\n    return com;\n}"
  },
  {
    "objectID": "index.html#arrays-of-structures",
    "href": "index.html#arrays-of-structures",
    "title": "Scientific C for programmers",
    "section": "Arrays of structures",
    "text": "Arrays of structures\n\nArrays can be made up of structs\n\n// Make an array with n particles\nstruct particle particles[n];\n\nDefined in this way, accessing all x coordinates would give strided memory access\n\nHaving a struct with arrays can be more efficient than an array of structs\nDepends on the specific application"
  },
  {
    "objectID": "index.html#structures-and-pointers",
    "href": "index.html#structures-and-pointers",
    "title": "Scientific C for programmers",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nStructures are variables, so you can point to their address\n\nvoid translateX(struct particle *p, double distance) {\n    (*p).x += distance;\n}\n\nA member of a pointer can be accessed with -&gt;\n\nIf p is a pointer to a struct particle, (*p).x is the same as p-&gt;x\n\n\nvoid translateX(struct particle *p, double distance) {\n    p-&gt;x += distance;\n}"
  },
  {
    "objectID": "index.html#structures-and-pointers-1",
    "href": "index.html#structures-and-pointers-1",
    "title": "Scientific C for programmers",
    "section": "Structures and pointers",
    "text": "Structures and pointers\n\nThe . and -&gt; operators have highest precedence:\n\n*p.x would be interpreted as *(p.x) (unwanted in our example)\nuse brackets to make your intention clear"
  },
  {
    "objectID": "index.html#self-referencing-structures-linked-list",
    "href": "index.html#self-referencing-structures-linked-list",
    "title": "Scientific C for programmers",
    "section": "Self-referencing structures: linked list",
    "text": "Self-referencing structures: linked list\n\nA member can have the same type as the structure it is a member of\nSelf-referencing structures are quite common: linked list, tree, …"
  },
  {
    "objectID": "index.html#linked-list",
    "href": "index.html#linked-list",
    "title": "Scientific C for programmers",
    "section": "Linked list",
    "text": "Linked list\nTODO"
  },
  {
    "objectID": "index.html#typedef",
    "href": "index.html#typedef",
    "title": "Scientific C for programmers",
    "section": "Typedef",
    "text": "Typedef\nTODO"
  },
  {
    "objectID": "index.html#size-of-structure",
    "href": "index.html#size-of-structure",
    "title": "Scientific C for programmers",
    "section": "Size of structure",
    "text": "Size of structure\nGoal:\n\nWrite a program centered around a Person structure\n\nLearning outcomes:\n\nDefine a structure and functions operating ont\nThink about memory alignment\n\nInstructions:\n\nCreate a Person structure with members height, weight, year of birth, and first letter of name\nWrite a function that computes the total weight of a group of persons\nCheck the size of the structure in memory and explain the result\nSee exercises/10_struct_basics"
  },
  {
    "objectID": "index.html#dna-transcription",
    "href": "index.html#dna-transcription",
    "title": "Scientific C for programmers",
    "section": "DNA transcription",
    "text": "DNA transcription\nTODO"
  },
  {
    "objectID": "index.html#input-and-output-1",
    "href": "index.html#input-and-output-1",
    "title": "Scientific C for programmers",
    "section": "Input and output 1 2",
    "text": "Input and output 1 2\n\nInput/output is not part of C, but of standard library =&gt; need for #include &lt;stdio.h&gt;\nConverting input/output can be tedious (use AI assistant?)\nMake use of dedicated libraries/formats such as HDF5, NetCDF, Zarr\nAnnotate input/output with metadata (units, meaning, etc…)\nLimited coverage in this course, see K&R Appendix B\n\nKernighan and Ritchie, Chapter 7, Input and OutputAdapted from https://github.com/gjbex/Scientific-C"
  },
  {
    "objectID": "index.html#writing-to-standard-out-stdout",
    "href": "index.html#writing-to-standard-out-stdout",
    "title": "Scientific C for programmers",
    "section": "Writing to standard out (stdout)",
    "text": "Writing to standard out (stdout)\nprintf allows to print internal values as characters in terminal\n// int with minimal width 5\nprintf(\"a = %5d\\n\", a); // a =    10\n// int with minimal width 5 and zero padding\nprintf(\"a = %05d\\n\", a); // a = 00010\n// double with 8 digits after comma\nprintf(\"pi = %.8f\\n\", M_PI); // pi = 3.14159265\n// double in exponential notation\nprintf(\"pi = %8.2e\\n\", M_PI); // pi = 3.14e+00\n// fixed-width string\nprintf(\"%.10s\\n\", \"Hello, world\"); // Hello, wor"
  },
  {
    "objectID": "index.html#reading-from-standard-in-stdin",
    "href": "index.html#reading-from-standard-in-stdin",
    "title": "Scientific C for programmers",
    "section": "Reading from standard in (stdin)",
    "text": "Reading from standard in (stdin)\nint day;\nchar month[20];\nprintf(\"Enter data in format '01 January'\\n\");\nscanf(\"%d %s\", &day, month); // Make sure to check values!\nscanf:\n\nreturns number of matched items\nstops when format string is exhausted or input fails to match specification\n\n\n\n\n\n\n\nTip\n\n\nTo run non-interactively, you can redirect file contents to stdin on Linux with ./a.out &lt;inputfile"
  },
  {
    "objectID": "index.html#command-line-arguments",
    "href": "index.html#command-line-arguments",
    "title": "Scientific C for programmers",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n\nCommand-line arguments are passed to main\nFirst argument: number of command-line arguments + 1 (typically argc)\nSecond argument: pointer to array of character strings (typically argv)\n\nFirst array element (at index 0) has name of program"
  },
  {
    "objectID": "index.html#command-line-arguments-1",
    "href": "index.html#command-line-arguments-1",
    "title": "Scientific C for programmers",
    "section": "Command-line arguments",
    "text": "Command-line arguments\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"There are %d command-line arguments\\n\", argc);\n    printf(\"The program is called %s\\n\", argv[0]);\n    for (int i = 1; i &lt; argc; i++)\n        printf(\"Command-line argument %d is %s\\n\", i, argv[i]);\n    return 0;\n}\n$ ./a.out Hello World\nThere are 3 command-line arguments\nThe program is called ./a.out\nCommand-line argument 1 is Hello\nCommand-line argument 2 is World"
  },
  {
    "objectID": "index.html#file-access",
    "href": "index.html#file-access",
    "title": "Scientific C for programmers",
    "section": "File access",
    "text": "File access\n\nFiles are accessed using a FILE structure defined in stdio.h:\n\nFILE *fp; fp = fopen(name, mode);\n\nmode can be read r, append a, or write w\nMake sure to check if fopen was succesful by comparing with NULL pointer\nMake for to close file again with fclose(fp);"
  },
  {
    "objectID": "index.html#file-access-example",
    "href": "index.html#file-access-example",
    "title": "Scientific C for programmers",
    "section": "File access example",
    "text": "File access example\n    FILE *values = fopen(\"values.txt\", \"r\");\n    if (values == NULL) {\n        printf(\"Failed to open values.txt\\n\");\n        return 1;\n    }\n    char line[256];\n    while (fgets(line, sizeof(line), fp)) {\n        double value;\n        if (sscanf(line, \"%lf\", &value) == 2) {\n            printf(\"Read value %f\\n\", value);\n        }\n    }\n    fclose(values);\n$ cat values.txt\n42\n3.14\n981.12\n$ ./a.out\nRead value 42.000000\nRead value 3.140000\nRead value 981.120000"
  },
  {
    "objectID": "index.html#exercise-regression",
    "href": "index.html#exercise-regression",
    "title": "Scientific C for programmers",
    "section": "Exercise: regression",
    "text": "Exercise: regression\nGoal:\n\nWrite a program that reads temperature anomalies and predicts future values using simple linear regression\n\nLearning outcomes:\n\nLearn how to read numbers from a structured input file and process them\n\nInstructions:\n\nSee exercises/12_regression"
  },
  {
    "objectID": "index.html#external-libraries-1",
    "href": "index.html#external-libraries-1",
    "title": "Scientific C for programmers",
    "section": "External libraries",
    "text": "External libraries\n\nExternal libraries extend C’s capabilities — especially useful in scientific computing (e.g., linear algebra, FFT, plotting).\nCommon scientific libraries:\n\nGSL (GNU Scientific Library)\nBLAS/LAPACK (Linear Algebra)\nFFTW (Fast Fourier Transforms)\nHDF5 (Hierarchical data format)\n\nBenefits:\n\nAvoid reinventing the wheel\nLeverage optimized, tested code\nImprove performance and portability"
  },
  {
    "objectID": "index.html#static-vs-dynamic-libraries",
    "href": "index.html#static-vs-dynamic-libraries",
    "title": "Scientific C for programmers",
    "section": "Static vs Dynamic Libraries",
    "text": "Static vs Dynamic Libraries\n\n\n\n\n\n\n\n\nFeature\nStatic Library (.a/.lib)\nDynamic Library (.so/.dll)\n\n\n\n\nLinking time\nCompile time\nRuntime\n\n\nBinary size\nLarger (library included)\nSmaller (library separate)\n\n\nPortability\nEasier to distribute\nRequires library on target system\n\n\nUpdates\nRecompile to update\nCan update without recompiling\n\n\nPerformance\nSlightly faster (no indirection)\nMay have overhead at runtime\n\n\n\n\nUse gcc -static for static linking, or -l&lt;libname&gt; with -L&lt;path&gt; for dynamic linking. Details differ from library to library: check the documentation"
  },
  {
    "objectID": "index.html#gnu-scientific-library",
    "href": "index.html#gnu-scientific-library",
    "title": "Scientific C for programmers",
    "section": "GNU Scientific Library",
    "text": "GNU Scientific Library\n\nThe GNU Scientific Library (GSL) provides a wide range of mathematical routines\nHow to get it:\n\nOn the cluster: load it as a module, module load GSL/2.8-GCC-13.3.0 for example\nOn your machine: install it as a system package, apt-get install libgsl-dev for example\n\nHow to use it:\n\nInclude the relevant headers in your code\nFind relevant link flags with pkg-config --libs gsl for example"
  },
  {
    "objectID": "index.html#minimizing-a-function-with-gsl",
    "href": "index.html#minimizing-a-function-with-gsl",
    "title": "Scientific C for programmers",
    "section": "Minimizing a function with GSL",
    "text": "Minimizing a function with GSL\ndouble f(double x, void *params) {\n    Params *p = (Params *) params;\n    return exp(-p-&gt;sigma*x*x)*sin(p-&gt;a + p-&gt;b*x);\n}\ntypedef struct {\n    double a, b, sigma;\n} Params;\n\nParams params = {0.3, 1.0, 0.05};"
  },
  {
    "objectID": "index.html#blas-lapack-high-performance-linear-algebra",
    "href": "index.html#blas-lapack-high-performance-linear-algebra",
    "title": "Scientific C for programmers",
    "section": "BLAS & LAPACK: High-Performance Linear Algebra",
    "text": "BLAS & LAPACK: High-Performance Linear Algebra\n\nBLAS (Basic Linear Algebra Subprograms)\n\nLow-level routines for vector and matrix operations\nLevels:\n\nLevel 1: Vector-vector (e.g., dot product)\nLevel 2: Matrix-vector (e.g., solving triangular systems)\nLevel 3: Matrix-matrix (e.g., multiplication)\n\n\nLAPACK (Linear Algebra PACKage)\n\nBuilt on top of BLAS\nHigh-level routines for:\n\nSolving linear systems\nEigenvalue problems\nSingular value decomposition"
  },
  {
    "objectID": "index.html#blas-lapack",
    "href": "index.html#blas-lapack",
    "title": "Scientific C for programmers",
    "section": "BLAS & LAPACK",
    "text": "BLAS & LAPACK\n\nWhy use them?\n\nHighly optimized for performance\nPortable across platforms\nWidely used in scientific and engineering applications\n\nMany implementations are available\n\nOpenBLAS\nIntel MKL\nATLAS\n\n\n\nLink with -lblas -llapack or use optimized implementations like OpenBLAS, Intel MKL, or ATLAS."
  },
  {
    "objectID": "index.html#dot-product-in-blas",
    "href": "index.html#dot-product-in-blas",
    "title": "Scientific C for programmers",
    "section": "Dot product in BLAS",
    "text": "Dot product in BLAS\n#include &lt;stdio.h&gt;\n#include &lt;cblas.h&gt;\n\nint main() {\n    double x[3] = {1.0, 2.0, 3.0};\n    double y[3] = {4.0, 5.0, 6.0};\n    double result = cblas_ddot(3, x, 1, y, 1);\n    printf(\"Dot product: %f\\n\", result);\n    return 0;\n}"
  },
  {
    "objectID": "index.html#hdf5-managing-scientific-data-in-c",
    "href": "index.html#hdf5-managing-scientific-data-in-c",
    "title": "Scientific C for programmers",
    "section": "HDF5: Managing Scientific Data in C",
    "text": "HDF5: Managing Scientific Data in C\n\nHDF5 (Hierarchical Data Format v5)\n\nDesigned for storing and organizing large, complex datasets\nSupports n-dimensional arrays, tables, images, and metadata\nCommon in physics, climate modeling, bioinformatics, and engineering\n\nFeatures\n\nPortable and self-describing binary format\nHierarchical structure: groups and datasets (like folders and files)\nSupports compression, parallel I/O, and chunking\n\n\nHDF5: writing a dataset\n\nSimple Example: Writing a Dataset\n\n#include \"hdf5.h\"\n\nint main() {\n    hid_t file_id, dataset_id, dataspace_id;\n    hsize_t dims[2] = {4, 6};\n    double data[4][6] = { /* initialize with values */ };\n\n    file_id = H5Fcreate(\"example.h5\", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    dataspace_id = H5Screate_simple(2, dims, NULL);\n    dataset_id = H5Dcreate(file_id, \"/mydata\", H5T_NATIVE_DOUBLE, dataspace_id,\n                           H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);\n    H5Dclose(dataset_id);\n    H5Sclose(dataspace_id);\n    H5Fclose(file_id);\n    return 0;\n}"
  },
  {
    "objectID": "index.html#solve-a-linear-system-of-equations-with-gsl",
    "href": "index.html#solve-a-linear-system-of-equations-with-gsl",
    "title": "Scientific C for programmers",
    "section": "Solve a linear system of equations with GSL",
    "text": "Solve a linear system of equations with GSL"
  },
  {
    "objectID": "index.html#training-a-neural-network-for-handwriting-recognition",
    "href": "index.html#training-a-neural-network-for-handwriting-recognition",
    "title": "Scientific C for programmers",
    "section": "Training a neural network for handwriting recognition",
    "text": "Training a neural network for handwriting recognition"
  },
  {
    "objectID": "index.html#segmentation-faults-1",
    "href": "index.html#segmentation-faults-1",
    "title": "Scientific C for programmers",
    "section": "Segmentation faults",
    "text": "Segmentation faults\nTODO"
  },
  {
    "objectID": "index.html#segmentation-fault-example",
    "href": "index.html#segmentation-fault-example",
    "title": "Scientific C for programmers",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n = 4;\n    int A[n];\n    for (int i = 0; i &lt;= n; i++) {\n        printf(\"A[%5d] = %12d\\n\", i, A[i]);\n        printf(\"A[%5d] = %12d\\n\", i * 3000, A[i*3000]);\n    }\n    return 0;\n}\nWhat will happen when you compile and run this program?"
  },
  {
    "objectID": "index.html#segmentation-fault-example-1",
    "href": "index.html#segmentation-fault-example-1",
    "title": "Scientific C for programmers",
    "section": "Segmentation fault example",
    "text": "Segmentation fault example\nInvalid array access gives undefined behavior, the result can depend on the system\n$ ./segmentation_fault\nA[    0] =            0\nA[    0] =            0\nA[    1] =            0\nA[ 3000] =   1815048801\nA[    2] =      4198989\nA[ 6000] =   2034381655\nA[    3] =            0\nSegmentation fault (core dumped)\n\nSome true elements (A[2]) have a garbage value\n\nMakes sense, elements were not initialized\n\nSome elements outside of array (A[3000]) have a garbage value\n\nMakes sense, it is not checked if this is actually a memory argument, you just get what happens to be in memory at (A + 3000)\n\nThe access of A[9000] gives a segmentation fault\n\n???"
  },
  {
    "objectID": "index.html#virtual-vs-physical-memory-background-colorlightgrey",
    "href": "index.html#virtual-vs-physical-memory-background-colorlightgrey",
    "title": "Scientific C for programmers",
    "section": "Virtual vs physical memory {background-color=“lightgrey”}",
    "text": "Virtual vs physical memory {background-color=“lightgrey”}\n\n\n\nAs a user/programmer, you see virtual memory\nVirtual memory creates the illusion of a large, contiguous, uniform address space\n\nHides fragmentation of physical memory\nDelegates managing memory hierarchy (caches, RAM, disk) to OS\nProvides safety mechanism to isolate process’ address space\n\nMapping to phyical memory in page table\n\nOut-of-bound memory access can pick up garbage mapping address\nYou might be accessing another process’ memory, even on read access the CPU throws a segmentation fault"
  },
  {
    "objectID": "index.html#handling-segmentation-faults",
    "href": "index.html#handling-segmentation-faults",
    "title": "Scientific C for programmers",
    "section": "Handling segmentation faults",
    "text": "Handling segmentation faults\n\nDo not make coding mistakes :)\nAsk the compiler to instrument executable to\n\ngcc -fsanitize=bounds-strict segmentation_fault.c\nCan lead to lower performance\n\nRun the program under a debugger such as gdb\n\nCompile with debug symbols (-g)"
  },
  {
    "objectID": "index.html#a-brief-history-of-c",
    "href": "index.html#a-brief-history-of-c",
    "title": "Scientific C for programmers",
    "section": "A brief history of C",
    "text": "A brief history of C\n\nC development starts in the early 1970s\nFirst standard published in 1989: ANSI C or C89\nUpdate in 1999: C99 standard\nUpdate in 2011: C11 standard\nMinor bugfixes in 2017: C17 (sometimes referred to as C18)\nUpdate in 2023: C23"
  },
  {
    "objectID": "index.html#different-c-standards",
    "href": "index.html#different-c-standards",
    "title": "Scientific C for programmers",
    "section": "Different C standards",
    "text": "Different C standards\n\nThe C89 standard is still considered the default\nCompiler has to be instructed to use specific standard: gcc -std=c11\n\nYou need a recent compiler for the most recent standard\n\nCompilers often to not stick exactly to standard\n\ngcc provides some C99 constructions by default\nOptions like -std=c89 -pedantic make it more strict"
  },
  {
    "objectID": "index.html#the-c99-standard-additions",
    "href": "index.html#the-c99-standard-additions",
    "title": "Scientific C for programmers",
    "section": "The C99 standard additions",
    "text": "The C99 standard additions\n\nSingle-line comments with //\nVariable length arrays\nMark functions with inline to avoid call overhead\nUse restrict to indicate arrays do not overlap\nBoolean and complex types in &lt;bool.h&gt; and &lt;complex.h&gt;\nType-generic macros in &lt;tgmath.h&gt;\nIEEE 754 floating point support"
  },
  {
    "objectID": "index.html#inline-functions",
    "href": "index.html#inline-functions",
    "title": "Scientific C for programmers",
    "section": "Inline functions",
    "text": "Inline functions\n\nFunction call: expensive\n\ncall stack must be maintained\nstack variables allocated, initialized\n\nSmall functions, called often: lots of overhead\nInline functions: function code inserted in caller\n\ngood compilers try that anyway\nhelping compilers: better optimization!\n\n\ninline double sqr(double x) {\n    return x*x;\n}"
  },
  {
    "objectID": "index.html#restrict-keyword-for-arrays",
    "href": "index.html#restrict-keyword-for-arrays",
    "title": "Scientific C for programmers",
    "section": "Restrict keyword for arrays",
    "text": "Restrict keyword for arrays\n\nArrays in C\n\naddress of first element\nno semantics for compiler\n\nMultiple arrays as function arguments, do they overlap?\nHelp compiler, use restrict\n\nprogrammer assures to compiler that arrays don’t overlap\n\n\nvoid daxpy_r(double * restrict z, double a,                      double * restrict x, double * restrict y, int n);"
  },
  {
    "objectID": "index.html#complex-numbers",
    "href": "index.html#complex-numbers",
    "title": "Scientific C for programmers",
    "section": "Complex numbers",
    "text": "Complex numbers\n\nTypes:\n\nfloat complex: single precision\ndouble complex: double precision\nlong double complex: extended precision\n\nDeclarations in complex.h\n\ntypes\nliteral: I\nfunctions, e.g., creal, cimag, csqrt, cexp, …"
  },
  {
    "objectID": "index.html#type-generic-math",
    "href": "index.html#type-generic-math",
    "title": "Scientific C for programmers",
    "section": "Type-generic math",
    "text": "Type-generic math\n\nAutomatically selects the correct version of a math function:\n\nfloat, double, or long double\ncomplex or real types\n\nCleaner code: No need to manually choose sinf, sin, or sinl.\nType safety: Matches function to argument type at compile time.\n\n#include &lt;tgmath.h&gt;\n\ndouble x = 0.5;\nfloat y = 0.5f;\n\ndouble result1 = sin(x);  // uses sin()\nfloat result2 = sin(y);   // uses sinf()"
  },
  {
    "objectID": "index.html#ieee-754-floating-point-support",
    "href": "index.html#ieee-754-floating-point-support",
    "title": "Scientific C for programmers",
    "section": "IEEE 754 floating point support",
    "text": "IEEE 754 floating point support\n\nfloat: 4 byte, single precision\ndouble: 8 byte, double precision\nlong double: 12 byte, extended precision\nRounding well-defined\nSupport for Inf, -Inf, NaN"
  },
  {
    "objectID": "index.html#the-c11-standard",
    "href": "index.html#the-c11-standard",
    "title": "Scientific C for programmers",
    "section": "The C11 standard",
    "text": "The C11 standard\nThe _Generic Keyword\n\nEnables type-generic programming (like tgmath.h)\nExample:\n#define my_abs(x) _Generic((x), \\\n    int: abs, \\\n    float: fabsf, \\\n    double: fabs \\\n)(x)"
  },
  {
    "objectID": "index.html#mathematics-in-c23",
    "href": "index.html#mathematics-in-c23",
    "title": "Scientific C for programmers",
    "section": "Mathematics in C23",
    "text": "Mathematics in C23\n\nNew mathematical functions in math.h\n\nsinpi(x) is the same as sin(pi*x) with better precision\nexp10 et al.\n\nChecked integer artithmetic in stdckdint.h\n\nckd_add et al.\n\nSupport for 1'000 and 1'133.023 notation\nDecimal floating-point math (IEEE 754-2008/2019)"
  },
  {
    "objectID": "index.html#syntax-changes-in-c23",
    "href": "index.html#syntax-changes-in-c23",
    "title": "Scientific C for programmers",
    "section": "Syntax changes in C23",
    "text": "Syntax changes in C23\n\nnullptr`` (keyword) rather thanNULL` (macro)\ntrue/false keywords, stdbool.h not required\nUnnamed function parameters\nstdbit.h: bit manipulation functions\nstrdup/strndup: simple string duplication\nconstexpr for compile-time constants\nstatic_assert for compile-time asserts\ntypeof to determine type at compile time"
  },
  {
    "objectID": "index.html#c23-attributes",
    "href": "index.html#c23-attributes",
    "title": "Scientific C for programmers",
    "section": "C23 attributes",
    "text": "C23 attributes\n\nDefensive programming\n\n[[fallthrough]]: intentional fall-through in switch\n[[nodiscard]]: don’t ignore return value\n[[maybe_unused]]: don’t warn if not used (function/parameter)\n[[deprecated]]\n\nPerformance related\n\n[[unsequenced]]: function has no side-effects, calls can be out-of-order\n[[reproducible]]: function has no side-effect, calls have to be in-order (e.g., random numbers)"
  },
  {
    "objectID": "index.html#scientific-programming-landscape-4",
    "href": "index.html#scientific-programming-landscape-4",
    "title": "Scientific C for programmers",
    "section": "Scientific programming landscape",
    "text": "Scientific programming landscape"
  },
  {
    "objectID": "index.html#more-to-explore",
    "href": "index.html#more-to-explore",
    "title": "Scientific C for programmers",
    "section": "More to explore",
    "text": "More to explore\n\nHow to do HPC =&gt; HPC intro and Linux for HPC\nBuild systems =&gt; CMake intro and Makefile intro\nVersion control =&gt; Version control with git\nOptimizing code =&gt; Code optimization\nDebugging code =&gt; Defensive programming and debugging\nParallel programming =&gt; Parallel programming\nSetting up an Integrated Development Environment (IDE)"
  },
  {
    "objectID": "index.html#more-to-explore-1",
    "href": "index.html#more-to-explore-1",
    "title": "Scientific C for programmers",
    "section": "More to explore",
    "text": "More to explore\n\n\n\n\n\n\nTip\n\n\nThe calendar of VSC Trainings can be found at https://www.vscentrum.be/vsctraining. Learning paths that show connections between trainings can be found at https://gjbex.github.io/."
  },
  {
    "objectID": "code_examples/swap_naive.html",
    "href": "code_examples/swap_naive.html",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "code_examples/swap_naive.html#swapping-variables-naive-approach",
    "href": "code_examples/swap_naive.html#swapping-variables-naive-approach",
    "title": "",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\n\n\n\nVariable\nAddress\nValue\n\n\n\n\nx\n0x100\n5\n\n\ny\n0x104\n10\n\n\na\n0x108\n5\n\n\nb\n0x10C\n10\n\n\ntemp\n0x110\n5"
  },
  {
    "objectID": "c_basics.html",
    "href": "c_basics.html",
    "title": "Basics of C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_basics.html#outline",
    "href": "c_basics.html#outline",
    "title": "Basics of C",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "c_basics.html#data-types-operators-and-expressions-1",
    "href": "c_basics.html#data-types-operators-and-expressions-1",
    "title": "Basics of C",
    "section": "Data types, operators and expressions 1 2",
    "text": "Data types, operators and expressions 1 2\n\nVariables are the basic data objects manipulated in a C program\nC is statically typed: a variable is of a specific type defined at compile time\nC allows manipulation of variables by expressions with operators"
  },
  {
    "objectID": "c_basics.html#the-very-basics",
    "href": "c_basics.html#the-very-basics",
    "title": "Basics of C",
    "section": "The very basics",
    "text": "The very basics\n\n\n\nC statements 3 end with a semicolon\nBraces {} are used to group statements into a code block\nWhitespace is mostly ignored, allows to improve readability\nCompiler ignores what comes after // and between /* and */\n\n\nint a = 10;\nif (a &gt; 0) {\n    b = 2; // Single-line comment\n    c = 3;\n}\n/* Multi-line\n   comment */"
  },
  {
    "objectID": "c_basics.html#names-of-data-objects-in-c",
    "href": "c_basics.html#names-of-data-objects-in-c",
    "title": "Basics of C",
    "section": "Names of data objects in C",
    "text": "Names of data objects in C\n\nare case sensitive\nconsist of {A,...,Z,a,...,z,_,0,...,9}\nstart with {A,...,Z,a,...,z,_}\ncan have any length, but at most:\n\nvariables: 31 significant, 64 for C99+\nfunctions: 6 significant4, 32 for C99+\n\ncannot be reserved words such as if, while, char, int, …"
  },
  {
    "objectID": "c_basics.html#conventions-for-names",
    "href": "c_basics.html#conventions-for-names",
    "title": "Basics of C",
    "section": "Conventions for names",
    "text": "Conventions for names\n\nvariables, functions: start with lowercase\nconstants, type names: start with uppercase\nnames reflect semantics of entity!\n\nvariables with very small scope have a short name\n\ncamelCase (e.g., nrOfRuns) or underscores nr_of_runs\n\n\n\n\n\n\n\nTip\n\n\n\nTry to be consistent within a project. If you might share code with others, try to stick to a generally accepted code style, e.g. the GNU coding standard"
  },
  {
    "objectID": "c_basics.html#overview-of-data-types",
    "href": "c_basics.html#overview-of-data-types",
    "title": "Basics of C",
    "section": "Overview of data types",
    "text": "Overview of data types\n\nchar: single character\nint: integer, allows qualifiers (signed, long, …)\nfloat/double/long double: real numbers\nenum: list of constants\nstruct: structure, group of related variables"
  },
  {
    "objectID": "c_basics.html#characters",
    "href": "c_basics.html#characters",
    "title": "Basics of C",
    "section": "Characters",
    "text": "Characters\n\na char holds 1 character of the local character set\nusually 1 byte, check with the sizeof operator\nlimits are defined in limits.h header as CHAR_MIN and CHAR_MAX\nchar can be signed or unsigned\n\nalmost always irrelevant, just use char\n\nExample: char myChar = 'b';\n\n\"b\" is a string (=array of chars)!"
  },
  {
    "objectID": "c_basics.html#special-characters-are-escaped-with",
    "href": "c_basics.html#special-characters-are-escaped-with",
    "title": "Basics of C",
    "section": "Special characters are escaped with \\",
    "text": "Special characters are escaped with \\\n\n'\\a': bell\n'\\n': new line\n'\\r': carriage return\n'\\t': horizontal tab\n'\\\\': backslash\n'\\'': single quote\n'\\\"': double quote\n'\\0': null character (terminates strings)"
  },
  {
    "objectID": "c_basics.html#strings",
    "href": "c_basics.html#strings",
    "title": "Basics of C",
    "section": "Strings?",
    "text": "Strings?\n\nC does not have a basic string type\nAn array of characters is very similar to a string\n\nchar amessage[] = \"My first string\";\nchar *pmessage = \"My second string\";\n\nThe second example is a character pointer, we discuss pointers later on\nString constants are terminated with \\0 internally\n\nAllows to know where string ends\nYou do not need to know this if you use functions from the standard library to work with strings"
  },
  {
    "objectID": "c_basics.html#integers",
    "href": "c_basics.html#integers",
    "title": "Basics of C",
    "section": "Integers",
    "text": "Integers\n\nint: typically 4 bytes, offers \\(2^{32}\\) distinct values\nmodifiers:\n\nunsigned int: only non-negative integers, natural for array indices\nshort int/long int/long long int: different ranges compared to plain int, can be combined with unsigned\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe range of int can be a limitation in practice, think about the range you need and choose the appropriate type."
  },
  {
    "objectID": "c_basics.html#fixed-size-integers",
    "href": "c_basics.html#fixed-size-integers",
    "title": "Basics of C",
    "section": "Fixed-size integers",
    "text": "Fixed-size integers\nThe C standard only imposes a minimal range for integers:\n\nFor example, int should at least cover \\([−32767, +32767]\\)\nSome platforms provide larger range =&gt; code is potentially platform dependent\n\nIf you need a fixed range:\n\nInclude the stdint.h header\nUse uint8_t, int16_t, …, which provide exactly the specified number of bits"
  },
  {
    "objectID": "c_basics.html#real-numbers",
    "href": "c_basics.html#real-numbers",
    "title": "Basics of C",
    "section": "Real numbers",
    "text": "Real numbers\n\n\n\nReal numbers are represented in a computer in a format very similar to exponential notation5:\nComputer uses binary representation, e.g., the IEEE SP standard:\n\nExponent determines range\nMantissa determines precision"
  },
  {
    "objectID": "c_basics.html#double-precision",
    "href": "c_basics.html#double-precision",
    "title": "Basics of C",
    "section": "Double precision",
    "text": "Double precision\n\n\n\n\n\na double is usually 8 bytes and gives about 15 decimal digit precision\nthe float.h header provides:\n\nDBL_MAX: largest positive double\nDBL_MIN: smallest positive double\nDBL_EPSILON: difference between 1.0 and next representable value (\\(\\approx\\) machine precision)\nBLD_DIG: number of significant decimal digits"
  },
  {
    "objectID": "c_basics.html#other-floating-point-representations",
    "href": "c_basics.html#other-floating-point-representations",
    "title": "Basics of C",
    "section": "Other floating-point representations",
    "text": "Other floating-point representations\n\ndouble: most often used in science\nfloat: half the number of bits compared to double, usually 7 decimal digit precision\nlong double: usually larger range than double, not used often\n\n\n\n\n\n\n\nNote\n\n\n\nIn deep learning, reduced-precision formats (FP16, FP8) are often used. Only dedicated devices like GPUs give hardware support."
  },
  {
    "objectID": "c_basics.html#enumeration",
    "href": "c_basics.html#enumeration",
    "title": "Basics of C",
    "section": "Enumeration",
    "text": "Enumeration\n\nenum makes it convenient to refer to constants symbolically\nUsing automatic integer numbering:\n\nenum Level = {LOW, MEDIUM, HIGH};\nenum Level myLevel = MEDIUM; // myLevel will be 1\n\nUsing custom values:\n\nenum Pieces = {King = 'K', Queen = 'Q', Rook = 'R', Bishop = 'B', Knight = 'N'};\nenum Pieces myPiece = Bishop; // myPiece will be 'B'"
  },
  {
    "objectID": "c_basics.html#type-conversion",
    "href": "c_basics.html#type-conversion",
    "title": "Basics of C",
    "section": "Type conversion",
    "text": "Type conversion\n\nIn constants, use suffix, e.g. 123456789L is a long int\nIn expressions, automatic conversion to largest type, e.g. 5/9.0 is interpreted as 5.0/9.0\nExplicit casting with brackets, e.g. (int) 5.3 becomes the int 5 (information is lost)"
  },
  {
    "objectID": "c_basics.html#accidental-type-conversion",
    "href": "c_basics.html#accidental-type-conversion",
    "title": "Basics of C",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nWhat do you expect the following code will do?\n\ndouble a = -1.6e5;\nif (abs(a) &gt;= 0) {\n    printf(\"a is positive\\n\");\n}\nelse {\n    printf(\"a is strictly negative\\n\");\n}    \n\n\nBehaviour is unexpected?\n\n$ gcc main.c -o main\n$ ./main\na is positive"
  },
  {
    "objectID": "c_basics.html#accidental-type-conversion-1",
    "href": "c_basics.html#accidental-type-conversion-1",
    "title": "Basics of C",
    "section": "Accidental type conversion",
    "text": "Accidental type conversion\n\nCompilation with -Wconversion flags provide a hint\n\n$ gcc -Wconversion main.c -o main\nmain.c: In function ‘main’:\nmain.c:6:13: warning: conversion from ‘double’ to ‘int’ may change value [-Wfloat-conversion]\n    6 |     if (abs(a) &gt;= 0) {\n\n\nThe abs function is for int, double a was silently converted\nSolution: use the fabs function\n\ndouble a = -1.6e5;\nif (fabs(a) &gt;= 0) {\n    printf(\"a is positive\\n\");\n}\nelse {\n    printf(\"a is strictly negative\\n\");\n}"
  },
  {
    "objectID": "c_basics.html#variable-declaration",
    "href": "c_basics.html#variable-declaration",
    "title": "Basics of C",
    "section": "Variable declaration",
    "text": "Variable declaration\n\nC is statically typed, each variable has to be declared with type information: int a, b;\nCan be combined with an assignmnent, but no automatic initalization:\n\ndouble x = 3.2, y;\ndouble z = sqrt(2.0);\n\nConstants cannot be modified during runtime, must be assigned on declaration: const int MINUTESPERHOUR = 60;\n\nConvention: names of constants are capitalized"
  },
  {
    "objectID": "c_basics.html#booleans",
    "href": "c_basics.html#booleans",
    "title": "Basics of C",
    "section": "Booleans",
    "text": "Booleans\n\nThe original C89 standard does not have a boolean type\n\ntrue: non-zero integer, non-NULL pointer\nflase: zero, NULL pointer\n\nThe C99 standard adds the bool type and true/false keywords (after including &lt;stdbool.h&gt;)\nThe C23 standard provides booleans by default\nYou can get by with the C89 approach, dedicated bool type might be somewhat more efficient in some cases"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes",
    "href": "c_basics.html#exercise-data-type-sizes",
    "title": "Basics of C",
    "section": "Exercise: data type sizes",
    "text": "Exercise: data type sizes\nGoal:\n\nPrint information about sizes and ranges of several types\n\nLearning outcomes:\n\nUnderstand C data types\n\nInstructions:\n\nExtend the program provided in exercises/04_data_type_sizes to print information about more types and ranges\nExplain the relation between sizes and ranges"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes-solution",
    "href": "c_basics.html#exercise-data-type-sizes-solution",
    "title": "Basics of C",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The size of int is %zu bytes; it ranges from %d to %d\\n\",\n       sizeof(int), INT_MIN, INT_MAX);\nprintf(\"The size of unsigned long int is %zu bytes; its max is %lu\\n\",\n       sizeof(unsigned long int), ULONG_MAX);\nOutput:\nThe size of int is 4 bytes; it ranges from -2147483648 to 2147483647\nThe size of unsigned long int is 8 bytes; its max is 18446744073709551615\n\n4 bytes = 32 bits: int is in \\([-2^{31}, 2^{31}-1]\\)\n8 bytes = 64 bits: unsigned long int is in \\([0, 2^{64}-1]\\)"
  },
  {
    "objectID": "c_basics.html#exercise-data-type-sizes-solution-1",
    "href": "c_basics.html#exercise-data-type-sizes-solution-1",
    "title": "Basics of C",
    "section": "Exercise: data type sizes solution",
    "text": "Exercise: data type sizes solution\nCode:\nprintf(\"The largest double that can be represented is %6.1e\\n\", DBL_MAX);\nprintf(\"The smallest positive double that can be represented is %6.1e\\n\", DBL_MIN);\nprintf(\"The machine epsilon is %6.1e\\n\", DBL_EPSILON);\nprintf(\"The number of digits is %d\\n\", DBL_DIG);\nOutput:\nThe largest double that can be represented is 1.8e+308\nThe smallest positive double that can be represented is 2.2e-308\nThe machine epsilon is 2.2e-16\nThe number of digits is 15\n\nExponent has 11 bits -&gt; in range [-1023,1024] -&gt; \\(2^{1024} \\approx 10^{308}\\)\nSignificant has 52 bits -&gt; 52 significant digits in binary -&gt; \\(52 \\log_{10} 2 \\approx 15.6\\)"
  },
  {
    "objectID": "c_basics.html#overview-of-operators",
    "href": "c_basics.html#overview-of-operators",
    "title": "Basics of C",
    "section": "Overview of operators",
    "text": "Overview of operators\n\narithmetic operators\nrelational operators\nlogical operators\nbitwise operators\nassignment operators\nincremental operators\nconditional operator"
  },
  {
    "objectID": "c_basics.html#arithmetic-operators",
    "href": "c_basics.html#arithmetic-operators",
    "title": "Basics of C",
    "section": "Arithmetic operators",
    "text": "Arithmetic operators\n\naddition, subtraction: +, -\nmultiplication, division: *, /\n\ninteger division truncates fractional part, 5/9 equals 0\n\nmodulo (only for integers): %\n*, /, % take precedence over + and -\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse brackets for clarity instead of relying on precedence rules"
  },
  {
    "objectID": "c_basics.html#relational-operators",
    "href": "c_basics.html#relational-operators",
    "title": "Basics of C",
    "section": "Relational operators",
    "text": "Relational operators\n\norder:\n\nsmaller, smaller or equal: &lt;, &lt;=\nlarger, larger or equal: &gt;, &gt;=\n\nequality:\n\nequal to, not equal to: ==, !=\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBe careful when comparing doubles, e.g. pow(sqrt(5.0), 2) == 5.0 is false!"
  },
  {
    "objectID": "c_basics.html#logical-operators",
    "href": "c_basics.html#logical-operators",
    "title": "Basics of C",
    "section": "Logical operators",
    "text": "Logical operators\n\nlogical and, logical or: &&, ||\n\nevaluated left to right with early stopping, (i &lt; N) && (a[i] &gt; 0) will not access a[i] unless i &lt; N\n\nunary negation !\n\nconverts non-zero operand into 0 and zero operand into 1\nzero is false, non-zero is true"
  },
  {
    "objectID": "c_basics.html#incrementdecrement-operators",
    "href": "c_basics.html#incrementdecrement-operators",
    "title": "Basics of C",
    "section": "Increment/decrement operators",
    "text": "Increment/decrement operators\n\nC specific shorthand notation\n\nincrement: i = i + 1; is the same as i++; or ++i;\ndecrement: i = i - 1; is the same as i--; or --i;\n\npost/pre increment matters when value is used, for example in assignment:\n\nint j = ++i;: first increment i, then assign it to j\nint j = i++;: first assign i to j, then increment j\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe name C++ can be interpreted as “incremented C”"
  },
  {
    "objectID": "c_basics.html#bitwise-operators",
    "href": "c_basics.html#bitwise-operators",
    "title": "Basics of C",
    "section": "Bitwise operators",
    "text": "Bitwise operators\nManipulate bits of integers (signed and unsigned char, int, long, …)\n\nBitwise and, or, xor: &, |, ^\n\n0011 & 0101 -&gt; 0001\n\nShift bits left, right: &lt;&lt;, &gt;&gt;\n\n0111 1000 &gt;&gt; 2 -&gt; xx01 1110\nx is zero if unsigned, undefined otherwise\n\nOne’s complement: ~\n\n~1101 -&gt; 0010\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBitwise operators are powerful, but also tedious. Use with care!"
  },
  {
    "objectID": "c_basics.html#assignment-operators",
    "href": "c_basics.html#assignment-operators",
    "title": "Basics of C",
    "section": "Assignment operators",
    "text": "Assignment operators\n\nSimple assignment is done with = (do not confuse with comparison ==)\nAssignment operators allow to compress statements:\n\ni = i + 2; is the same as i += 2;\nMost binary operators have a corresponding assignment operator\nMore concise, but often more intuitive as well"
  },
  {
    "objectID": "c_basics.html#conditional-expression",
    "href": "c_basics.html#conditional-expression",
    "title": "Basics of C",
    "section": "Conditional expression",
    "text": "Conditional expression\nConditional expression is a ternary operator condition ? expr_true : expr_false\n\nEvaluate the condition\n\nIf true, evaluate expr_true as the result\nIf false, evaluate expr_false as the result\n\n\n// z = max(a, b)\nif (a &gt; b) {\n    z = a;\n} else {\n    z = b;\n}\n// same thing but shorter\nz = (a &gt; b) ? a : b;"
  },
  {
    "objectID": "c_basics.html#precedence-and-associativity",
    "href": "c_basics.html#precedence-and-associativity",
    "title": "Basics of C",
    "section": "Precedence and associativity",
    "text": "Precedence and associativity\n\nK&R provide a table with precedence rules (2.12)\n\nMake your code readable and maintable by using brackets\n\nC does not specify order of evaluation for most operators:\n\norder can even depend on compiler options\nx = f() + g(); might evaluate g before f\n\nimportant if g alters variable used by f\n\na + b + c; could be (a + b) + c or a + (b + c)\n\nfloating-point arithmetic does not preserve mathematical associativity"
  },
  {
    "objectID": "c_basics.html#exercise-operators",
    "href": "c_basics.html#exercise-operators",
    "title": "Basics of C",
    "section": "Exercise: operators",
    "text": "Exercise: operators\nGoal: Solve a few operator-related programming questions Learning outcome: Understand the basics of C operators Instructions: See exercises/05_operators\n\n\n\n\n\n\nTip\n\n\n\nThis exercise uses the assert() function to check your solution. This function can be useful for debugging, but should not be used in production code.\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can easily “cheat” the assert() statements, but that is not the intention of course."
  },
  {
    "objectID": "c_basics.html#exercise-operators-solution",
    "href": "c_basics.html#exercise-operators-solution",
    "title": "Basics of C",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\nImplement a function that returns if a year is a leap year: easy to achieve by combining modulo and logical operators.\nint isLeapYear(int year) {\n    /* Return 1 if year is a leap year and return 0 otherwise\n       A year is a leap year if:\n       - it is divisible by 4 but not by 100 OR\n       - it is disisible by 400\n    */\n    if ( (year % 4 == 0 && year % 100 != 0) || (year % 400) == 0) return 1;\n    else return 0;\n}"
  },
  {
    "objectID": "c_basics.html#exercise-operators-solution-1",
    "href": "c_basics.html#exercise-operators-solution-1",
    "title": "Basics of C",
    "section": "Exercise: operators solution",
    "text": "Exercise: operators solution\n    // Multiply i by 8 and store it in j, but without making use of the * operator\n    // Hint: use a bitwise operator\n    int i = 5;\n    int j = i &lt;&lt; 3;\n    assert(j == 40);\n\n    // Compute c as the minimal value of a and b without using an if-else statement\n    int a = 126;\n    int b = 45;\n    int c = (a &lt; b) ? a : b;\n    assert(c == b);"
  },
  {
    "objectID": "c_basics.html#control-flow-1",
    "href": "c_basics.html#control-flow-1",
    "title": "Basics of C",
    "section": "Control flow 6 7",
    "text": "Control flow 6 7\n\nControl flow statements specify order in which computations are performed\nOften multiple ways to achieve the same end result\n\nInvolves an element of personal preference\nOne way might provide faster code than another"
  },
  {
    "objectID": "c_basics.html#statements-and-blocks",
    "href": "c_basics.html#statements-and-blocks",
    "title": "Basics of C",
    "section": "Statements and blocks",
    "text": "Statements and blocks\n\nUse ; to terminate a statement\nGroup multiple statements in blocks with braces {}\n\nblocks can be nested\nvariables can be redeclared and have block scope\n{\n   int i = 3; // from here, i is 3\n   {\n      int i = 5; //from here, i is 5\n   }\n   // from here, i is 3 again\n}\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse blocks to make your code more readable, unless you want to participate in the The International Obfuscated C Code Contest"
  },
  {
    "objectID": "c_basics.html#if-else-statement",
    "href": "c_basics.html#if-else-statement",
    "title": "Basics of C",
    "section": "if-else statement",
    "text": "if-else statement\n\n\nif (expression != 0) {\n    statement_true;\n} else {\n    statement_false;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression != 0} --&gt;|true| C[statement_true]\n    B --&gt;|false| E[statement_false]\n\n\n\n\n\n\n\n\n\nThe else clause is optional\nFor a single-line statement, braces are optional\nIndentation is only for style, but helps for readability\nif (expression) is the same as if (expression != 0)"
  },
  {
    "objectID": "c_basics.html#else-if-statement",
    "href": "c_basics.html#else-if-statement",
    "title": "Basics of C",
    "section": "else-if statement",
    "text": "else-if statement\n\n\nif (expression1) {\n    statement1;\n} else if (expression2) {\n    statement2;\n} else {\n    statement3;\n}\n\n\n\n\n\n\nflowchart LR\n    B{expression1} --&gt;|true| C[statement1]\n    B --&gt;|false| E{expression2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n\n\n\n\n\n\n\n\n\nGeneral way to write a multi-way decision\nThe else clause is optional"
  },
  {
    "objectID": "c_basics.html#switch",
    "href": "c_basics.html#switch",
    "title": "Basics of C",
    "section": "Switch",
    "text": "Switch\n\n\nswitch (expression) {\n    case const-expr1: statements1\n    case const-expr2: statements2\n    default: statements3\n}\n\n\n\n\n\n\nflowchart LR\n    B{e == const-expr1} --&gt;|true| C[statements1]\n    B --&gt;|false| E{e == const-expr2}\n    E --&gt;|true| F[statement2]\n    E --&gt;|false| G[statement3]\n    C --&gt; E\n\n\n\n\n\n\n\n\n\nMulti-way decision to branch based on comparison with constant integer values\nFall through: execution goes to next case\n\nYou can leave a switch with break or return\n\nCase expressions must be constant and unique\ndefault is optional"
  },
  {
    "objectID": "c_basics.html#switch-example",
    "href": "c_basics.html#switch-example",
    "title": "Basics of C",
    "section": "Switch example",
    "text": "Switch example\n// Count occurence of odd and even digits in a string\nswitch (c) {\ncase '0': case '2': case '4': case '6': case '8':\n    neven++;\n    break;\ncase '1': case '3': case '5': case '7': case '9':\n    nodd++;\n    break;"
  },
  {
    "objectID": "c_basics.html#for-loop",
    "href": "c_basics.html#for-loop",
    "title": "Basics of C",
    "section": "For loop",
    "text": "For loop\n// General for loop\nfor (expr1; expr2; expr3) {\n    statements;\n}\n// Most common usage\nfor (int i = 0; i &lt; N; i++) {\n    statements;\n}\n\nexpr1: executed once at start, typically for initialization\nexpr2: evaluated at start of each iteration, for loop stops if false\nexpr3: evaluated at end of each iteration"
  },
  {
    "objectID": "c_basics.html#for-loop-1",
    "href": "c_basics.html#for-loop-1",
    "title": "Basics of C",
    "section": "For loop",
    "text": "For loop\n\nShould be used when number of repetitions is known or computed\nEach expression is optional, for (;;) {} is an infinite loop\nbreak in loop body terminates loop\ncontinue in loop body goes to next iteration"
  },
  {
    "objectID": "c_basics.html#while-loop",
    "href": "c_basics.html#while-loop",
    "title": "Basics of C",
    "section": "While loop",
    "text": "While loop\n// General while loop\nwhile (expression) {\n    statements;\n}\n// Check if str contains c\nwhile (i &lt; strlen(str) && !found) {\n    if (str[i] == c)\n        found = True;\n    else\n        i++;\n}\n\nstatements are executed zero or more times, as long as expression is true\nshould be used when number of repetitions is unknown"
  },
  {
    "objectID": "c_basics.html#do-while-loop",
    "href": "c_basics.html#do-while-loop",
    "title": "Basics of C",
    "section": "Do-While loop",
    "text": "Do-While loop\n// General while loop\ndo {\n    statements;\n} while (expression);\n\nstatements are executed at least once, until expression is false\nSimilar to while loop, but expression is evaluated at end of iteration"
  },
  {
    "objectID": "c_basics.html#goto-and-labels",
    "href": "c_basics.html#goto-and-labels",
    "title": "Basics of C",
    "section": "Goto and labels",
    "text": "Goto and labels\ngoto label;\n...\nlabel:\n    statements;\n\ngoto allows to branch to a specified label\nnever necessary, often makes code hard to read\neven C inventors discourage it, do do not use it"
  },
  {
    "objectID": "c_basics.html#functions-and-program-structure-1",
    "href": "c_basics.html#functions-and-program-structure-1",
    "title": "Basics of C",
    "section": "Functions and Program Structure 8 9",
    "text": "Functions and Program Structure 8 9\n\nFunctions break large computing tasks into smaller ones\nHelp to bring structure into code\nHide implementations details\nMake it easier to reuse existing code"
  },
  {
    "objectID": "c_basics.html#basics-of-functions",
    "href": "c_basics.html#basics-of-functions",
    "title": "Basics of C",
    "section": "Basics of functions",
    "text": "Basics of functions\n// General function definition\nreturn-type function-name(type1 arg1, type2 arg2, ...) {\n    declarations and statements;\n    return expression;\n} \n\nA function can have no arguments: int myFunction(void);\nA function can return nothing: void myFunction(int A);\n\nNo return statement in body required\n\nThe compiler requires a function to be known before it can process a call\n\nDeclare the function: return-type function-name(type1 arg1, type2 arg2);\nDeclaration is promise to provide implementation later"
  },
  {
    "objectID": "c_basics.html#function-examples",
    "href": "c_basics.html#function-examples",
    "title": "Basics of C",
    "section": "Function examples",
    "text": "Function examples\n// The most minimal (useless) function\ndummy() {}\n// Compute the square of a floating-point number\ndouble square(double a) {\n    return a * a;\n}"
  },
  {
    "objectID": "c_basics.html#return-statements",
    "href": "c_basics.html#return-statements",
    "title": "Basics of C",
    "section": "Return statement(s)",
    "text": "Return statement(s)\n\nA return statements returns a value (or nothing), but also returns control to the caller\nA function can have multiple return statements, but at most one is executed in each call\n\nint index(char c, char s[]) {\n    unsigned i;\n    for (i = 0; i &lt; strlen(s); i++)\n        if (s[i] == c)\n            return i;\n    return -1;\n}\n\nThe returned expression is converted to function’s return type\n\n// Valid, but dubious\nint returnInt() {\n    double a = 5.0;\n    return a;\n}"
  },
  {
    "objectID": "c_basics.html#more-on-functions",
    "href": "c_basics.html#more-on-functions",
    "title": "Basics of C",
    "section": "More on functions",
    "text": "More on functions\n\nmain function is special: always the entry point of the program\nC passes arguments by value, inside the function a local copy is made\n\nchanges to values are invisible outside of function\npointers (see Day 3) allow to circumvent limitations\n\nA function can only return one variable\n\npack multiple values in a struct\nuse pointers (see Day 3) to pass out values\nexternal variables (usually a bad idea)"
  },
  {
    "objectID": "c_basics.html#external-variables",
    "href": "c_basics.html#external-variables",
    "title": "Basics of C",
    "section": "External variables",
    "text": "External variables\n\ninternal variable: defined inside function\n\nlifetime and scope limited to function call\n\nexternal variable: defined outside function\n\nbigger scope: globally accessible inside any function\nlonger lifetime: keeps value between calls\nalternative for long list of function arguments\n\n\n\n\n\n\n\n\nTip\n\n\n\nExternal variables typically make code less reusable, so generally they should be avoided"
  },
  {
    "objectID": "c_basics.html#external-variables-example",
    "href": "c_basics.html#external-variables-example",
    "title": "Basics of C",
    "section": "External variables example",
    "text": "External variables example\n#include &lt;stdio.h&gt;\nint external_variable;\n\nvoid someFunction(void) {\n    printf(\"In someFunction, external variable is %d\\n\", external_variable);\n    external_variable++;\n    }\n\nint main(void) {\n    external_variable = 1;\n    someFunction();\n    printf(\"in main, external variable is %d\\n\", external_variable);\n    return 0;\n}\n\nValue of external_variable persists:\n$ ./a.out\nIn someFunction, external variable is 1\nin main, external variable is 2"
  },
  {
    "objectID": "c_basics.html#scope",
    "href": "c_basics.html#scope",
    "title": "Basics of C",
    "section": "Scope",
    "text": "Scope\nThe scope of a variable or function is the part of the program where the variable of function can be used\n\nLocal variables\n\nFrom definition until end of block\nIncludes function arguments\n\nExternal variables\n\nFrom definition until end of file\nCan be used in multiple files by declaring with extern (not covered)"
  },
  {
    "objectID": "c_basics.html#header-files-and-build-systems",
    "href": "c_basics.html#header-files-and-build-systems",
    "title": "Basics of C",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nSo far: small programs in one .c file: easy to compile\nLarger projects: many source files\n\nOrder of compilation can matter because of dependencies\nDifficult to remember compilation commands (linking and flags)\nEditing one file does not require recompiling entirely"
  },
  {
    "objectID": "c_basics.html#header-files-and-build-systems-1",
    "href": "c_basics.html#header-files-and-build-systems-1",
    "title": "Basics of C",
    "section": "Header files and build systems",
    "text": "Header files and build systems\n\nUse header files:\n\n.h files containing shared definitions and declarations\n#include \"example.h\" or #include &lt;stdio.h&gt;\n\nUse a build system (not covered here)\n\nMakefile (https://github.com/hpcleuven/Makefile-intro]\nCMake (https://github.com/hpcleuven/CMake-intro]\nMeson\n\n\n\n\n\n\n\n\nTip\n\n\n\nMost exercises can be compiled by running the make command in the exercise directory"
  },
  {
    "objectID": "c_basics.html#static-variables",
    "href": "c_basics.html#static-variables",
    "title": "Basics of C",
    "section": "Static variables",
    "text": "Static variables\n\nInternal variables with static declaration\n\nRemain in existing across function calls\nProvide permanent private storage within a single function\n\n\nunsigned uniqueIdentifier() {\n    // id Indicates how many times the function has been called\n    static unsigned id = 0;\n    return id++;\n}"
  },
  {
    "objectID": "c_basics.html#static-functions",
    "href": "c_basics.html#static-functions",
    "title": "Basics of C",
    "section": "Static functions",
    "text": "Static functions\n\nFunctions with static declaration\n\nA static function is only visible within the file where it is declared\nA normal function is visible everywhere\n\nExternal variables with static declaration\n\nCan only be used in file where they are declared"
  },
  {
    "objectID": "c_basics.html#initialization",
    "href": "c_basics.html#initialization",
    "title": "Basics of C",
    "section": "Initialization",
    "text": "Initialization\n\nAutomatic internal variables\n\nWithout explicit initialization (such as int x;), values are “garbage”\nInitial value can come from expression: double y = sqrt(6.0);\nRe-initialized each time the block is entered\nCompiler can warn about uninitialized variables\n\nE.g., -Wuninitialized for gcc (not perfect)"
  },
  {
    "objectID": "c_basics.html#initialization-1",
    "href": "c_basics.html#initialization-1",
    "title": "Basics of C",
    "section": "Initialization",
    "text": "Initialization\n\nStatic internal variables\n\nGuaranteed to initialize to zero\nInitialization first time it is encountered\nExpression or constant expression\n\nExternal variables\n\nGuaranteed to initialize to zero\nInitialized at start of execution\nConstant expression"
  },
  {
    "objectID": "c_basics.html#recursion",
    "href": "c_basics.html#recursion",
    "title": "Basics of C",
    "section": "Recursion",
    "text": "Recursion\nFunctions can call themselves (i.e. recursion)\nunsigned long fac(unsigned long n) {\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n*fac(n-1);\n}\n\nEach function call has overhead (pushing frame on stack)\nOften not the fastest or lowest footprint\n\nDeep recursion levels can even cause stack overflow\n\nOften closer to mathematical description"
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor",
    "href": "c_basics.html#the-c-preprocessor",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA few statements are processed before compilation\n\n#include \"filename\" or include &lt;filename&gt;\n#define name replacement\nconditional inclusions with #if, #elif, #else, #endif\n\nIn your head, do not interpret these as C code, but imagine their impact on the code presented to compiler."
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-1",
    "href": "c_basics.html#the-c-preprocessor-1",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\n\n#include \"myheader.h\": includes content from myheader.h in current directory verbatim\n#include &lt;math.h&gt;: includes content from math.h in include directory verbatim\nguarantees all source files have same definitions and variable declarations"
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-2",
    "href": "c_basics.html#the-c-preprocessor-2",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nA macro substitution replaces each occurrence of a name with a replacement, for example #define max(A, B) ((A) &gt; (B) ? (A) : (B))\n\nEvery occurence of max(x, y) will be replaced\nUse with care, can make code more readable, but also obfuscate when reading code for the first time\nMacros avoid overhead associated with function call"
  },
  {
    "objectID": "c_basics.html#the-c-preprocessor-3",
    "href": "c_basics.html#the-c-preprocessor-3",
    "title": "Basics of C",
    "section": "The C Preprocessor",
    "text": "The C Preprocessor\nConditional inclusion gives control over preprocessor statements\n// Prevent redefinition\n#ifndef FOUR_PI\n#define FOUR_PI 4 * M_PI\n#endif\n// Use SYSTEM to decide which header is included\n#if SYSTEM == SYSV\n    #define HDR \"sysv.h\"\n#elif SYSTEM == MSDOS\n    #define HDR \"msdos.h\"\n#else\n    #define HDR \"default.h\"\n#endif"
  },
  {
    "objectID": "c_basics.html#variadic-functions",
    "href": "c_basics.html#variadic-functions",
    "title": "Basics of C",
    "section": "Variadic functions",
    "text": "Variadic functions\nTODO"
  },
  {
    "objectID": "c_basics.html#compute-pi-using-monte-carlo",
    "href": "c_basics.html#compute-pi-using-monte-carlo",
    "title": "Basics of C",
    "section": "Compute \\(\\pi\\) using Monte Carlo",
    "text": "Compute \\(\\pi\\) using Monte Carlo\nGoal:\n\nWrite a program that approximates \\(\\pi\\) by using a Monte Carlo algorithm\n\nLearning outcomes:\n\nWrite a loop and use control flow\n\nInstructions:\n\nThe quarter unit circle in the first quadrant has area \\(\\frac{\\pi}{4}\\). Approximate this area by generating uniformly distributed points in \\([0,1] \\times [0,1]\\) (get_random_double is provided) and selecting points inside a unit circle\nHow does the estimate converge with the number of samples?\nSee exercices/06_mc_pi."
  },
  {
    "objectID": "c_basics.html#fibonacci",
    "href": "c_basics.html#fibonacci",
    "title": "Basics of C",
    "section": "Fibonacci",
    "text": "Fibonacci\nGoal:\n\nWrite a program to compute the Fibonacci sequence\n\nLearning outcome:\n\nWrite (recursive) functions\n\nInstructions:\n\nThe Fibonacci sequence is defined by \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) and \\(F_0=0, F_1=1\\)\nCompute the nth element by using a recursive function\nTry to trigger a stack overflow for large n\nWrite a function without recursion\nSee exercises/07_recursion"
  },
  {
    "objectID": "c_basics.html#footnotes",
    "href": "c_basics.html#footnotes",
    "title": "Basics of C",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nKernighan and Ritchie, Chapter 2, Types, operators and expressions↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nA statement is roughly a programming instruction, something to do↩︎\nguaranteed by standard, nowadays most compilers allow longer lengths↩︎\nnot part of the C standard, but quite universal↩︎\nKernighan and Ritchie, Chapter 3, Control Flow↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎\nKernighan and Ritchie, Chapter 4, Functions and Program Structure↩︎\nAdapted from https://github.com/gjbex/Scientific-C↩︎"
  },
  {
    "objectID": "wrapping_up.html",
    "href": "wrapping_up.html",
    "title": "Wrapping up",
    "section": "",
    "text": "Wrapping up"
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  },
  {
    "objectID": "outline.html#outline",
    "href": "outline.html#outline",
    "title": "",
    "section": "",
    "text": "Introduction\n\n\n\nMotivation\n\n\nContext\n\n\nCourse overview\n\n\n\n\n\nJumping in\n\n\n\nHello, world\n\n\nTemperature conversion\n\n\nLogistic map\n\n\n\n\n\n\nBasics of C\n\n\n\nTypes and operators\n\n\nControl flow\n\n\nFunctions\n\n\n\n\n\n\n\n\nAdvanced C\n\n\n\nArrays and pointers\n\n\nStructures\n\n\nInput and output\n\n\n\n\n\n\nBeyond the core of C\n\n\n\nExternal libraries\n\n\nSegmentation faults\n\n\nC standards\n\n\n\n\n\nWrapping up"
  }
]